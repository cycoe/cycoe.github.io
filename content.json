{"meta":{"title":"Cycoe's Home Page","subtitle":"Simple is better than complex. Complex is better than complicated.","description":"Cycoe's Personal Blog","author":"Cycoe","url":"http://cycoe.cc"},"pages":[{"title":"categories","date":"2018-11-13T07:39:24.000Z","updated":"2019-02-28T01:04:14.956Z","comments":true,"path":"categories/index.html","permalink":"http://cycoe.cc/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-11-13T07:34:39.000Z","updated":"2019-02-28T01:04:14.952Z","comments":true,"path":"about/index.html","permalink":"http://cycoe.cc/about/index.html","excerpt":"","text":""}],"posts":[{"title":"反向SSH实现内网穿透","slug":"反向SSH实现内网穿透","date":"2019-04-30T15:42:57.000Z","updated":"2019-05-03T14:07:52.213Z","comments":true,"path":"2019/04/30/反向SSH实现内网穿透/","link":"","permalink":"http://cycoe.cc/2019/04/30/反向SSH实现内网穿透/","excerpt":"","text":"最近实验室又配置了一台新的计算平台，噪声堪比飞机起飞，再加上本校区不允许实验过夜，只能将其安置在学校外面。但从学校到计算平台车程 40Km，每次都过去做计算显然不现实，如果能从学校直接远程连接是最好的。 通过相关资料的查询及对专业人士的请教，找到如下几种解决方法: 联系网络运营商将动态 IP 转为静态的公网 IP，这样就可以直接从学校的内网连接到计算平台，是最完美的解决方案。但是查询资费后发现，价钱不那么完美，一个月 6000 块大洋怎么负担得起啊！ 主机 A 使用 TeamViewer 连接至计算平台局域网下的另一台主机 B，再控制 B 使用 SSH 连接至计算平台。这种方法包含几个明显的弊端： 操作麻烦，需要经过两层的文件传输及控制； 虽然 TeamViewer 有个人的免费使用许可，但最近审查日益严格，经常使用几分钟就被强制下线； TeamViewer 基于 GUI 远程控制，对网络要求很高； 最重要的一点，一个好的解决方案应该形成一个“黑箱”，而不应该把内部细节暴露给用户； 从计算平台使用反向 SSH 连接到云服务器，从而建立起从云服务器到计算平台的隧道连接。这种方法传输的速度上限在于云服务器的带宽，最大的优点在于实现了一个“鸭子类型”，使用 SSH 连接计算平台与连接局域网内的主机无异。 SSH 协议与应用 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 最初是 UNIX 系统上的一个程序，后来又迅速扩展到其他操作平台。SSH 在正确使用时可弥补网络中的漏洞。SSH 客户端适用于多种平台。几乎所有 UNIX 平台—包括 HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行 SSH。 以上对 SSH 的解释来自百度百科，别问我为什么不用 Wikipedia。从中我们看到，SSH 是建立在应用层基础上的一种安全协议，可以用来进行远程控制，或在计算机之间传送文件，比传统的 telnet 或 ftp 协议要更安全。Linux 下最常使用的就是 OpenSSH。OpenSSH 是 SSH 协议的免费开源实现，提供了服务端后台程序（SSH Daemon）和客户端工具(SSH Client)。主机可以通过 SSH 客户端连接运行了 SSH 服务端的主机。 网络拓扑分析互联网是一张巨大的网，其中所有的主机都由有线或无线的方式相连，但并不代表任意两台主机都能互相可见。网络是有方向的，与其说是网我觉得更像一棵树。网络在向下进行传输时，会经过 NAT（Network Address Translation 网络地址转换），因此外网的主机无法直接访问内网的主机。 在我们本次遇到的问题中，网络连接可表示为如下的拓扑结构。 各个主机的 IP 地址如下表所示 主机名 IP 用户名 备注 计算平台 A 10.0.0.100 cal 目标主机，处于内网 控制端 B 192.168.1.100 client 控制主机，处于内网 云服务器 O 123.123.123.123 server 公网服务器，起桥梁作用 其中 A、B 能够访问 O，但 O 不能访问 A、B，并且 A、B 之间不能直接互相访问。我们最后要实现的目标就是使用 B 访问 A。 解决方法通俗地说：就是在主机 A 上做到 O 的反向代理；然后在 O 上做正向的代理实现本地端口的转发。 准备工作A、B、O 上都要安装 SSH Client，A、O 上需要安装 SSH Daemon。 需要用到的 ssh 参数12反向代理ssh -fCNR 12正向代理ssh -fCNL 123456-f 后台执行 ssh 指令-C 允许压缩数据-N 不执行远程指令-R 将远程主机（服务器）的某个端口转发到本地端指定主机的指定端口-L 将本地机（客户机）的某个端口转发到远端指定主机的指定端口-p 指定远程主机的端口 反向代理首先在 A 主机上操作，建立 A 到 O 的反向代理，具体命令为1ssh -fCNR [O 主机 IP 或省略]:[O 主机端口]:[A 主机 IP ]:[A 主机端口] [O 主机的用户名@O 主机 IP] 在这里我使用了 O 主机的 3333 端口，以及 A 主机的 22 端口，按照以上命令即为1ssh -fCNR 3333:localhost:22 server@123.123.123.123 此时我们就将 O 的 3333 端口映射到了 A 的 22 端口，也就是说访问 O 的 3333 端口与访问 A 的 22 端口效果相同。 使用 ps aux | grep 3333 命令来查看反向代理是否运行成功。 正向代理接下来在 O 主机上操作。完成上一步的反向代理后，在主机 O 上运行如下命令应该就可以登陆 A 主机。1ssh -p 3333 cal@localhost 该命令的含义为，使用 cal 用户登陆本机的 3333 端口。上面已经说过，访问 O 的 3333 端口与访问 A 的 22 端口效果相同，那么我们就成功从 O 主机登陆了 A 主机。 但此时我们仍只能从 O 主机本机上登陆 A 主机，无法从其他主机登陆，因此需要再对 3333 端口进行一次端口转发，使其他主机可以访问。具体命令为1ssh -fCNL [O 主机 IP 或省略]:[转发端口]:[O 主机 IP]:[被转发端口] [登陆 O 主机的用户名@O 主机的 IP] 此处我们想要将 3333 端口转发到 2222 端口，因此转发端口为 2222，被转发端口为 3333。1ssh -fCNL *:2222:localhost:3333 localhost 此处 * 表示允许任意其他主机访问，本机的用户名可省略。使用 ps aux | grep 2222 命令来查看正向代理是否运行成功。此处 2222 端口为本地转发端口，负责与外网进行通信，并将数据转发到 3333 端口，实现了可以从其他主机访问的功能。 展现奇迹的时候到了到次为至，我们已经配置好了 AO 主机，那么我们可以从任意可联网的设备登录到计算平台中去啦。指令为1ssh -p 2222 cal@123.123.123.123 我们实现了从任意地方连入内网计算平台的连接！ 这种反向代理是不稳定的不幸的是这种 ssh 连接会因为超时和网络堵塞等原因而关闭，那么从的外网连通内网的通道就无法维持了，为此我们需要维持稳定 ssh 反向代理隧道的方法。 配置 ssh key 实现免密登陆在使用 ssh 进行连接时，每次都需要输入密码，一方面不安全，另一方面也为我们接下来使用的自动化工具带来了阻碍。 首先登陆 A 主机，并运行如下命令生成公钥私钥对。中间的配置过程一路回车即可。1ssh-keygen -t rsa -C \"youremail@example.com\" 此时就在 A 主机的 ~/.ssh/ 目录下生成了公钥与私钥对，接下来我们需要将公钥传到 O 主机上作为我们登陆的一个比对凭证1ssh-copy-id server@123.123.123.123 此时，我们再使用 ssh server@123.123.123.123 登陆路 O 主机就不再需要密码了。 用 autossh 建立稳定隧道从 A 主机到 O 主机的反向代理连接是不稳定的，也就是说，我们需要一个工具来时刻监听着这个连接。一但断开，再次自动重新建立连接即可。幸运的是，已经有人写出了这个工具，那就是 autossh！感谢开源！ CentOS 的官方仓库中并没有这个软件包，我们需要从源码编译安装1234567sudo yum install wget gcc makewget http://www.harding.motd.ca/autossh/autossh-1.4e.tgztar -xf autossh-1.4e.tgzcd autossh-1.4e./configuremakesudo make install 至此我们已经安装好了 autossh，利用下面的命令来启动守护进程。1autossh -M 7200 -fCNR 3333:localhost:22 server@123.123.123.123 autossh 命令的参数与 ssh 一致，不同的是我们需要指出的 -M`` 参数，这个参数指定一个端口，这个端口是外网的 O 主机用来接收内网 A 主机的信息，如果隧道不正常而返回给 A 主机让它实现重新连接。 配置自动启动我们需要将 autossh 命令配置在开机自动启动脚本中，免去了每次开机都需要重新运行脚本的麻烦。 我们需要在 A 主机的 /etc/rc.d/rc.local 文件中添加如下内容1/bin/su -c '/usr/local/bin/autossh -M 7200 -fCNR 3333:localhost:22 server@123.123.123.123' - cal 此命令表示，以 cal 用户运行 autossh 命令，这样我们就能够使用 cal 用户反向连接到 A 主机。 为了保险起见，我们需要为自启动脚本添加执行权限1sudo chmod +x /etc/rc.d/rc.local 至此我们就建立好了稳定的连接隧道。 进一步优化保持活连接在测试中发现，如果一个连接长时间空置，那么就会冻结。反向代理连接也是一样，此时便只能通过重启 A 主机使连接重置。为保持一个活连接（Keep alive），需要服务端或客户端定时发送心跳包来确保连接活跃，此处我们选择配置服务端的心跳。 在 A 和 O 的 /etc/ssh/sshd_config 文件中添加如下内容1234# server 每隔 60 秒发送一次请求给 client，然后 client 响应，从而保持连接ClientAliveInterval 60# server 发出请求后，客户端没有响应得次数达到 3，就自动断开连接，正常情况下，client 不会不响应ClientAliveCountMax 3 Windows SSH Client 连接提示错误使用 Windows 的 SSH Client 连接 Linux 运行的 SSH 服务端时，会提示“ssh algorithm negotiation failed”错误，导致此问题的原因是 ssh 升级后，为了安全，默认不再采用原来一些加密算法，我们手工添加进去即可。 在 O 主机的 /etc/ssh/sshd_config 文件中添加如下内容1234# add crypt format for window ssh clientCiphers aes128-cbc,aes192-cbc,aes256-cbc,aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,arcfour128,arcfour256,arcfour,blowfish-cbc,cast128-cbcMACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-sha1-96,hmac-md5-96KexAlgorithms diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1,diffie-hellman-group-exchange-sha256,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group1-sha1,curve25519-sha256@libssh.org 参考文献 Windows SSH Client 报 Algorithm negotiation failed 的解决方法之一 使用SSH反向隧道进行内网穿透","categories":[],"tags":[]},{"title":"路由器配置教程","slug":"路由器配置教程","date":"2019-04-30T13:19:49.000Z","updated":"2019-04-30T15:31:55.369Z","comments":true,"path":"2019/04/30/路由器配置教程/","link":"","permalink":"http://cycoe.cc/2019/04/30/路由器配置教程/","excerpt":"","text":"初次使用拿到新的路由器之后，首先检查外包装是否有破损、路由器是否有划痕、插头是否有使用痕迹、插上电源后指示灯是否正常亮起，以此初步判断路由器是否是全新的，在某东平台上买电子产品要尤其注意。。。 好吧扯远了。。。路由器其实可以算作是一台独立的微型计算机，运行着定制的操作系统（针对路由器我们叫固件）。但路由器又与我们平常见到的电脑不同，因为它没有标准输入输出设备，也就是键盘鼠标和显示器。那我们要怎么对路由器进行控制呢，其实有很多种方式，但无论的使用哪种方式，我们都需要首先连接上路由器。 为路由器插上电 连接路由器的方式有两种——有线和无线连接。任选其一即可。 有线连接：使用网线一头连接路由器的 LAN（Local Area Network）口，一头连接电脑的网线口 无线连接：打开 Wi-Fi 并连接路由器，一般初始名字为 “TP-LINK_XXX” 在浏览器中输入 192.168.1.1 打开路由器管理界面（也可能是其他 IP 地址，一般在路由器底部的标签上可以看到） 这个时候，根据配置向导对路由器进行配置即可。需要注意的是对于校园网，在 WAN 口连接方式中，选择“动态IP”选项。其他的 SSID 名（也就是平常说的 Wi-Fi 名）及密码等根据需要进行配置即可 高级配置在路由器管理页面中，我们可以看到非常多的配置选项。虽然平常在家庭使用中我们只会用到其中的几个选项，但对于实验室这样一个需要对几十台设备进行管理的场景，里面的一些选项就会非常有用了。 静态 IP 地址绑定这是我最常用到的一个功能，通俗的讲就是将一个设备的 IP 的地址固定下来。一个设备在通过路由器连入互联网时，路由器会通过 DHCP（Dynamic Host Configuration Protocol 动态主机设置协议）服务为每个设备随机分配 IP 地址，并且每过一段时间就会改变。那么我们想在局域网中找到另一台设备就需要通过 IP 地址，而静态 IP 地址绑定就是要告诉路由器，我想为一台特定设备分配一个固定的 IP 地址，那么我以后就可以通过这个固定的 IP 地址来找到这台设备。 现在的路由器几乎都有这个功能，一般是在基本设置-LAN 设置-静态地址分配中进行设置。其中“MAC 地址”是设备的硬件地址，是一串唯一的 12 位的十六进制数，在设备出厂时就确定好了。可通过我写的小程序获得。“IP 地址”是你希望该设备使用的 IP 地址。 路由器桥接","categories":[],"tags":[]},{"title":"从自然数开始","slug":"从自然数开始","date":"2019-02-28T02:05:58.000Z","updated":"2019-04-04T08:51:24.240Z","comments":true,"path":"2019/02/28/从自然数开始/","link":"","permalink":"http://cycoe.cc/2019/02/28/从自然数开始/","excerpt":"","text":"素数（Prime）对于一个自然数 $n\\in\\mathbb{N}$，若其只能被 $1$ 和它本身整除（即只有两个因子），则被称为素数；若其有多于两个因子，则被称为合数。素数是不能够进行质因式分解的最小单元，因此合数具有唯一的质因式分解（质因子不可再分）。 1 的特殊性1 能够被 $1$ 及其自身整除，但为了体系的自洽，不认为 $1$ 是素数。有如下两个原因： 若 $1$ 是素数，则任意自然数的质因式分解将不是唯一的。$6=2\\times 3=1\\times 2\\times 3$。 任意素数 $p$ 可被分解为 $p=1\\times p$，若 $1$ 为素数，则 $p$ 为合数，与 $p$ 为素数相矛盾。 寻找素数针对素数，我们希望研究： 对于任意 $n\\in \\mathbb{N}$，判断其是否为素数； 对于任意 $n\\in \\mathbb{N}$，找到所有小于 $n$ 的素数，或等价于求小于 $n$ 的素数的个数； 对于任意 $n\\in \\mathbb{N}$，求其质因式分解。 质因式分解前几天，看杂志时发现一个有趣的问题，“对任意一个自然数 $n$，如何求其所有因子的和”。这个问题本身并不困难，但从中可以继续思考质数的相关规律。 既然是要求因子的和，那么我们首先需要用数学语言将因子表示出来。在此之前，我们需要先将这个自然数表示出来。 设 $n$ 有 $m+1$ 个质因子 $p_0 &lt; p_1 &lt; \\cdots &lt; p_m$，则存在如下唯一的质因式分解 n = p_0^{a_0} \\times p_1^{a_1} \\times \\cdots \\times p_m^{a_m}则 $n$ 的因子 $f$ 满足 f = p_0^{b_0} \\times p_1^{b_1} \\times \\cdots \\times p_m^{b_m}其中 \\left\\{\\begin{array}{c} 0 \\leq b_0 \\leq a_0\\\\ 0 \\leq b_1 \\leq a_1\\\\ \\vdots\\\\ 0 \\leq b_m \\leq a_m \\end{array}\\right.,\\ 且\\ b_0, b_1, \\cdots, b_m \\in \\mathbb{N}记所有质因子之和为 $S(n)$，即为所有满足上式的 $f$ 之和 \\begin{split} S(n) &= (p_0^0+p_0^1+\\cdots+p_0^{a^0})\\times (p_1^0+p_1^1+\\cdots+p_1^{a^1})\\times \\cdots \\times (p_m^0+p_m^1+\\cdots+p_m^{a^m})\\\\ &= \\dfrac{p_0^{a_0+1}-1}{p_0-1}\\times \\dfrac{p_1^{a_1+1}-1}{p_1-1}\\times \\cdots \\times\\dfrac{p_m^{a_m+1}-1}{p_m-1}\\\\ &= \\prod\\limits_{i=0}^m \\dfrac{p_i^{a_i+1}-1}{p_i-1} \\end{split}至此，我们已经得到已知自然数 $n$ 所有因子和 $S(n)$ 的表达式。接下来验证一下，$24$ 的所有因子有 $1, 2, 3, 4, 6, 8, 12, 24$，求和得 $S_1(24)=60$。$24$ 的质因式分解为 $24=2^3\\times3^1$，则 $S_2(24)=(2^0+2^1+2^2+2^3)\\times(3^0+3^1)=60$。答案正确！ 但通过观察发现，表达式的值并不直接与 $n$ 相关，而是与 $n$ 的所有质因子相关。我们知道，因式分解是一个 NPC 问题，我们无法在多项式时间内对 $n$ 进行因式分解。那么，我们有没有办法对 $S(n)$ 进行粗略的估计呢？即有没有办法用 $n$ 来表示 $S(n)$ 的上下界？或者更具体的，$S(n)$ 与 $n$ 是否存在某种倍数关系？ 对 $S(n)$ 的表达式进行缩放我们得到 \\begin{split} S(n) &= \\dfrac{p_0^{a_0+1}-1}{p_0-1}\\times \\dfrac{p_1^{a_1+1}-1}{p_1-1}\\times \\cdots \\times\\dfrac{p_m^{a_m+1}-1}{p_m-1}\\\\ &< \\dfrac{p_0^{a_0+1}}{p_0-1}\\times \\dfrac{p_1^{a_1+1}}{p_1-1}\\times \\cdots \\times\\dfrac{p_m^{a_m+1}}{p_m-1}\\\\ &= \\dfrac{p_0}{p_0-1}\\times \\dfrac{p_1}{p_1-1}\\times \\cdots \\times\\dfrac{p_m}{p_m-1}\\times n \\end{split}得到 \\dfrac{S(n)}{n} < \\dfrac{p_0}{p_0-1}\\times \\dfrac{p_1}{p_1-1}\\times \\cdots \\times\\dfrac{p_m}{p_m-1} = \\Pi_p(m)接下来，我们希望知道两件事 对于任意大的 $m$，$\\Pi_p(m)$ 是否存在上界，若 $\\Pi_p(m)$ 的上界存在，则 $\\dfrac{S(n)}{n}$ 的上界存在。 若$\\Pi_p(m)$ 的上界不存在，那么对于确定的 $n$，我们能否得到 $\\dfrac{S(n)}{n}$ 的上界。 首先来解决第一个问题。使用计算机进行计算发现，前 $2^k$ 个质数的 $\\Pi_p(2^k)$ 与 $k$ 呈近似线性关系 \\Pi_p(2^k) = ak + b另外 $2^k$ 以内的质数的分式乘积 $\\Pi_p(\\eta)$ 也与 $k$ 呈近似线性关系。 设 $\\Pi(n)$ 为前 $n$ 个自然数的类似分式积表达式 \\Pi(n) = \\dfrac21 \\times \\dfrac32 \\times \\cdots \\times \\dfrac{n}{n-1} = n则前 $n$ 个质数的 $\\Pi(n)$ 与 $n$ 呈线性关系。 一个为质数， 一个为自然数，其中必然蕴含着质数分布的某种真理。","categories":[{"name":"Math","slug":"Math","permalink":"http://cycoe.cc/categories/Math/"}],"tags":[{"name":"Math, Algorithm","slug":"Math-Algorithm","permalink":"http://cycoe.cc/tags/Math-Algorithm/"}]},{"title":"正交試驗設計","slug":"正交试验设计","date":"2018-11-13T00:35:52.000Z","updated":"2019-02-28T01:08:30.202Z","comments":true,"path":"2018/11/13/正交试验设计/","link":"","permalink":"http://cycoe.cc/2018/11/13/正交试验设计/","excerpt":"","text":"正交試驗設計是利用正交表來安排與分析多因素試驗的一種設計方法。它是由試驗因素的全部水平組合中，挑選部分有代表性的水平組合進行試驗的，通過對這部分試驗結果的分析瞭解全面試驗的情況，找出最優的水平組合。可以通過代表性很強的少數次試驗，摸清各個因素對試驗指標的影響情況，確定出因素的主次順序，找出較好的生產條件或最佳參數組合。 正交表的性質正交性 均勻分散性：任一列中，不同數字出現的次數相等； 整齊可比性：任兩列中，同一橫行所組成的數字對出現的次數相等； 可置換性： 正交表各列的地位是平等的，表中各列之間可以相互置換，稱爲列間置換； 正交表各行之間也可相互置換，稱列間置換； 正交表中同一列的水平數字也可以相互置換，稱水平置換。 分散均勻性 任一列的各水平都出現，使得部分試驗中包含所有因素的所有水平； 任意兩列間的所有組合全部出現，使任意兩因素間都是全面試驗。 綜合可比性 任一列各水平出現的次數都相等； 任兩列間所有可能的組合出現的次數都相等，因此使任一因素各水平的試驗條件相同。 拉丁方陣拉丁方陣（Latin square）是一種 $n\\times n$ 的方陣，在這種 $n\\times n$ 的方陣裏，恰有 $n$ 種不同的元素，每一種不同的元素在同一行或同一列裏只出現一次。如下面的三階拉丁方。 \\begin{bmatrix} 1 & 2 & 3\\\\ 2 & 3 & 1\\\\ 3 & 1 & 2\\\\ \\end{bmatrix}標準型當一個拉丁方陣的第一行與第一列的元素按順序排列時，此爲這個拉丁方陣的標準型，英語稱爲 “reduced Latin square, normalized Latin square, or Latin square in standard form”。 構造拉丁方同階的拉丁方有多個，構造其中的一個有一種通用的方法。 若 $n$ 爲偶數，則構造第一行爲 $1, 2, n, 3, n-1, 4, n-2, \\dots$，之後的每一行都在上一行對應列元素上加一併對 $n$ 取模，即可表示爲如下矩陣。 \\begin{bmatrix} 1 & 2 & n & 3 & n-1 & 4 & n-2 & \\cdots\\\\ 2 & 3 & n+1 & 4 & n & 5 & n-1 & \\cdots\\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\ i & i+1 & i+n-1 & i+2 & i+n-2 & i+3 & i+n-3 & \\cdots\\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\ n & 1 & n-1 & 2 & n-2 & 3 & n-3 & \\cdots\\\\ \\end{bmatrix} \\mathrm{mod}\\ n若 $n$ 爲奇數，則先按偶數法則構造一個拉丁方，然後將上述模式左右對調。 正交拉丁方設有兩個階數相同且爲 $n$ 的拉丁方陣$A_1=(a^{(1)}_{i,j})_{n\\times n}, A_2=(a^{(2)}_{i,j})_{n\\times n}$，其中將所有放置位置相同的元素組合成一個元組，組合成一個新的矩陣 $((a^{(1)}_{i,j}, a^{(2)}_{i,j}))_{n\\times n}$。當這個新的矩陣 $((a^{(1)}_{i,j}, a^{(2)}_{i,j}))_{n\\times n}$ 中每一個元素互不相同時，拉丁方陣 $A_1$ 和 $A_2$ 是互相正交的。此時，$A_1$ 和 $A_2$ 即爲一對正交拉丁方。 而在階數固定的情況下，所有兩兩正交的拉丁方所成的集合稱爲正交拉丁方族。如下面的兩個 3 階拉丁方。 \\begin{matrix} A = \\begin{bmatrix} 1 & 2 & 3\\\\ 2 & 3 & 1\\\\ 3 & 1 & 2\\\\ \\end{bmatrix} & B = \\begin{bmatrix} 1 & 2 & 3\\\\ 3 & 1 & 2\\\\ 2 & 3 & 1\\\\ \\end{bmatrix} \\end{matrix}素數階拉丁方若 $n$ 階拉丁方存在 $r$ 個兩兩正交的拉丁方，那麼 $r\\leq n-1$。素數階拉丁方（以 $3, 5, 7, \\dots$ 爲階）是完全的，即 $n$ 階正交拉丁方族中有 $n-1$ 個拉丁方。 構造正交表因爲素數階拉丁方都可構造完全的正交拉丁方族，則可繼續構造正交表。若把素數 $n$ 作爲水平數，則以 $n$ 階拉丁方構造的正交拉丁方有 $n-1$ 個。以 $n-1$ 作爲因素數構造正交表。 以 3 階拉丁方爲例，3 階正交拉丁方族包含 2 個正交拉丁方，並將對應位置元素合併成二元有序數對。 \\begin{matrix} \\begin{bmatrix} 1 & 2 & 3\\\\ 2 & 3 & 1\\\\ 3 & 1 & 2\\\\ \\end{bmatrix} & \\begin{bmatrix} 1 & 2 & 3\\\\ 3 & 1 & 2\\\\ 2 & 3 & 1\\\\ \\end{bmatrix} & = & \\begin{bmatrix} 11 & 22 & 33\\\\ 23 & 31 & 12\\\\ 32 & 13 & 21\\\\ \\end{bmatrix} & \\end{matrix}以第一個元素作爲因素 A，第二個元素作爲因素 B，然後與因素 C、D 均勻搭配，構造 4 因素 3 水平正交表。 C, A, B, D 1 2 3 1 11 22 33 2 23 31 12 3 32 13 21 展開後爲 試驗號 A B C D 1 1 1 1 1 2 1 2 2 2 3 1 3 3 3 4 2 2 3 1 5 2 3 1 2 6 2 1 2 3 7 3 3 2 1 8 3 1 3 2 9 3 2 1 3 若只與一個因素 C 搭配，則可構造 3 因素 3 水平正交表。 C, A, B 1 11 22 33 2 23 31 12 3 32 13 21 展開後爲 試驗號 A B C 1 1 1 1 2 1 2 2 3 1 3 3 4 2 2 3 5 2 3 1 6 2 1 2 7 3 3 2 8 3 1 3 9 3 2 1 由此可見，以素數 $n$ 爲水平數設計正交試驗，可滿足 $[n-1, n+1]$ 個因素的設計，並且總共需要 $n^2$ 次試驗。即對於 3 因素 3 水平與 4 因素 3 水平正交試驗具有相同的試驗組數，同爲 9 組。可類似地構造出 $L_9(3^3)$，$L_9(3^4)$，$L_{25}(5^5)$，$L_{25}(5^6)$，$L_{49}(7^7)$，$L_{49}(7^8)$ 等。 參考資料 百度百科-拉丁方 百度百科-正交拉丁方 百度百科-拉丁方設計 正交表與正交設計","categories":[{"name":"statistics","slug":"statistics","permalink":"http://cycoe.cc/categories/statistics/"}],"tags":[{"name":"statistics","slug":"statistics","permalink":"http://cycoe.cc/tags/statistics/"}]},{"title":"Linux下常用軟件和配置記錄","slug":"Linux下常用软件和配置记录","date":"2018-11-09T14:22:31.000Z","updated":"2019-05-03T14:01:44.436Z","comments":true,"path":"2018/11/09/Linux下常用软件和配置记录/","link":"","permalink":"http://cycoe.cc/2018/11/09/Linux下常用软件和配置记录/","excerpt":"","text":"隨着使用 Linux 系統的年頭越來越長，積累的相關技巧也越來越多。最近一次重裝系統突然發現很多配置都已經忘的差不多了，想要配置系統還需要去網上到處搜刮資料實在是麻煩，因此打算用一篇博客記錄關於 Linux 系統的配置及常用軟件的介紹。 Archlinux 配置讓 Qt5 程序使用原生 GTK+ 主題Qt5 程序在 GTK3 環境下主題不統一真的很難受，尤其是 GTK3 用了黑色主題而 Qt5 還是刺眼的白色主題的時候。不像在 KDE 設置中設置 GTK3 主題那麼方便，設置 Qt5 主題可需要好好折騰一番。而且這個解決方案也是我使用了近一年後才找到的答案。 首先你需要安裝 qt5ct 來提供 Qt5 程序主題的設置入口。此時直接在應用列表中打開 qt5ct 會提示未設置環境變量，編輯 .xprofile 文件，並在其中加入如下內容1[ \"$XDG_CURRENT_DESKTOP\" = \"KDE\" ] || [ \"$XDG_CURRENT_DESKTOP\" = \"GNOME\" ] || export QT_QPA_PLATFORMTHEME=\"qt5ct\" 註銷後重新登錄，此時打開 qt5ct 應該就不報錯了。但此時你會發現主題列表中只有 Qt5 自帶的幾個樣式，而沒有 Gtk3 主題。你需要安裝 qt5-styleplugins 來使 Qt5 支持 GTK2 主題。你沒有看錯，我也不知道爲啥 Qt5 只支持 GTK2 的主題。但是我們要如何設置 GTK2 主題呢，好吧，又需要安裝一個叫 gtk-theme-switch2 的工具。在 gtk-theme-switch2 中設置好滿意的 GTK2 主題後，再在 qt5ct 中設置 Qt5 主題爲 GTK2 即可。 常用軟件用了幾年 Linux 後發現其實 Linux 平臺的軟件並不少（當然 Adobe 全家桶和 MS Office 除外，要做設計或者辦公還是老老實實 Windows 吧:speak_no_evil:），只是與 Windows 和 Mac 平臺常用的軟件不同而已。Linux 的真正強大之處是命令行軟件，幾條簡單的命令組合就可以完成複雜的功能。 小鹤双拼每次重装系统都需要重新配置输入法，更蛋疼的是在 Rime 中添加鹤形码表时，总出现部署错误。虽然最后折腾半天总是莫名其妙地整好了，但是不得不感叹配置 Rime 真是玄学（虽然很不想承认是自己对 Rime 的配置文件一窍不通:laughing:）。特此记录一下给 Rime 添加鹤形的过程，虽然以后按相同的步骤也不一定能配置成功。 第一步，安装 fcitx 框架（ibus 框架就不考虑了，fcitx 用习惯了）和 Rime 的 fcitx 实现。1234# Archlinuxsudo pacman -S fcitx fcitx-rime fcitx-configtool# openSUSEsudo zypper in fcitx fcitx-rime fcitx-config-gtk 第二步，在 fcitx 设置中加入 rime 输入法，记得关闭“只显示当前语言输入法选项”。切换到 Rime 输入法，此时应该会自动运行一次 deploy。 第三步，将我的配置中的 .config/fcitx 目录复制到对应的路径，其中已经包含了 flypy 使用的码表（之前小鹤双拼官网发布的挂接码表文件，但因为没有通用的配置方法目前已经下架），并将运行下面的命令将配置文件复制到 Rime 系统级路径中（尝试过复制到 .config/fcitx/rime/build/default.custom.yaml，没有效果）。1234# 备份原配置sudo mv /usr/share/rime-data/default.yaml /usr/share/rime-data/default.yaml.bak# 复制新配置sudo cp default.yaml /usr/share/rime-data/default.yaml 第四步，在 fcitx 上右键，选择 deploy，此时会提示部署错误，但是惊喜地发现输入法已经可以使用。 常用软件用了几年 Linux 后发现其实 Linux 平台的软件并不少（当然 Adobe 全家桶和 MS Office 除外，要做设计或者办公还是老老实实 Windows 吧:speak_no_evil:），只是与 Windows 和 Mac 平台常用的软件不同而已。Linux 的真正强大之处是命令行软件，几条简单的命令组合就可以完成复杂的功能。 Dia一個非常小的流程圖繪製軟件，但是功能夠用。 ncduncdu (NCurses Disk Usage) 是一個基於 NCurses 系統的磁盤用量分析命令行軟件，相似功能的還有基於 GTK+ 的 Baobab（從版本號來看應該是屬於 Gnome 桌面套裝）。其實對我來說真的很少使用此類軟件，畢竟我很少刪除磁盤文件，但是最近 /Home 分區接近爆滿讓我很難受，還是需要從磁盤的角落翻出以後再也用不上的大文件以刪除之。 xreaderpdf 文檔閱讀器，X-Apps 計劃中的一員（這個計劃好像只有個閱讀器？:laughing:）。體積小巧，優點是可以使用 hjkl 等 vim 鍵位進行控制。缺點是沒有高級功能，單純作爲一個閱讀器還是不錯的。 pcmanfmLXDE 桌面環境默認文件管理器，實話說比 Gnome 的鸚鵡螺好用太多，功能上與 Dolphin 相近。Archlinux 上有單獨提供 pcmanfm-gtk3 的安裝包，其他髮型版上應該默認使用的就是 GTK3 了。 lxappearanceGTK+ 界面主題設置工具，又是 LXDE 的一員。LXDE 自帶的幾款軟件質量都挺高，界面風格統一併且功能強大。 gpickviewLXDE 默認的圖片查看器，體積小巧，沒有太多花哨功能。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cycoe.cc/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://cycoe.cc/tags/Linux/"}]},{"title":"一種通過最小二乘法求轉變點的方法","slug":"一种通过最小二乘法求转变点的方法","date":"2018-10-23T13:52:47.000Z","updated":"2019-02-28T01:03:03.816Z","comments":true,"path":"2018/10/23/一种通过最小二乘法求转变点的方法/","link":"","permalink":"http://cycoe.cc/2018/10/23/一种通过最小二乘法求转变点的方法/","excerpt":"","text":"最小二乘法假設存在 k 個樣本點 \\(X_1, X_2, \\ldots, X_k\\)，定義向量\\(X_i = (x_{i1}, x_{i2}, \\ldots, x_{in})^T\\)，爲方便計算在 \\(X_i\\) 前插入常量 1。則需要求 \\(W = (w_0, w_1, w_2, \\ldots, w_n)\\) 使 \\(\\hat{Y} = XW\\)。 定義均方誤差 \\(E = \\dfrac{1}{n}\\sum(y_i-\\hat{y}_i)^2 = \\dfrac{1}{n}||Y-\\hat{Y}||_2^2\\)，則可轉變爲尋找 W 使得 E 最小，即尋找 \\(W = \\mathrm{argmin}\\dfrac{1}{n}||Y-XW||_2^2\\)。 對於 E(W) = \\dfrac{1}{n}則可推導 \\begin{align} E(W+\\Delta W) - E(W) &= \\dfrac{1}{n}||Y-X(W+\\Delta W)||_2^2-\\dfrac{1}{n}||Y-XW||_2^2\\\\ &= \\dfrac1n||Y-XW||_2^2-\\dfrac2n(Y-XW)(X\\Delta W)+\\dfrac1n||X\\Delta W||_2^2-\\dfrac1n||Y-XW||_2^2\\\\ &= \\dfrac2n(XW-Y)X\\Delta W+\\mathcal{O}(||\\Delta X||)\\\\ \\end{align}令 L(W) = \\dfrac2n(XW-Y)X\\Delta W爲 \\(E(W)\\) 在 \\(W\\) 處的導數，同時 \\begin{align} L(\\Delta W) &= \\\\ &= \\\\ &= \\dfrac2n(XW-Y)X\\Delta W\\\\ \\end{align}則 \\begin{align} \\nabla E(W) = \\dfrac2nX^T(XW-Y) &= 0\\\\ X^TXW &= X^TY\\\\ W &= (X^TX)^{-1}X^TY \\end{align}最終得 E=\\dfrac1n||Y-\\hat{Y}||_2^2=\\dfrac1n||X(X^TX)^{-1}X^TY-Y||_2^2","categories":[],"tags":[{"name":"算法 線性代數 粒子羣優化","slug":"算法-線性代數-粒子羣優化","permalink":"http://cycoe.cc/tags/算法-線性代數-粒子羣優化/"}]},{"title":"Nocturnal使用說明","slug":"Nocturnal使用说明","date":"2018-09-05T16:00:00.000Z","updated":"2019-02-28T01:03:02.789Z","comments":true,"path":"2018/09/06/Nocturnal使用说明/","link":"","permalink":"http://cycoe.cc/2018/09/06/Nocturnal使用说明/","excerpt":"","text":"Nocturnal by CycoeGitHub 地址如果在使用過程中發現 bug，可到此處進行反饋，或者直接提交修復 PR，感謝支持！ 聲明Nocturnal 是我課餘時間練習 python 代碼編寫的程序，針對使用引起的一切後果本人概不負責。 關於捐贈Nocturnal 不併強制要求捐贈，但爲了防止軟件被濫用而出現的一系列問題，因此需要提供解密密鑰才能使用，具體操作如下： 打開軟件，此時會自動彈出一個命令提示符窗口和一個二維碼 微信掃描二維碼添加我爲好友 你能在命令提示符窗口上看到類似這樣一段話 12你的 id 爲 2160。請將 id 發給開發者獲取解鎖密鑰請輸入解密密鑰: 將其中的 id 發給我，我會生成解密密鑰 輸入密鑰後即可使用 （可選）如果你覺得這個軟件給你帶來了便利，你可以給開發者包個紅包，建議 5 元 使用說明命令幫助 命令全稱 縮寫 描述 help h 打印幫助信息 emailLogin el 綁定通知郵箱 grade g 成績抓取模式 report r 選報告模式 class c 選課模式 add a 添加待選課程名稱 delete de 刪除待選課程名稱 list l 列出待選課程名稱 donate d 捐贈 quit q 退出 以上表格第一列爲命令的全稱，第二列爲命令的縮寫，輸入全稱與縮寫擁有同樣的效果。 軟件符號說明Nocturnal 使用字符界面（TUI）進行交互，雙擊 Nocturnal.exe 打開軟件後可看到一個黑底白字的字符界面，這不是因爲軟件運行出錯，而是 Nocturnal 本來就是這樣的。現在你應該能在界面上看到一些表格，最上面的表格爲 Nocturnal 的基本信息，中間的表格爲使用幫助。在最下方你可以看到類似這樣的提示符 [0] &gt;&gt;&gt;，該提示符表明此時你可以輸入命令運行相關功能，[0] 中的數字表示後臺正在運行的任務數量。 成績抓取模式在 [0] &gt;&gt;&gt; 後輸入 grade 或 g 回車即可運行成績抓取功能。第一次使用時會自動提示你輸入用戶名和密碼，也就是你的教務網學號和密碼。運行成功後不會有提示，但 Nocturnal 就會在後臺自動抓取成績，並在出新成績時自動通知。 選報告模式在 [0] &gt;&gt;&gt; 後輸入 report 或 r 回車即可運行選報告模式，運行成功後 Nocturnal 會在後臺自動抓取報告列表，並在有新報告放出時自動選報告，並通過郵件通知你。 選課模式選課模式與成績抓取模式和選報告模式不同，選課模式需要在前臺運行。選課模式通過匹配關鍵字實現，針對每門課程可以添加多個關鍵字。比如你想要選 ‘高分子研究方法’ 這門課，則可以在一級關鍵字後輸入 ‘高分子研究方法’ 並回車。但一般課程會有多個時間開課，如果想要指定特定時間或特定老師的課程，則可在二級關鍵字後輸入 ‘週一’ 或 ‘某某某老師’ 即可。Nocturnal 會首先檢查一級關鍵字，如果一級關鍵字對應多個候選，那麼會繼續以二級關鍵字進行過濾，優先選擇符合二級關鍵字的候選。但如果二級關鍵字過濾後沒有可選課程，那麼會返回一級關鍵字的候選列表，並隨機選取一個候選作爲最終選擇。總而言之，Nocturnal 中的關鍵字列表並不是選課的唯一列表，而是一個優先列表，Nocturnal 會按關鍵字列表所給的優先順序依照選取所有可選課程。 注意：選課模式還未經過測試，選課完成後務必登錄教務網檢查已選課程。 具體流程如下： 輸入 a 回車添加需要選的課程名稱，輸入 a 後提示如下：123[0] &gt;&gt;&gt; aplease input 1th key&gt; &gt; 表示此時你可輸入一級關鍵字，一般我們會將課程名稱作爲一級關鍵字，如此時你可輸入 ‘高分子研究方法’ 回車添加一個關鍵字，完成後程序會提示你輸入二級關鍵字如下：12345[0] &gt;&gt;&gt; aplease input 1th key&gt; 高分子研究方法please input 2th key&gt; 此時你可直接輸入回車來結束關鍵字的輸入（在輸入任一關鍵字時，你都可通過直接回車來結束輸入），或者輸入 ‘週六’ 回車作爲想要上課的時間。 重複以上步驟直至你輸入了所有想要選的課程。 輸入 l 查看已經輸入的課程列表 輸入 d 刪除不想選的課程 郵件通知Nocturnal 目前只有通過郵箱一種方式對你進行通知，你可通過輸入 el 來綁定郵箱，Nocturnal 會提示你一步一步進行操作。&lt;接收郵箱&gt;爲你要接收通知的郵箱，建議使用 qq 郵箱，這樣使用微信綁定 qq 郵箱後就可以的即時地收到郵件通知消息。&lt;發送郵箱&gt;可以使用任意郵箱，但發送郵箱需要輸入密碼。 爲發送郵箱的主機地址，qq 郵箱對應的是 ‘smtp.qq.com’，163 郵箱對應 ‘smtp.163.com’，其他郵箱請自行百度。&lt;端口&gt; 默認值爲 ‘25’（注意：使用端口 25 意味着不使用 SSL 加密，希望郵件加密的同學請自行百度）。每步輸入過程中，提示符後括號中爲原始值，如果你不希望更改原始值，直接回車即可。 更新日誌Date: 2017-1-3Version: V4.0 Date: 2017-12-15Version: V3.1 [bug fix] 修復掉線後不能重新登錄的問題 修復達到最大重試次數後不會自動停止的問題 [optimization] 重新登錄時清理內存 簡化代碼結構 新增等待時的動畫效果 完善自定義郵箱登錄 Date: 2017-12-14Version: V3.0 [bug fix] 修復選報告時的崩潰問題 [optimization] 重磅更新！新增驗證碼自動識別，花了大力氣才寫出來，現在無需手動輸入驗證碼登錄 更新了選報告的入口，優化了休眠邏輯 命令行提示已漢化 優化郵件提醒，現在只會發送最新選到的報告列表 新增報告黑名單，選到的報告自動加入黑名單列表中，防止手動退了後又重複選上 新增捐贈入口，希望大家多多支持！ 打包成安裝文件，不用再手動解壓","categories":[{"name":"python","slug":"python","permalink":"http://cycoe.cc/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://cycoe.cc/tags/python/"}]},{"title":"Vim- 一款讓我相見恨晚的編輯器","slug":"Vim-一款让我相见恨晚的编辑器","date":"2018-08-12T14:34:49.000Z","updated":"2019-02-28T01:03:03.776Z","comments":true,"path":"2018/08/12/Vim-一款让我相见恨晚的编辑器/","link":"","permalink":"http://cycoe.cc/2018/08/12/Vim-一款让我相见恨晚的编辑器/","excerpt":"","text":"Vim 簡介 Vim is a greatly improved version of the good old UNIX editor Vi. Many new features have been added: multi-level undo, syntax highlighting, command line history, on-line help, spell checking, filename completion, block operations, script language, etc. There is also a Graphical User Interface (GUI) available. 以上關於 Vim 的描述來自 Vim 的官方 GitHub 倉庫。Vim 是一款古老且強大的編輯器，從其誕生之日起到現在已經有二十多年的歷史（比我的年齡都要大 orz）。很多人聽說它的大名一般是因爲它與 Emacs 並稱編輯器之神與神之編輯器。爲什麼會有這樣的名號？除了它們的功能極其強大之外，還因爲它們極其難以上手。以下圖片爲網友戲稱的常用編輯器的學習曲線。 即便如此，Vim 和 Emacs 仍流行到了現在，以至於後來經常能在各處看到的 Vimer（Vim 黨）和 Emacser（Emacs 黨）的編輯器之爭，雖然有的時候可能只是類似於“php 是世界上最好的語言”之類的梗，但足以看出 Vim 確實非常強大，並且用上了就再也回不去了。 安裝 VimVim 在所有的 Linux 發行版上都易於獲得，只需要使用對應的包管理器進行安裝即可，Windows 上也有編譯好的二進制包，但實際在安裝過程中仍會面臨幾個選擇。 以 Archlinux 爲例，Archlinux 的官方倉庫中包含的 Vim 在編譯過程中並沒有編譯進 python、lua 等支持，導致很多插件無法使用，因此爲了能使用上 Vim 的完全體，可以選擇 Gvim。Gvim 是基於 Vim 的一個帶有圖形界面的版本，並在編譯過程中包含進了所有可用組件。如果選擇 Vim 分支，強烈建議使用 Gvim，並且使用 8.0 之後的版本。下載鏈接在此處。 另一個可供選擇的版本是 Neovim，Neovim 是 Vim 的一個 fork 版本，比 Vim 具有更多的特性（Neovim 先首先支持的異步架構和內置 terminal，隨後 Vim 也提供了支持），目前開發活躍，推薦進行嘗試。下載鏈接在此處。 以上的所有版本在下文中都將統一稱爲 ‘Vim’（雖然事實上 Vim 與 Neovim 並不是同一個項目，但在配置和使用方法上是類似的）。無論安裝哪個版本，安裝完成後從應用啓動菜單或命令行應該就能成功啓動。恭喜你！此時已經完成了安裝 Vim 的第一步，現在你看到的是一個黑底白字的字符界面。不過彆着急，接下來我們會一步一步將 Vim 配置成稱手的編輯器。 退出 Vim - 使用 Vim 的第一大難題？雖然客觀上講，退出 Vim 相較於 Vim 其他功能要容易的多，但是確實是第一次使用 Vim 會遇到的一個問題。相對於其他的編輯器，Vim 沒有直觀的退出方式，以至於在 Stack Overflow 上有個專門的問題（見此處）解答如何退出 Vim。甚至有了如下的梗： 看來確實有必要對 Vim 的退出方式做個總結，之列出平常最常用的幾種退出方式 :q 正常退出 :q! 強制退出不保存 :wq 保存並退出 :x 保存並退出，與 :wq 不同之處在於如果文件未做修改則不更新時間戳 強制關機 使用 Vim 前先看幫助文檔安裝好 Vim 後，你可能想要馬上嘗試輸入。但我強烈建議先閱讀軟件自帶的幫助文檔，一款優秀的軟件都會帶有一個詳細的用戶手冊以及一個簡要的使用說明，這有助於降低你在接觸新軟件時的痛苦感。你可以在 Vim 中隨時通過輸入 :help&lt;CR&gt;（ 代表回車）來呼出幫助文檔。 配置 Vim - 從 .vimrc 開始由於 Vim 的流行，GitHub 上有各種各樣現成的 ‘vimrc’（Vim 的配置文件）可供使用。對於不想自己折騰配置的用戶來說，從 GitHub 上下載安裝其他用戶已經編輯好的 ‘vimrc’ 是最好的選擇。甚至還有像 SpaceVim 這樣的模塊化 Vim 配置可以一鍵安裝使用，能大大減少配置所需的時間。 另一些用戶可能想要繼續對 Vim 進行自定義配置，那麼就需要對 ‘vimrc’ 進行修改。在 Linux 系統中，Gvim 與 Vim 的配置文件默認存放在 ‘$HOME/.vimrc’（Neovim 存放在 ‘$HOME/.config/nvim/init.vim’），Windows 下存放在 ‘$VIM/vimrc’。 你可以選擇自己新建一個文件從頭開始。不過還是建議拷貝官方自帶的配置示例，一方面可以省去一部分對常規配置的修改時間，另一方面，官方示例中對各配置語句對應有詳細的註釋。或者也可以選擇從 GitHub 上尋找一個適合你的 ‘vimrc’，或者參考我的配置。 常規配置在使用 Vim 之前，我們需要對其進行一些常規配置，來使它看起來更像一般的編輯器（以下步驟默認了你已經學會 Vim 的基本操作，包括移動光標、輸入、模式切換等）。 首先，通過輸入 :e $HOME/.vimrc&lt;CR&gt; 打開配置文件（’$HOME/.vimrc’ 替換爲你平臺對應的配置文件路徑）。這時，如果此前你已經拷貝了 Vim 的示例配置文件，或者是從網上下載安裝了其他人的配置，那麼你打開的文件裏應該就有那些內容，如果此前還未做過配置，那麼打開的就是一個空文件。 接下來可以選擇下面的配置中你需要的部分拷貝進你的 ‘vimrc’ 123456789101112131415161718192021222324252627282930\" about vim setupset nocompatible \" disable compatible for viset shell=/bin/bash \" setup default shellset shortmess=at \" 啓動時隱去援助提示set mouse=a \" active mouse controlset clipboard+=unnamed \" support system clipboardlet mapleader=';' \" remap &lt;leader&gt;\" display setupset relativenumber \" display relative row numberset ruler \" 顯示標尺，就是在右下角顯示光標位置set spell spelllang=en_us,cjk \" Spell checking for English, escape Chineseset langmenu=zh_CN.UTF-8set helplang=cn \" 設置幫助文檔爲中文，需要 'yianwillis/vimcdoc'syntax enable \" syntax highlight enablesyntax on \" syntax highlight onset background=dark \" setup background colorcolorscheme gruvbox \" setup color schemeset wildmenu \" select the candidates in interactive wayset backspace=indent,eol,start \" more powerful backspacingset cursorcolumn \" 淺色高亮當前列set cursorline \" 淺色高亮當前行set novisualbell \" 關閉視覺響鈴set laststatus=2 \" 啓動顯示狀態行set showcmd \" show the command executed by shortcutsset noshowmode \" don't show the mode status, avoid override argvs hintset hlsearch \" highlight for searched resultsset incsearch \" highlight for searching resultsset showmatch \" show the match of brackets and Quotation markset ignorecase \" ignore case when searching and command completionset gdefault \" default substitute in the whole line 其中，最重要的一條設置就是 set nocompatible，它的作用是關閉對 Vi 的兼容性。Vi 是一款更加古老的編輯器，可視作是 Vim 的前身。如果保留對 Vi 的兼容性也就意味着你放棄了很多 Vim 獨有的特性。set shell=/bin/bash 顯式地聲明瞭 Vim 在運行腳本時調用的解釋器，如果是 Windows 用戶則需要去掉這行。 此時保存配置文件並通過 :so \\$HOME/.vimrc&lt;CR&gt; 重載配置後應該就能看到改變了。但此時你可能會注意到幾條錯誤信息，不要緊張，這是因爲我們在配置中引用了一些插件功能，但事實上我們現在還未安裝插件，安裝插件後你會看到錯誤就消失了。 安裝插件管理器 - 管理插件的插件Vim 有非常多的插件管理器可以使用，除去功能上的細微差異，我們可以將所有插件管理器分爲異步型和同步型。可以簡單地理解爲異步型可以同時下載安裝多個插件，而同步型一次只能處理一個。在 Vim 7.4 版本出來之前，插件管理器都是同步型的，包括大名鼎鼎的 Vundle。 在我剛開始使用 Vim 的時候，Vim 和 Neovim 都已經支持異步架構，但由於當時查的是中文資料，很多都是非常老的文章。基本上所有文章都推薦使用 Vundle 作爲插件管理器，事實上在你用過 vim-plug 之類的異步插件管理器後，你會無法再忍受 Vundle 的速度。這告訴我們技術型的文章還是要去 Google… 不會有人再去使用 Vim 7.4 之前的版本了，所以這裏我推薦使用 vim-plug 作爲插件管理器。vim-plug 的優點是異步下載安裝、插件更新方便、支持插件按需加載，並且只包含一個文件。它的 GitHub 倉庫上有詳細的安裝教程。 安裝插件 - 本體不夠再打 mod雖然 Vim 並不是擴展性最好的編輯器，但它仍支持成千上萬個插件。尋找插件最好的途徑是 GitHub 和 Vim Scripts。以下是我使用的插件列表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960let g:python3_host_prog = \"/usr/bin/python3\"call plug#begin('~/.vim/plugged')Plug 'tomasr/molokai' \" molokai color schemePlug 'morhetz/gruvbox' \" gruvbox colorscheme themePlug 'mhinz/vim-startify' \" an awesome startup screenPlug 'vim-scripts/fcitx.vim' \" auto switch fcitx statusPlug 'manu-mannattil/vim-sdcv' \" a simple dictionary for vimPlug 'vim-airline/vim-airline' \" add status linePlug 'scrooloose/nerdtree', &#123; 'on': 'NERDTreeToggle' &#125; \" directory treePlug 'majutsushi/tagbar', &#123; 'on': 'TagbarToggle' &#125; \" Class structure viewer, need ctags installedPlug 'mbbill/undotree', &#123; 'on': 'UndotreeToggle' &#125; \" undo tree managerPlug 'tpope/vim-fugitive' \" git supportPlug 'junegunn/gv.vim' \" view git commits in VimPlug 'junegunn/fzf', &#123; 'dir': '~/.fzf', 'do': './install --all' &#125; \" fuzzy file searcherPlug 'junegunn/fzf.vim' \" provide many other search functionsPlug 'tpope/vim-commentary' \" a better comment toolPlug 'vim-scripts/EasyMotion' \" enhance default motionsPlug 'Yggdroot/indentLine' \" indent line indicatorPlug 'jiangmiao/auto-pairs' \" auto add pairsPlug 'junegunn/rainbow_parentheses.vim' \" a much simpler-using fork of abovePlug 'junegunn/limelight.vim' \" dim othersPlug 'junegunn/goyo.vim' \" provide a dim writing environmentPlug 'w0rp/ale' \" syntax error checkPlug 'Valloric/YouCompleteMe', \" auto complete \\&#123; 'do': './install.py --clang-completer' &#125;Plug 'SirVer/ultisnips' \" auto complete stringPlug 'honza/vim-snippets' \" complete rules for ultisnipsPlug 'junegunn/vim-easy-align' \" align toolPlug 'godlygeek/tabular' \" advanced align toolPlug 'gabrielelana/vim-markdown', &#123; 'for': 'markdown' &#125; \" markdown pluginPlug 'joker1007/vim-markdown-quote-syntax', &#123; 'for': 'markdown' &#125; \" syntax highlight for quoted codePlug 'iamcco/mathjax-support-for-mkdp', &#123; 'for': 'markdown' &#125; \" mathjax support for markdown previewPlug 'iamcco/markdown-preview.vim', &#123; 'for': 'markdown' &#125; \" markdown preview supportPlug 'vim-scripts/indentpython.vim', &#123; 'for': 'python' &#125; \" auto indent for pythonPlug 'nvie/vim-flake8', &#123; 'for': 'python' &#125; \" flake8 style code check, need install flake8\" 這兩個插件被 neoformat 替代了\" Plug 'tell-k/vim-autopep8', &#123; 'for': 'python' &#125; \" a python code format tool wrapper for autopep8\" Plug 'fisadev/vim-isort', &#123; 'for': 'python' &#125; \" imports sorter for pythonPlug 'vim-latex/vim-latex', &#123; 'for': 'tex' &#125; \" latex edit environmentPlug 'skywind3000/asyncrun.vim' \" AsyncRun pluginPlug 'hotoo/pangu.vim' \" Chinese text formatPlug 'vimwiki/vimwiki' \" write wiki in vimPlug 'yianwillis/vimcdoc' \" a Chinese help handbook for VimPlug 'sbdchd/neoformat' \" a collection of format toolsPlug 'ludovicchabant/vim-gutentags' \" generate tags for projectPlug 'mhinz/vim-signify' \" show file modifying status for gitPlug 'Shougo/echodoc.vim' \" show argvs hint on the command line\"======================\"\" text object 全家桶 \"\"======================\"Plug 'kana/vim-textobj-user' \" 用戶自定義 text objectPlug 'kana/vim-textobj-indent' \" 縮進對象，關鍵字 &lt;i&gt;Plug 'kana/vim-textobj-syntax' \" 語法對象Plug 'kana/vim-textobj-function', &#123; 'for':['c', 'cpp', 'vim', 'java'] &#125; \" 函數對象，關鍵字 &lt;f&gt;Plug 'sgur/vim-textobj-parameter' \" 參數對象，關鍵字 &lt;,&gt;Plug 'coderifous/textobj-word-column.vim' \" 列對象，關鍵字 &lt;c&gt;Plug 'bps/vim-textobj-python' \" python 對象合集，&lt;c&gt; 類，&lt;f&gt; 函數Plug 'tpope/vim-surround' \" deal with surround for text objectcall plug#end()filetype plugin indent on 由於 vim-plug 的強大，我們只需要將上述配置粘貼進 vimrc 中，重載配置文件後運行 :PlugInstall&lt;CR&gt; 就會自動安裝所有插件，甚至 vim-plug 會幫我們做好安裝後的處理。 必裝插件配置 - 大大提高生產力通過 vim-plug 安裝的插件大部分都是即裝即用的，但也包括小部分需要在安裝完成後進行一定的配置才能舒適地使用。 YouCompleteMe - 最強補全神器YouCompleteMe 是谷歌程序員 Valloric 開發的一款智能補全插件。在 YouCompleteMe 出來之前，大部分補全插件都是基於 tag 分析，也就是從當前文件以及其他 buffer 中的文件文本中匹配類似字符串進行補全，說白了就是靠猜。而 YouCompleteMe 是真正支持程序語義分析的補全，能夠理解程序語言進行補全，準確率大大提高，並且體驗也提升了很多。 盜用 YouCompleteMe 官方倉庫上的一張效果圖 雖然 YouCompleteMe 效果看起來很炫酷，但它也被稱爲“最難安裝的插件”。它的底層是用 C++ 寫成的，爲了能作爲 Vim 的插件，外層又用 Python 做了封裝，因此它也是最複雜的插件。Plug &#39;Valloric/YouCompleteMe&#39;, { &#39;do&#39;: &#39;./install.py --clang-completer&#39; } 命令要求 vim-plug 將 YouCompleteMe 插件下載下來後自動編譯，但如果你的終端上缺少編譯的依賴會導致編譯失敗，此時我們需要手動進行編譯。 在 Linux 下進行安裝會相對比較容易，在編譯之前你需要但不限於以下工具： cmake automake python3-dev（python2 或 python3） 之後運行 cd ~/.vim/plugged/YouCompleteMe/ 進入 YouCompleteMe 的安裝目錄，運行 ./install.py --clang-completer 進行安裝，如果不需要 C 語言補全支持的話無需 --clang-completer 選項。安裝程序會自動下載 libclang 依賴，等待安裝完成即可。Windows 的安裝過程大部分相似，可參考 YouCompleteMe 的官方倉庫文檔。 再次使用 Vim 打開一個 Python 或 cpp 文件應該就能自動補全了。但接下來你會發現 YouCompleteMe 彈出的補全菜單裏只會包括前面你輸入過的關鍵字，並沒有進行語義識別，那不是和自帶的 omni 補全沒區別！還浪費我這麼長時間安裝！其實之前我也是這麼想的，直到有一天我看到這篇文章，我才發現原來我一直用的是半殘的 YouCompleteMe，根本沒發揮出它真正的實力。通過如下配置就能使 YouCompleteMe 的補全策略更貼近於常見的 IDE。 12345678910111213141516171819202122set completeopt=longest,menu \" YCM 的提示方式，previews 會顯示具體預覽窗口，menu 不提示\" let g:ycm_add_preview_to_completeopt = 0let g:ycm_collect_identifiers_from_tags_files=1 \" 使用 ctags 生成的 tags 文件let g:ycm_min_num_of_chars_for_completion=2 \" 從第 2 個鍵入字符就開始羅列匹配項let g:ycm_seed_identifiers_with_syntax=1 \" 語法關鍵字補全let g:ycm_cache_omnifunc=1 \" 禁止緩存匹配項,每次都重新生成匹配項let g:ycm_complete_in_comments = 1 \" 在註釋輸入中也能補全let g:ycm_complete_in_strings = 1 \" 在字符串輸入中也能補全let g:ycm_collect_identifiers_from_comments_and_strings = 1 \" 註釋和字符串中的文字也會被收入補全let g:ycm_python_binary_path = '/usr/bin/python' \" set default python binarylet g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py' \" set global ycm extra config pathlet g:ycm_confirm_extra_conf = 0 \" confirm for config filelet g:ycm_use_ultisnips_completer=1 \" 查詢 ultisnips 提供的代碼模板補全let g:ycm_key_invoke_completion = '&lt;c-z&gt;' \" 手動觸發補全的按鍵\" 使 YCM 能在輸入兩個字母的時候自動基於語義補全let g:ycm_semantic_triggers = &#123; \\ 'c,cpp,python,java,go,erlang,perl': ['re!\\w&#123;2&#125;'], \\ 'cs,lua,javascript': ['re!\\w&#123;2&#125;'], \\ &#125;nnoremap &lt;leader&gt;d :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt; \" goto definitionautocmd InsertLeave * if pumvisible() == 0|pclose|endif \" 離開插入模式後自動關閉預覽窗口autocmd VimEnter * EchoDocEnable ALE - 第二好的異步語法檢查工具ALE 是一款非常強大的異步語法檢查工具。在 Vim 支持異步之前，最好的語法檢查工具是 Syntastic，但由於它非異步的工作方式，導致語法檢查會阻塞主線程，使用體驗比較差。在新版 Vim 中，都會推薦 ALE 或其他支持異步的語法檢查工具。事實上 ALE 並不僅僅是一款語法檢查工具，它是包括了語法檢查、代碼風格格式化、自動補全功能的工具集。 ALE 安裝完成後，隨意打開一個代碼文件。如果語法存在錯誤，那麼在窗口的最左側會顯示一列符號，包括 ‘&gt;&gt;’ 或 ‘—‘。將光標移至有標記的行，在最下方的 statusline 中會顯示錯誤的具體信息。 123456789101112131415161718192021\" let g:ale_set_loclist = 0 \" show the lint as a dot on left of a line\" let g:ale_set_quickfix = 1 \" show the lint in quickfix list\" let g:ale_open_list = 1 \" show quickfix window to show error message\" let g:ale_keep_list_window_open = 1 \" keep quickfix window show whether errors exist\" let g:ale_sign_column_always = 1 \" 保持左側邊欄始終可見nmap &lt;silent&gt; &lt;C-k&gt; &lt;Plug&gt;(ale_previous_wrap)nmap &lt;silent&gt; &lt;C-j&gt; &lt;Plug&gt;(ale_next_wrap)\" Check Python files with flake8 and pylint.\" let b:ale_linters = ['flake8', 'pylint']\" set fixers for different file typeslet b:ale_fixers = &#123; \\ 'python': ['isort', 'autopep8'], \\ 'cpp': ['clang-format'], \\ 'markdown': ['prettier']&#125;\" let g:ale_linters_explicit = 1let g:ale_completion_delay = 500 \" 補全的延遲let g:ale_echo_delay = 20 \" 回顯的延遲let g:ale_lint_delay = 500 \" 停止輸入後更新 lint 標記的延遲let g:ale_echo_msg_format = '[%linter%] &lt;%code&gt; %%s' \" 自定義 lint 輸出格式let g:ale_lint_on_text_changed = 'normal' \" 當文字在 NORMAL 模式下發生更改的時候更新 lint，防止 YCM 頻繁刷新let g:ale_lint_on_insert_leave = 1 \" 離開 INSERT 模式時更新 lint 將錯誤信息表示在左側只是一種方式，你也可以通過反註釋前 4 行，利用 Vim 自帶的 quickfix 窗口顯示錯誤信息。雖然通過這種方式你能夠更清晰的瞭解各個錯誤的具體信息，但需要佔用一部分寶貴的屏幕空間。 11 至 14 行設置了 ALE 的默認格式化工具，ALE 本身並不對代碼進行格式化，而是針對不同文件類型調用合適的格式化工具進行處理（ALE 支持的格式化工具列表可參照官方倉庫）。其中 isort、autopep8、prettier 都是 Python 編寫的命令行工具，clang-format 是 clang 編譯器帶的 C++ 格式化工具。 20、21 行是針對 YCM 做的額外配置，據悉可以解決 YCM 補全菜單頻繁刷新的問題。","categories":[],"tags":[{"name":"Vim, Linux","slug":"Vim-Linux","permalink":"http://cycoe.cc/tags/Vim-Linux/"}]},{"title":"convert format of documents with pandoc","slug":"convert-format-of-documents-with-pandoc","date":"2018-06-29T06:33:48.000Z","updated":"2019-02-28T01:03:03.682Z","comments":true,"path":"2018/06/29/convert-format-of-documents-with-pandoc/","link":"","permalink":"http://cycoe.cc/2018/06/29/convert-format-of-documents-with-pandoc/","excerpt":"","text":"Pandoc 是一個強大的文檔格式轉換軟件，可以對 html、markdown、ppt、doc、pdf 等多種格式進行相互轉換，但在將 markdown 文件轉換爲 pdf 文件的過程中，發現會出現中文編碼的問題，因此需要使用如下命令指定渲染的引擎 pandoc -f markdown_github my.md -o my.pdf --pdf-engine=xelatex -V mainfont=&quot;Your Font&quot;","categories":[],"tags":[]},{"title":"Spawn your blog site with hexo","slug":"Spawn-your-blog-site-with-hexo","date":"2018-04-14T05:50:18.000Z","updated":"2019-02-28T01:03:03.719Z","comments":true,"path":"2018/04/14/Spawn-your-blog-site-with-hexo/","link":"","permalink":"http://cycoe.cc/2018/04/14/Spawn-your-blog-site-with-hexo/","excerpt":"","text":"最近，由於 GitHub 在國內的訪問越來越不穩定，我決定將博客遷移至 Coding（一個國內的代碼託管平臺）。Coding 與 GitHub 類似的可以直接展示靜態的個人主頁，整個配置流程與 GitHub 類似。但是之前使用的是 Jekyll 博客生成器進行構建，Jekyll 的優點是可以直接將代碼 Push 上去，GitHub 可以直接根據 Jekyll 格式的目錄進行部署，無需本地的部署環境，但是由於 Ruby 的性能問題，整個部署過程需要至少幾分鐘，因此尋求其他的生成器解決辦法。後來瞭解到 Hexo，一個由 NodeJS 驅動的博客生成器，於是決定趁遷移嘗試一下。 環境安裝安裝 NodeJSHexo 既然是由 NodeJS 驅動的，那必然 NodeJS 環境是必不可少，另外爲了更方便地管理第三方庫，還需要安裝 npm 管理器。對於我使用的 ArchLinux 爲例，只需要運行以下命令即可完成安裝。 $ sudo pacman -S nodejs npm 安裝 hexo 先創建一個文件夾用於存放博客的資源文件，然後 cd 到該目錄下 安裝 hexo：sudo npm install hexo -g 安裝完成後通過 hexo -v 查看版本 通過 hexo init 將本目錄初始化爲博客的根目錄，可以看到目錄下自動生成了一些文件 各文件解釋如下： node_modules：依賴包 public：存放構建生成的頁面 scaffolds：命令生成文章等的模板 source：用命令創建的各種文章 themes：主題目錄 _config.yml：整個博客的配置 db.json：source 解析得到的信息 package.json：項目所需模塊的配置信息 開始寫博客可以選擇 typora 或者其他的 Markdown 編輯器進行編輯，此處我選擇了 vim 進行文件編輯。要想要 vim 支持 Markdown 的語法高亮需要以下幾個插件 Plugin ‘godlygeek/tabular’ Plugin ‘gabrielelana/vim-markdown’ 部署博客hexo 可以用 $ hexo d -g 命令方便的對博客系統進行部署，但首先需要在博客配置文件 _config.yml 的 Deployment 節中做配置1234deploy: type: git # 此處是部署的方式 repo: # 此處是所有需要部署的倉庫，倉庫的設置與 Jekyll 類似 coding: git@git.coding.net:cycoe/cycoe.git 然後在 Coding 上新建一個名爲 cycoe 的空倉庫（由於 Coding 本身的限制，該倉庫應與用戶名同名），在本機的博客根目錄運行 hexo d -g 即可將博客部署至 Coding。然後打開倉庫設置，將此倉庫設置爲 Coding Pages 即可。 2018-06-05 更新最近 Coding 不知是怎麼了，我的博客總是打不開。湊巧最近剛租了個包月的服務器，於是決定將整個博客遷移到自己的服務器上。 Hexo 和 Jekyll 博客系統的部署原理不太一樣，$ hexo g 是 $ hexo generate 的縮寫，其原理是在本地使用 Hexo 引擎將 _posts 目錄的 Markdown 文件生成網頁結構，結果保存在 public 目錄下，可直接由 Apache 或 Nginx 驅動。 而 $ hexo deploy 正是將 public 目錄下的網頁部署到 Git 倉庫中。因此如果能將倉庫克隆到服務器上進行部署，那麼問題就能解決。 在服務器上建立 Git 倉庫初始化 Git 倉庫$ sudo git init --bare sample.git Git 就會創建一個裸倉庫，即會在當前路徑下創建一個名爲 sample.git 的倉庫。裸倉庫沒有工作區，因爲服務器上的 Git 倉庫純粹是爲了共享，所以不讓用戶直接登錄到服務器上去改工作區，並且服務器上的 Git 倉庫通常都以 .git 結尾。然後，把 owner 改爲服務器的用戶名，不然沒有權限將修改寫入該倉庫。 $ sudo chown -R ubuntu:ubuntu sample.git 將倉庫加到 Hexo 的配置文件12345deploy: type: git repo: #coding: git@git.coding.net:cycoe/cycoe.git my_server: ubuntu@139.199.95.151:/home/ubuntu/git/blog.git 此處 @ 前的用戶名一定要與服務器倉庫的權限對應，: 後面是倉庫的絕對路徑。 部署此時運行 $ hexo d- g 即可將博客網頁目錄部署到倉庫，但此時查看倉庫會發現目錄下並不是網頁的結構，因爲這個倉庫是裸倉庫，下面並沒有工作區，所以看到的並不是我們 Push 上來的內容。 Git Hook 事件事實上，如果我們此時將該倉庫克隆到另一個目錄下就可以看到工作區了。首先 cd 到需要保存網頁的路徑下 $ cd /home/ubuntu/www/，然後運行 $ git clone /home/ubuntu/git/blog.git 將倉庫克隆至當前路徑。 但是如果每次都要登上服務器手動克隆就違揹我們自動化部署的初衷了。因此此處需要用到 Git 自帶的 Hook 功能，簡單來將講就是在倉庫發生變化前/後所要執行的操作。 Hook 的事件放在裸倉庫目錄的 hooks 文件夾下，這裏我們新建一個名爲 post-receive 的事件，該事件是在倉庫更新合併完成後自動運行，文件中加入如下內容 12345#!/bin/bashcd /home/ubuntu/www/blog # cd 到網頁的展示倉庫unset GIT_DIR # 非常重要！如果不解綁 GIT_DIR 環境變量無法切換路徑git config --listgit pull origin master 運行 $ chmod +x post-receive 賦予執行權限 此時再在本機運行 $ hexo d -g 發現網頁目錄也自動更新了 2018-08-18 更新今天寫了一篇博客，運行 $ hexo d -g 想要更新博客，結果發現網頁並沒有變化。登上服務器一看 /home/ubuntu/git/blog.git 倉庫已經更新了，懷疑是更新後沒有成功運行 post-receive。但是自從上次設置好 post-receive 後就沒有改過，按理說應該能夠運行。運行 $ ls -l 命令後發現，/home/ubuntu/git/blog.git 目錄的歸屬者是 ubuntu，而 /home/ubuntu/www/blog 目錄的歸屬者是 nginx，應該是上次我在設置 nginx 的時候不小心把 /home/ubuntu/www 目錄遞歸修改成歸屬 nginx 了。而 post-receive 所做的工作實際上是在我把更新 push 到 /home/ubuntu/git/blog.git 倉庫後，cd 到了 /home/ubuntu/www/blog 目錄並拉取更新。因此我是以 ubuntu 用戶的身份做的 push，又是以 ubuntu 用戶的身份運行的 post-receive，因此在 /home/ubuntu/www/blog 目錄中是沒有權限拉取更新的。 既然已經發現了問題出在用戶權限上。那就可以通過運行 $ sudo chown -R ubuntu:users /home/ubuntu/www 將整個目錄都改爲 ubuntu 所屬，也就不關 nginx 用戶什麼事了，這樣確實非常方便的解決了這個問題。另外 post-receive 在更改用戶歸屬後執行權限丟失了，記得運行 $ chmod +x post-receive 重新賦予執行權限。事實上當初建立 nginx 用戶也是因爲安裝了 nginx 服務，想要弄得更規範些。但因爲懶一直沒給 nginx 建立自己的 Home 目錄，按理說把跟 nginx 相關的目錄都扔到 nginx 用戶對應的 Home 下是最好的。 2018-10-24 更新最近寫的新博客中需要開啓 LaTeX 公式支持，但 hexo 本身對數學公式的支持有些問題，Hexo 默認使用 “hexo-renderer-marked” 引擎渲染網頁，該引擎會把一些特殊的 markdown 符號轉換爲相應的 html 標籤，比如在 markdown 語法中，下劃線 ‘_’ 代表斜體，會被渲染引擎處理爲 標籤。 解決方法更換 Hexo 的 markdown 渲染引擎，使用 ‘hexo-renderer-kramed’ 引擎替代 ‘hexo-renderer-marked’ 引擎，前者在後者的基礎上修復了一些 bug。執行以下命令卸載原引擎並安裝新引擎。12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 此時行間公式應該就可以正常渲染了，但行內公式還是有問題。接下來在博客根目錄中，找到 node_modules\\kramed\\lib\\rules\\inline.js，修改 11 行的 escape 變量的值。12// escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/,escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, 這一步是在原基礎上取消了對 ‘\\, {, }’ 的轉義(escape)。同時把第 20 行的 em 變量也要做相應的修改。12// em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 然後運行 hexo clean 清除構建，再 generate 即可解決問題。 在主題中開啓 mathjax 開關打開 themes/next/_config.yml，將 math 的 enable 設爲 true，將 per_page 設爲 true，表示針對每頁單獨決定是否開啓 mathjax 支持。1234567math: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has 'mathjax: true' in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: true 因爲 per_page 設爲 true，因此需要在文章的 Front-matter 裏打開 mathjax 開關。1234567---title: Spawn your blog site with hexodate: 2018-04-14 13:50:18categories: linuxtag: hexomathjax: true---","categories":[{"name":"linux","slug":"linux","permalink":"http://cycoe.cc/categories/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://cycoe.cc/tags/hexo/"}]},{"title":"Planche training calendar","slug":"Planche-training-calendar","date":"2018-04-12T16:00:00.000Z","updated":"2019-02-28T01:03:03.636Z","comments":true,"path":"2018/04/13/Planche-training-calendar/","link":"","permalink":"http://cycoe.cc/2018/04/13/Planche-training-calendar/","excerpt":"","text":"A planche is a skill in gymnastics in which the body is held parallel to the ground, giving the illusion of floating. It is a move that requires significant strength and balance. 剛進大學的時候 ，無意間在 B 站看到一個關於俄挺的視頻，能夠完成俄挺成了我的一個夢想。本科的時候陸陸續續地練過一段時間，練練俯臥撐和團身，團身也就是剛剛高團 2-3 秒的程度。後來因爲實在沒什麼進展也就漸漸放棄了。前幾天回家的路上吹了點小風就感冒了，意識到自己的小身板太弱，再加上最近想要增重，決定重新開始練習俄挺。 2018-04-05從今天開始練習，因爲也好久沒有做俯臥撐了，目前的水平實在太爛。 標準俯臥撐 10 個 衝肩維持 5 秒 2018-04-13練了一個星期的衝肩，每天都在堅持。 衝肩維持 10 秒 窄距俯臥撐 10 個 2018-06-10最近右手小臂疼的厲害，應該是跟前幾天每天用鼠標做視頻有關，看來要好好休息幾天了，最近下調訓練強度，少用鼠標。。不過值得激動的是，目前已經可以比較輕鬆地做團身了，高階團身應該也能 10 來秒了，接下來準備練團身舉腿。 衝肩維持 30 秒 窄距俯臥撐 25 個 衝肩俯臥撐 15 個 團身維持 10 秒 引體向上 7 個 2018-07-25最近一個月因爲手腕一直還是有點疼，尤其搬重物的時候，也就沒怎麼敢繼續練團身，轉而練習引體和前水平。打算先通過前水平鍛鍊背部力量，通過雙力臂鍛鍊手腕力量，等基礎打好後再練習俄挺。引體的話其實應該一組能做個 10 個左右，但是後面幾組做的時候因爲可能是翻腕了的原因，導致手腕還是會疼，發現在雲梯上練習就沒事了，可能是手的朝向的問題。 雙力臂其實還是沒有太大進展，前水平的話一條腿伸直是能保持了，接下來就是要延長持續的時間，然後慢慢向雙腿進步。在宿舍也可以每天都練前水平。 另外利用操場上的槓鈴可以做很多其他的訓練，比如正手擡、反手拉、單手拉、臥推。利用器材可以取得更好的訓練效果。 最後有個非常重要的想法：在家的這幾天發現，想要找個健身器材齊全的公園實在不是很容易，因此希望能做個 App，街健愛好者可以在上面共享健身器材所在的位置，另外可以認識附近的街健愛好者。 衝肩俯臥撐 20 個 前水平團身 10 秒 單槓硬拉 4 個 引體 10 個","categories":[{"name":"personal","slug":"personal","permalink":"http://cycoe.cc/categories/personal/"}],"tags":[{"name":"planche","slug":"planche","permalink":"http://cycoe.cc/tags/planche/"}]},{"title":"教務網現驚天大 bug？！談談弱密碼如何暴露你的信息","slug":"教务网现惊天大bug","date":"2017-12-06T16:00:00.000Z","updated":"2019-02-28T01:03:03.362Z","comments":true,"path":"2017/12/07/教务网现惊天大bug/","link":"","permalink":"http://cycoe.cc/2017/12/07/教务网现惊天大bug/","excerpt":"","text":"漏洞發現最近在爲之前寫的爬蟲做批註的時候發現了一段有趣的代碼，代碼如下123456789101112131415161718192021222324252627MisUtils.initAttempt()while MisUtils.descAttempt(): self.response = self.session.send(prepareBody) if self.response.status_code == 200: breakif not MisUtils.descAttempt(): Logger.log('Up to max attempts!', ['Maybe remote server unreachable'], level=Logger.error) return Falseif re.search('用戶名不存在', self.response.text): print(Logger.log('No such a user!', ['Cleaning password file'], level=Logger.error)) reInput = Trueelif re.search('密碼錯誤', self.response.text): print(Logger.log('Wrong password!', ['Cleaning password file'], level=Logger.error)) reInput = Trueelif re.search('請輸入驗證碼', self.response.text): print(Logger.log('Please input vertify code!', ['Retrying...'], level=Logger.error))elif re.search('驗證碼錯誤', self.response.text): print(Logger.log('Wrong vertify code!', ['Retrying...'], level=Logger.error))else: print(Logger.log('Login successfully!', ['UserName: ' + MisUtils.confDict['userName']], level=Logger.error)) MisUtils.dumpConfFile() break 當時寫的時候沒注意，現在回過頭來看看，驚奇地發現教務網對於用戶名和密碼的驗證順序是如下的優先級： 首先驗證用戶名是否存在 再驗證密碼是否正確 然後驗證碼是否爲空 最後纔是驗證碼是否正確 這。。。我只想說，誰寫的驗證邏輯。。。我要這驗證碼有何用？！！！ 漏洞驗證接下來去教務網上驗證一下整個驗證邏輯是否如所想的那樣 首先在用戶名輸入框中隨意輸入一串數字，並保持密碼和驗證碼都爲空，嘗試登錄發現彈出“用戶名不存在”的 JS 腳本 再輸入我正確的學號，仍保持密碼和驗證碼都爲空，嘗試登錄彈出“密碼錯誤”的 JS 腳本 輸入正確的學號和密碼，並保持驗證碼爲空，嘗試登錄彈出“請輸入驗證碼”的 JS 腳本 輸入正確的學號和密碼，但是輸入錯誤的驗證碼，嘗試登錄彈出“驗證碼錯誤”的 JS 腳本 通過以上流程，可以總結得以下兩條有價值的信息： 當你輸入的用戶名不存在時，不管密碼和驗證碼輸的啥，總是會提示“用戶名不存在”；當你輸入的用戶名存在，並且密碼爲空時，會提示“密碼錯誤”。 當你輸入的用戶名存在，但是密碼錯誤時，不管驗證碼輸的啥，總會提示“密碼錯誤”；當輸入的密碼正確並且驗證碼爲空時，會提示“請輸入驗證碼”。 漏洞利用通過上面的兩條信息可以至少做到兩件事情 枚舉用戶名目前所有在讀研究生的入學時間大部分爲 2013-2017 年，學號的前四位爲入學年份，中間三位與所在的專業有關，最後三位爲流水號。對所有形如 2013XXXXXX 的學號進行嘗試登錄，根據信息 1，能夠枚舉出所有 13 年入學的學生學號。 暴破利用上一步得到的用戶名列表，再配合字典就可以進行在線的密碼暴破，這種破解方法一般來說是非常低效的，嚴重依賴於網絡狀況和服務器的機能。嘗試發現在單線程的情況下，每秒只能對服務器進行 1k 次左右的訪問。也就是說如果使用 16 位的數字加字母作爲密碼，最多需要 2.5 百萬億年的時間才能成功破解。看起來是非常安全吧。然而實際情況又是什麼樣呢？教務網的初始密碼爲身份證號中的生日，一般來說我們在第一次登錄時都會改密碼，但還總會有人抱着僥倖的心理用初始密碼，這就爲暴破帶來了捷徑。以生日作爲密碼具有非常明顯的結構，如 2017 年入學學生的生日大多在 1994-1996 之間，利用下面簡單的字典生成器可得到 1994-1996 年所有的日期列表：12345678910111213141516171819202122232425262728293031big_month_ = [1, 3, 5, 7, 8, 10, 12]small_month_ = [4, 6, 9, 11]def gen_(begin, end): password_ = [] for year in range(begin, end + 1): for month in range(1, 13): if month in big_month_: month_len = 31 elif month in small_month_: month_len = 30 elif month == 2: if year % 4 != 0 or (year % 100 == 0 and year % 400 != 0): month_len = 28 else: month_len = 29 else: month_len = 31 for day in range(1, month_len + 1): password_.append(str(year) + str(month).zfill(2) + str(day).zfill(2)) with open('password.dict', 'w') as fr: for password in password_: fr.write(password) fr.write('\\n')def main(): gen_(1994, 1996) 利用得到的用戶名列表和密碼字典就可以對所有未修改的用戶密碼進行暴破。 總結最後結果怎麼樣？使用 100 個線程，並設置單個線程的訪問頻率爲 1 次/秒進行暴破，10 分鐘破解出了接近 40 個用戶密碼！並且平均每四個人裏就有一個人沒有修改密碼！可能很多人會覺得教務網密碼不涉及錢財也就不那麼在意。但其實教務網上有詳細的個人資料，包括你的姓名、照片和家庭住址。另外還有你的課表，你某時某刻會在哪個教室出現都會被人知道啊！所以，弱密碼的危害顯而易見，很多的信息泄漏也都是由弱密碼引起的。給自己換個複雜點的密碼吧，畢竟密碼這種東西一寸長一寸強。現在也快到年底了，騙子也要賺錢備年貨了，希望大家能夠保護好自己的信息，不要給騙子可乘之機。最後討伐一下這個軟件提供商，一個商業化的系統裏面竟然有如此明顯的邏輯漏洞，只希望快點被修復吧。","categories":[{"name":"python","slug":"python","permalink":"http://cycoe.cc/categories/python/"},{"name":"spider","slug":"python/spider","permalink":"http://cycoe.cc/categories/python/spider/"},{"name":"sploit","slug":"python/spider/sploit","permalink":"http://cycoe.cc/categories/python/spider/sploit/"}],"tags":[]},{"title":"如何提高搶到報告的概率？","slug":"如何提高抢到报告的概率","date":"2017-11-02T16:00:00.000Z","updated":"2019-02-28T01:03:03.299Z","comments":true,"path":"2017/11/03/如何提高抢到报告的概率/","link":"","permalink":"http://cycoe.cc/2017/11/03/如何提高抢到报告的概率/","excerpt":"","text":"#right-panel { background-color: #fff; } #right-panel .cover-top { background: linear-gradient(to bottom, #fff 50%, transparent); } #cover-bottom #cover-bottom-background-right { background: #fff; } @font-face { font-family: octicons-link; src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff'); } #container { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; color: #373737; font-family: \"Roboto\", \"Noto Sans\", \"Ubuntu\", \"Helvetica Neue\", Helvetica, \"Segoe UI\", Arial, sans-serif, \"Noto Sans CJK SC\", \"Source Han Sans SC\", \"Microsoft Yahei\"; font-size: 14px; line-height: 2; word-wrap: break-word; background-color: #fff; } #container a { background-color: transparent; -webkit-text-decoration-skip: objects; } #container a:active, #container a:hover { outline-width: 0; } #container strong { font-weight: inherit; } #container strong { font-weight: bolder; } #container h1 { font-size: 2em; margin: 0.67em 0; } #container img { border-style: none; } #container svg:not(:root) { overflow: hidden; } #container code, #container kbd, #container pre { font-family: \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; font-size: 1em; } #container hr { box-sizing: content-box; height: 0; overflow: visible; } #container input { font: inherit; margin: 0; } #container input { overflow: visible; } #container button:-moz-focusring, #container [type=\"button\"]:-moz-focusring, #container [type=\"reset\"]:-moz-focusring, #container [type=\"submit\"]:-moz-focusring { outline: 1px dotted ButtonText; } #container [type=\"checkbox\"] { box-sizing: border-box; padding: 0; } #container table { border-spacing: 0; border-collapse: collapse; } #container td, #container th { padding: 0; } #container * { box-sizing: border-box; } #container input { font: 13px/1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; } #container a { color: #4078c0; text-decoration: none; } #container a:hover, #container a:active { text-decoration: underline; } #container hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #ddd; } #container hr::before { display: table; content: \"\"; } #container hr::after { display: table; clear: both; content: \"\"; } #container h1, #container h2, #container h3, #container h4, #container h5, #container h6 { margin-top: 0; margin-bottom: 0; line-height: 1.5; } #container h1 { font-size: 30px; } #container h2 { font-size: 21px; } #container h3 { font-size: 16px; } #container h4 { font-size: 14px; } #container h5 { font-size: 12px; } #container h6 { font-size: 11px; } #container p { margin-top: 0; margin-bottom: 10px; } #container blockquote { margin: 0; } #container ul, #container ol { padding-left: 0; margin-top: 0; margin-bottom: 0; } #container ol ol, #container ul ol { list-style-type: lower-roman; } #container ul ul ol, #container ul ol ol, #container ol ul ol, #container ol ol ol { list-style-type: lower-alpha; } #container dd { margin-left: 0; } #container code { font-family: \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; font-size: 12px; } #container pre { margin-top: 0; margin-bottom: 0; font: 12px \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; } #container .pl-0 { padding-left: 0 !important; } #container .pl-1 { padding-left: 3px !important; } #container .pl-2 { padding-left: 6px !important; } #container .pl-3 { padding-left: 12px !important; } #container .pl-4 { padding-left: 24px !important; } #container .pl-5 { padding-left: 36px !important; } #container .pl-6 { padding-left: 48px !important; } #container .form-select::-ms-expand { opacity: 0; } #container:before { display: table; content: \"\"; } #container:after { display: table; clear: both; content: \"\"; } #container>*:first-child { margin-top: 0 !important; } #container>*:last-child { margin-bottom: 0 !important; } #container a:not([href]) { color: inherit; text-decoration: none; } #container .anchor { display: inline-block; padding-right: 2px; margin-left: -18px; } #container .anchor:focus { outline: none; } #container h1, #container h2, #container h3, #container h4, #container h5, #container h6 { margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; } #container h1 .octicon-link, #container h2 .octicon-link, #container h3 .octicon-link, #container h4 .octicon-link, #container h5 .octicon-link, #container h6 .octicon-link { color: #000; vertical-align: middle; visibility: hidden; } #container h1:hover .anchor, #container h2:hover .anchor, #container h3:hover .anchor, #container h4:hover .anchor, #container h5:hover .anchor, #container h6:hover .anchor { text-decoration: none; } #container h1:hover .anchor .octicon-link, #container h2:hover .anchor .octicon-link, #container h3:hover .anchor .octicon-link, #container h4:hover .anchor .octicon-link, #container h5:hover .anchor .octicon-link, #container h6:hover .anchor .octicon-link { visibility: visible; } #container h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } #container h1 .anchor { line-height: 1; } #container h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } #container h2 .anchor { line-height: 1; } #container h3 { font-size: 1.5em; line-height: 1.43; } #container h3 .anchor { line-height: 1.2; } #container h4 { font-size: 1.25em; } #container h4 .anchor { line-height: 1.2; } #container h5 { font-size: 1em; } #container h5 .anchor { line-height: 1.1; } #container h6 { font-size: 1em; color: #777; } #container h6 .anchor { line-height: 1.1; } #container p, #container blockquote, #container ul, #container ol, #container dl, #container table, #container pre { margin-top: 0; margin-bottom: 16px; } #container hr { height: 4px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; } #container ul, #container ol { padding-left: 2em; } #container ul ul, #container ul ol, #container ol ol, #container ol ul { margin-top: 0; margin-bottom: 0; } #container li>p { margin-top: 16px; } #container dl { padding: 0; } #container dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold; } #container dl dd { padding: 0 16px; margin-bottom: 16px; } #container blockquote { padding: 0 15px; color: #777; border-left: 4px solid #ddd; } #container blockquote>:first-child { margin-top: 0; } #container blockquote>:last-child { margin-bottom: 0; } #container table { display: block; width: 100%; overflow: auto; word-break: normal; word-break: keep-all; } #container table th { font-weight: bold; } #container table th, #container table td { padding: 6px 13px; border: 1px solid #ddd; } #container table tr { background-color: #fff; border-top: 1px solid #ccc; } #container table tr:nth-child(2n) { background-color: #f8f8f8; } #container img { max-width: 100%; box-sizing: content-box; background-color: #fff; } #container code { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(0,0,0,0.04); border-radius: 3px; } #container code:before, #container code:after { letter-spacing: -0.2em; content: \"\\00a0\"; } #container pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } #container .highlight { margin-bottom: 16px; } #container .highlight pre, #container pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border-radius: 3px; } #container .highlight pre { margin-bottom: 0; word-break: normal; } #container pre { word-wrap: normal; } #container pre code { display: inline; max-width: initial; padding: 0; margin: 0; overflow: initial; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } #container pre code:before, #container pre code:after { content: normal; } #container kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: #555; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #ccc; border-bottom-color: #bbb; border-radius: 3px; box-shadow: inset 0 -1px 0 #bbb; } #container .pl-c { color: #969896; } #container .pl-c1, #container .pl-s .pl-v { color: #0086b3; } #container .pl-e, #container .pl-en { color: #795da3; } #container .pl-s .pl-s1, #container .pl-smi { color: #333; } #container .pl-ent { color: #63a35c; } #container .pl-k { color: #a71d5d; } #container .pl-pds, #container .pl-s, #container .pl-s .pl-pse .pl-s1, #container .pl-sr, #container .pl-sr .pl-cce, #container .pl-sr .pl-sra, #container .pl-sr .pl-sre { color: #183691; } #container .pl-v { color: #ed6a43; } #container .pl-id { color: #b52a1d; } #container .pl-ii { background-color: #b52a1d; color: #f8f8f8; } #container .pl-sr .pl-cce { color: #63a35c; font-weight: bold; } #container .pl-ml { color: #693a17; } #container .pl-mh, #container .pl-mh .pl-en, #container .pl-ms { color: #1d3e81; font-weight: bold; } #container .pl-mq { color: #008080; } #container .pl-mi { color: #333; font-style: italic; } #container .pl-mb { color: #333; font-weight: bold; } #container .pl-md { background-color: #ffecec; color: #bd2c00; } #container .pl-mi1 { background-color: #eaffea; color: #55a532; } #container .pl-mdr { color: #795da3; font-weight: bold; } #container .pl-mo { color: #1d3e81; } #container kbd { display: inline-block; padding: 3px 5px; font: 11px \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; line-height: 10px; color: #555; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #ccc; border-bottom-color: #bbb; border-radius: 3px; box-shadow: inset 0 -1px 0 #bbb; } #container .full-commit .btn-outline:not(:disabled):hover { color: #4078c0; border: 1px solid #4078c0; } #container :checked+.radio-label { position: relative; z-index: 1; border-color: #4078c0; } #container .octicon { display: inline-block; vertical-align: text-top; fill: currentColor; } #container .task-list-item { list-style-type: none; } #container .task-list-item+.task-list-item { margin-top: 3px; } #container .task-list-item input { margin: 0 0.2em 0.25em -1.6em; vertical-align: middle; } #container hr { border-bottom-color: #eee; } 在之前寫搶報告軟件的過程中，遇到一個非常有趣的問題——如何提高搶到報告的概率？當然，無腦減小兩次請求之間的間隔時間可以保證一定能搶到報告，但是也會加大服務器的負擔，作爲北京化工大學的優秀學子:smirk:，這麼做是不可行的。腦中突然靈光一現，以固定 5 秒的時間間隔搶報告與以 0 到 10 之間的隨機時間間隔搶報告，搶到報告的概率是一樣的嗎？剛好最近要考數理統計，那就用概率論的知識來解決這個問題吧（其實是不務正業:grin:）。 問題分析 從直觀上來看，固定 5 秒的時間間隔與 0 到 10 之前的隨機時間間隔的期望是相等的，實際情況計算後才知道。 間隔時間固定的情況 爲了簡化問題，首先將搶到報告的事件記爲 ，將報告的存活時間（報告從可搶狀態開始到被搶走的時間）的期望值記爲 E ，提交搶報告請求的時間間隔爲 ，則搶到報告的概率即爲 。針對 的情況， 。即在報告平均存活時間爲 3 秒，搶報告間隔固定爲 5 秒的情況下，搶到報告的概率爲 。 間隔時間爲均勻分佈的情況 在該種情況下，我們構造搶報告的時間間隔的分佈爲 ，其概率密度函數爲： 則對於任意的時間間隔 ，根據上一節中的結果，搶到報告的概率 的可表示爲分段函數： 得到搶到報告的期望爲 針對搶報告時間滿足 分佈，報告平均存活時間爲 3 秒的情況，將 代入上式，得到 。也就是說不改變 期望的情況下，通過改變 的分佈竟然提高了搶到報告的概率！！！我要趕快把這個修改合併到搶報告程序中！！！ 總結 爲什麼兩種方法搶到報告的概率不同呢？個人分析是由於在 滿足均勻分佈時，其中較小的 帶來了較大的成功概率，而較大的 對整體概率的影響不大。正如有句話說的好，搶報告搶的早不如搶的巧。搶報告是玄學，需要天時地利人和。至於計算過程是否正確，就要看最後我的數理統計成績了:joy:","categories":[{"name":"python","slug":"python","permalink":"http://cycoe.cc/categories/python/"},{"name":"spider","slug":"python/spider","permalink":"http://cycoe.cc/categories/python/spider/"}],"tags":[]},{"title":"利用 python 實現自動搶報告","slug":"利用python实现自动抢报告","date":"2017-10-27T16:00:00.000Z","updated":"2019-02-28T01:03:03.242Z","comments":true,"path":"2017/10/28/利用python实现自动抢报告/","link":"","permalink":"http://cycoe.cc/2017/10/28/利用python实现自动抢报告/","excerpt":"","text":"上了研究生才知道北化的研究生每年需要聽 15 個報告，而且最重要的是這些報告都是算分數的，而且更重要的是你的分數是和最後的獎學金評定掛鉤的。這也就決定了大家爲了那麼點報告分數擠教務網都擠破了頭（北化的服務器大家都懂），雖然場面不如開學搶課那麼火爆，卻需要長時間掛着教務網瘋狂刷新，爲了交換個講座也需要大半夜起來，生怕被別人截胡。爲了解放生產力，同時熟悉爬蟲技術、神經網絡技術、裝飾器等進階內容，寫了這個爬蟲來練練手。 聲明該爬蟲是本人(cycoe)練習 python 編程技巧和神經網絡所編寫，使用造成的任何責任與本人無關 項目地址 問題分解想要順利的拿到搶講座的 session，需要如下的步驟： 處理登陸問題，包括處理驗證碼、頁面表單和 cookies 獲取報告列表 獲取搶報告的地址 提交表單數據 框架設計好的框架應具有良好的可維護性和擴展性，目前正朝着這個方向努力 採用交互式的命令行設計，分離 login, robSpeech 等方法 將 login, robSpeech, robClass 等方法封裝成 Robber 對象 將底層的 requests 封裝成 Spider 對象 逐步解決 通過 firefox 或 chrome 的 debug 模式可以查看在訪問網頁時的 request 和 response。仿照瀏覽器在訪問教務網時提交的 headers 構造如下字典 1234567891011121314151617181920212223242526class Spider(object): @staticmethod def formatHeaders(referer=None, contentLength=None, originHost=None): \"\"\" 封裝請求的 headers :param referer: 跳轉標記，告訴 web 服務器自己是從哪個頁面跳轉過來的 :param contentLength: 作用未知 :param originHost: 原始主機地址 :returns: headers 字典 \"\"\" headers = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7', 'Cache-Control': 'max-age=0', 'Connection': 'keep-alive', 'Content-Type': 'application/x-www-form-urlencoded', 'DNT': '1', 'Host': 'graduate.buct.edu.cn:8080', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (X11;Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36', 'Referer': referer, 'Content-Length': contentLength, 'Origin': originHost, &#125; 封裝 request 請求需要的 prepareBody 對象，response = session.send(prepareBody)，response 就是我們拿到的服務器的響應對象，可通過 response.text 得到網頁內容，response.status_code 得到狀態碼，response.url 得到響應的地址。 1234567891011121314151617181920212223242526272829def prepare(self, referer=None, originHost=None, method='GET', url=None, data=None, params=None): \"\"\" 生成用於請求的 prepare :param referer: 跳轉標記，告訴 web 服務器自己是從哪個頁面跳轉過來的 :param originHost: 原始主機地址 :param method: 請求方法 in ['GET', 'POST'] :param url: 請求的 url 地址 :param data: 封裝的 post 數據 :param params: post 參數 :return: prepare 對象 \"\"\" headers = self.formatHeaders(referer=referer, originHost=originHost) req = Request(method, url, headers=headers, data=data, params=params) return self.session.prepare_request(req)prepareBody = prepare(referer=None, originHost=None, method='GET', url=UrlBean.jwglLoginUrl, data=None, params=None)response = session.send(prepareBody) 請求登錄網址，提交表單數據。根據 response 返回的響應體內容判斷是否登陸成功 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128def getVIEWSTATE(self): \"\"\" 正則獲取頁面的 __VIEWSTATE :returns: 頁面的 __VIEWSTATE \"\"\" VIEWSTATE = re.findall('&lt;.*name=\"__VIEWSTATE\".*value=\"(.*)?\".*/&gt;', self.response.text) if len(VIEWSTATE) &gt; 0: return VIEWSTATE else: return Nonedef getEVENTVALIDATION(self): \"\"\" 正則獲取頁面的 __EVENTVALIDATION :returns: 頁面的 __EVENTVALIDATION \"\"\" EVENTVALIDATION = re.findall('&lt;.*name=\"__EVENTVALIDATION\".*value=\"(.*)?\".*/&gt;', self.response.text) if len(EVENTVALIDATION) &gt; 0: return EVENTVALIDATION else: return Nonedef login(self): \"\"\" 登錄教務網 \"\"\" # 在登錄前請求一次登錄頁面，獲取網頁的隱藏表單數據 prepareBody = self.prepare(referer=None, originHost=None, method='GET', url=UrlBean.jwglLoginUrl, data=None, params=None) # 登陸主循環 while True: self.response = self.session.send(prepareBody) self.VIEWSTATE = self.getVIEWSTATE() self.EVENTVALIDATION = self.getEVENTVALIDATION() if self.VIEWSTATE is not None and self.EVENTVALIDATION is not None: break Logger.log(\"Retrying fetching login page viewState...\", level=Logger.warning) reInput = True # 是否需要重新輸入用戶名和密碼 while True: # 輸入用戶名和密碼 if reInput: if Config.checkUserFile(): Config.readUserInfo() else: Config.userName = input(\"&gt; UserName: \") Config.password = input(\"&gt; Password: \") reInput = False prepareBody = self.prepare(referer=UrlBean.jwglLoginUrl, originHost=None, method='GET', url=UrlBean.verifyCodeUrl, data=None, params=None) while True: codeImg = self.session.send(prepareBody) # 獲取驗證碼圖片 if codeImg.status_code == 200: break else: Logger.log(\"retrying fetching vertify code...\", level=Logger.warning) with open('check.gif', 'wb') as fr: # 保存驗證碼圖片 for chunk in codeImg: fr.write(chunk) print_vertify_code() verCode = input(\"input verify code:\") # verCode = self.classifier.recognizer(\"check.gif\") # 識別驗證碼 # 構造登陸表單 postData = &#123; '__VIEWSTATE': self.VIEWSTATE, '__EVENTVALIDATION': self.EVENTVALIDATION, '_ctl0:txtusername': Config.userName, '_ctl0:txtpassword': Config.password, '_ctl0:txtyzm': verCode, '_ctl0:ImageButton1.x': '43', '_ctl0:ImageButton1.y': '21', &#125; prepareBody = self.prepare(referer=UrlBean.jwglLoginUrl, originHost=UrlBean.jwglOriginUrl, method='POST', url=UrlBean.jwglLoginUrl, data=postData, params=None) # 獲取登陸 response while True: self.response = self.session.send(prepareBody) if self.response.status_code == 200: break # 根據返回的 html 判斷是否登錄成功 if re.search('用戶名不存在', self.response.text): Logger.log('No such a user!', ['Cleaning password file'], level=Logger.error) print(OutputFormater.table([['No such a user!'], ['Cleaning password file']], padding=2)) Config.cleanUserInfo() reInput = True elif re.search('密碼錯誤', self.response.text): Logger.log('Wrong password!', ['Cleaning password file'], level=Logger.error) print(OutputFormater.table([['Wrong password!'], ['Cleaning password file']], padding=2)) Config.cleanUserInfo() reInput = True elif re.search('請輸入驗證碼', self.response.text): Logger.log('Please input vertify code!', ['Retrying...'], level=Logger.error) print(OutputFormater.table([['Please input vertify code!'], ['Retrying...']], padding=2)) elif re.search('驗證碼錯誤', self.response.text): Logger.log('Wrong vertify code!', ['Retrying...'], level=Logger.error) print(OutputFormater.table([['Wrong vertify code!'], ['Retrying...']], padding=2)) else: Logger.log('Login successfully!', ['UserName: ' + Config.userName, 'Password: ' + Config.password], level=Logger.warning) print(OutputFormater.table([['Login successfully!']], padding=2)) Config.dumpUserInfo() break 拿到已登陸的 session 後，搶課和搶報告都是非常方便的，只要按照瀏覽器提交的數據構造 headers 和表單數據後就可以獲得正常的 response 暗坑總結 剛開始抓到的網頁內容中文都是亂碼，後來 google 解決，發現是 python 的編碼和 asp 框架的編碼問題造成的，python 中的編碼問題真的是讓人頭大 由於網站的防爬蟲設計，會在 html 源碼中插入很多隱藏的表單數據，如此處的 __VIEWSTATE 和 __EVENTVALIDATION，這兩個是非常重要的參數。否則無法成功登陸 兩次訪問之間要有一定的時間間隔，如此處用了一個隨機函數的閉包來獲得隨機時間的間隔 使用裝飾器解決了在訪問搶課網頁前判斷登錄的問題 接下來將循環封裝成函數，加入最大循環次數和超時 完善邊界檢查和異常處理","categories":[{"name":"python","slug":"python","permalink":"http://cycoe.cc/categories/python/"},{"name":"spider","slug":"python/spider","permalink":"http://cycoe.cc/categories/python/spider/"}],"tags":[]},{"title":"Archlinux 安裝小記","slug":"Archlinux安装小记","date":"2017-07-08T16:00:00.000Z","updated":"2019-02-28T01:03:03.206Z","comments":true,"path":"2017/07/09/Archlinux安装小记/","link":"","permalink":"http://cycoe.cc/2017/07/09/Archlinux安装小记/","excerpt":"","text":"準備工作 ethernet 用戶無需對網絡連接做過多設置，wifi 用戶可使用 wifi-menu 工具進行無線網連接 對 /etc/pacman.d/mirrorlist 文件中的源進行排序 分區 利用 cfdisk 或 fdisk 工具進行分區 使用 mkfs.ext4 /dev/sdxY 進行分區的格式化，btrfs 分區運行 mkfs.btrfs -f /dev/sdxY 掛載按順序執行如下命令12345678910mount /dev/sdxY /mnt # 掛載根分區mkdir /mnt/homemkdir /mnt/bootmkdir /mnt/boot/grubmkdir /mnt/boot/efimount /dev/sdxY /mnt/homemount /dev/sdxY /mnt/boot/efimount /dev/sdxY /mnt/boot/grub 若根分區爲 btrfs 格式，則需要先使用如下命令掛載根分區123456mount /dev/sdxY /mnt #掛載根分區cd /mntbtrfs subvolume create @ #創建名爲 @ 的子卷cd ~umount /mntmount /dev/sdxY /mnt -o subvol=@,compress=lzo 分區掛載完畢後可運行 lsblk 查看掛載信息 安裝運行自動化安裝工具 pacstrap -i /mnt base 需要 gcc 等開發工具的用戶需要裝上 base-devel 包 btrfs 分區需要 btrfs-progs 包 wifi 用戶需要同時安裝 dialog wpa_supplicant 來使用 wifi-menu 引導管理器可選擇 grub，efi 主板用戶需加上 efibootmgr，多系統檢測需要 os-prober示例：pacstrap -i /mnt base base-devel btrfs-progs dialog wpa_supplicant grub efibootmgr os-prober 運行 genfstab -U /mnt 查看掛載信息是否正確，檢查無誤後運行 genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 將掛載信息寫入 fstab 配置 使用 archlinux 自帶的 arch-chroot /mnt 接管新系統 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 設置時區 1234# nano /etc/locale.genen_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_TW.UTF-8 UTF-8","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cycoe.cc/categories/Linux/"}],"tags":[]},{"title":"靜態編譯安裝 Qt","slug":"静态编译安装Qt","date":"2017-04-10T16:00:00.000Z","updated":"2019-02-28T01:03:03.136Z","comments":true,"path":"2017/04/11/静态编译安装Qt/","link":"","permalink":"http://cycoe.cc/2017/04/11/静态编译安装Qt/","excerpt":"","text":"由於 pyqt 寫的程序打包過程中依賴庫的問題，打算用 c++ 版的 Qt 重寫程序。但若用系統自帶的共享鏈接庫進行編譯，程序同樣無法在其他機器上運行。因此，此時需要自己手動靜態編譯 Qt，使用靜態鏈接庫編譯的程序會自動將依賴的庫加到最終編譯出的機器碼中。 安裝依賴項 Qt 的界面顯示依賴 freetype 和 fontconfig，這兩個一定要裝上，否則編譯不成功。 安裝完畢後創建 freetype 的軟鏈接到標準的安裝位置：ln -s /usr/include/freetype2/freetype /usr/include/freetype 編譯 下載最新的 Qt everywhere 壓縮包 解壓壓縮包，cd 進壓縮包目錄 運行以下命令對 makefile 進行配置 1./configure -confirm-license -opensource -static -fontconfig -release -no-qml-debug -qt-xcb -nomake tests -nomake examples -skip qtwebkit -prefix /usr/include/Qt-5.8.0-static -static -&gt; 選擇靜態編譯模式 -fontconfig -&gt; 此項一定要加，否則會導致找不到字體 -prefix -&gt; 指定安裝位置 運行 make -j 3 採用 3 線程編譯 最後 sudo make install 安裝 Qt 配置 Qt Creator 安裝 Qt Creator 打開 Qt Creator -&gt; tools -&gt; options -&gt; build，根據安裝路徑配置 Qt version 和 Kit","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cycoe.cc/categories/Linux/"}],"tags":[]},{"title":"基於Jekyll引擎的博客服務器搭建","slug":"基于Jekyll引擎的博客服务器搭建","date":"2017-03-31T16:00:00.000Z","updated":"2019-02-28T01:03:03.096Z","comments":true,"path":"2017/04/01/基于Jekyll引擎的博客服务器搭建/","link":"","permalink":"http://cycoe.cc/2017/04/01/基于Jekyll引擎的博客服务器搭建/","excerpt":"","text":"Transform your plain text into static websites and blogs. 爲什麼要搭建自己的博客服務器之前我們已經利用 GitHub Pages 和 Jekyll 搭建了靜態博客並且託管在了 github.io 上，並且擁有了不錯的頁面效果以及可用性。那我們爲什麼還要搭建自己的博客服務器呢？因爲 GitHub 的服務器在美國，訪問體驗並不順暢；並且在我們 Push 了項目之後，往往要等待一定時間頁面內容纔會刷新。爲了更好的體驗效果，我們將基於樹莓派搭建自己的博客服務器。樹莓派爲 3B+，系統爲 Archlinuxarm-rpi-2 環境搭建安裝 Ruby依次運行下面的命令安裝最新的 Ruby 運行環境：12345$ sudo pacman -S ruby$ ruby --versionruby 2.4.0p0 (2016-12-24 revision 57164) [armv7l-linux-eabihf]$ gem --version2.6.8 出現上面的提示說明 Ruby 安裝成功，gem 可以看做是 Ruby 插件的安裝器，一般安裝 Ruby 後自帶。 注意：Archlinux 用普通用戶安裝 Ruby 後會遇到運行 Gem 插件提示找不到命令的情況，原因是 Ruby 未自動設置環境變量。解決方法： bash打開 ~/.bashrc 文件，加入以下命令： 1export PATH=$PATH:~/.gem/ruby/2.4.0/bin/ fish打開 ~/.config/fish/config.fish 文件（沒有則新建），加入以下命令： 1set -x PATH &#123;$PATH&#125; ~/.gem/ruby/2.4.0/bin 安裝 Jekyll Jekyll is a simple, blog-aware, static site generator for personal, project, or organization sites.Written in Ruby by Tom Preston-Werner, GitHub’s co-founder, it is distributed under an open source license. 安裝 Jekyll 之前需要先安裝 bundle 管理器 1gem install bundle 編輯 Gemfile，在文件中輸入以下內容 1gem &apos;github-pages&apos;, group: :jekyll_plugins 利用 bundle 安裝 Jekyll 渲染需要的所有包 1bundle install 到此需要的依賴安裝完畢，若 fork 的其他人的 Jekyll 模板，則直接進入模板目錄下執行 bundle install。 運行 Jekll 若要在 _site 目錄下生成網站目錄，則運行 bundle exec jekyll build 若要運行可本機訪問的服務則運行 bundle exec jekyll server -w，默認本機地址 127.0.0.1:4000 若要局域網可訪問則需要加上 bundle exec jekyll server -w --host=0.0.0.0","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cycoe.cc/categories/Linux/"}],"tags":[]},{"title":"研究生複試英語面試稿子","slug":"English_Interview","date":"2017-03-24T16:00:00.000Z","updated":"2019-02-28T01:03:03.442Z","comments":true,"path":"2017/03/25/English_Interview/","link":"","permalink":"http://cycoe.cc/2017/03/25/English_Interview/","excerpt":"","text":"English InterviewGood morning, professors! I am very glad to be here for this interview. My name is Zhu Haonan, 22 years old. I am from Wenzhou, the city on the Shore`/ʃɔ:(r)/` of Zhejiang Province. My undergraduate education will be accomplished in Beijing University of Chemical Technology in this July, majoring in polymer material and engineering. From high school, I was captivated`/ˈkæptɪveɪt/` by chemistry, logic and programming. In 2015, I won the second prize in the Mathematical`/ˌmæθəˈmætɪkl/` Contest in Modeling, where I learned how to work in a team and solve problems with math and computer. During my undergraduate study, I recognized`/ˈrekəgnaɪz/` that polymer science is a very prospective`/prəˈspektɪv/` subject, and polymer materials are widely used among numerous`/ˈnjuːmərəs/` fields. I enjoy my major very much. I am long to do further research in this field and make contributions to the development of polymer material with my efforts. Therefore, I wish I could keep pursuing`/pəˈsju/` advanced studies. It is a urgent`/ˈɜːdʒənt/` requirement to seize any chance for self-development, especially facing the fierce`/fɪəs/` social competition. I think the postgraduate study can enrich my knowledge and make me competent`/ˈkɒmpɪtənt/` in my future career`/kəˈrɪə(r)/`. That’s all. Thank you for giving me this opportunity!","categories":[{"name":"blog","slug":"blog","permalink":"http://cycoe.cc/categories/blog/"}],"tags":[]},{"title":"在SSD上使用Btrfs文件系統的相關優化","slug":"在SSD上使用Btrfs文件系统的相关优化","date":"2017-03-24T16:00:00.000Z","updated":"2019-02-28T01:03:03.066Z","comments":true,"path":"2017/03/25/在SSD上使用Btrfs文件系统的相关优化/","link":"","permalink":"http://cycoe.cc/2017/03/25/在SSD上使用Btrfs文件系统的相关优化/","excerpt":"","text":"優化掛載參數在 Linux 中掛載 SSD 上的 btrfs，可以採用各種參數進行優化：12#&lt;file system&gt;&lt;mount point&gt;&lt;type&gt;&lt;options&gt;&lt;dump&gt;&lt;pass&gt;UUID=&lt;略&gt;/ btrfs defaults,ssd,discard,noatime,compress=lzo,subvol=@ ssdbtrfs 文件系統有對 SSD 進行優化，在掛載參數中加入 ssd 即可。該參數不會自動啓用 TRIM/discard。 discard可以通過以下命令確認 SSD 是否支持 TRIM：12sudo hdparm -I /dev/sdX | grep TRIM*Data Set Management TRIM supported (limit 8 blocks) 若 SSD 支持 TRIM 命令，可以在 /etc/fstab 中啓用 discard 參數。建議將 discard 掛載參數作爲首選。據 debian wiki 所述，包括三星、鎂光、英睿達在內的一些 SSD 在 discard/TRIM 上有問題，不能合適地處理 TRIM 命令。該參數不是必需的，也可以自定義週期性運行 fstrim 命令來取代該參數，使用該命令前要確認 SSD 支持 TRIM，否則可能造成數據丟失。當 SSD 有足夠的空餘空間或（未分配的）可用空間時不需要該參數。 noatime掛載參數可以加入 noatime，通過禁止更新訪問記錄來減少不必要的寫操作以提高性能。該選項對 HDD 同樣有性能提升。btrfs 的默認配置爲 relatime。 compress打開壓縮功能在通常情況下有利於提高傳輸性能（並非絕對），也可以節省存儲空間。加入以下掛載參數： compress=lzo compress=zlib lzo 速度更快，zlib 壓縮率更高。注意確認 SSD 主控是否是非壓縮主控，若爲壓縮主控不建議加入該參數。 寫緩存若 SSD 帶有緩存，啓用 Write Cache 可以提高性能：Disks -&gt; Drive Setting -&gt; Enable Write Cache，但在突然斷電的情況下可能造成數據丟失。 I/O 調度SSD 結構不同於傳統硬盤，尋址時間短，I/O 調度算法可選擇 noop 以降低延遲。以下命令可查看與修改調度器：12cat/sys/block/sdX/queue/scheduler # sdX 指你的設備sudotee/sys/block/sdX/queue/scheduler &lt;&lt;&lt; noop 注意以上方法並不持久，重啓後會重置。如果 SSD 是系統唯一的存儲設備，可考慮通過 elevator=noop 內核參數設置 I/O 調度器。也可使用 udev 規則來修改調度器，對多存儲設備同樣有效：1sudo touch /etc/udev/rules.d/60-ssd-scheduler.rules #創建該文件 文件內容如下：12# set deadline scheduler for non-rotating disksACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, ATTR&#123;queue/rotational&#125;==&quot;0&quot;, ATTR&#123;queue/scheduler&#125;=&quot;noop&quot;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cycoe.cc/categories/Linux/"}],"tags":[]},{"title":"教育部公佈2017年考研國家線！","slug":"postgraduate","date":"2017-03-14T16:00:00.000Z","updated":"2019-02-28T01:03:03.549Z","comments":true,"path":"2017/03/15/postgraduate/","link":"","permalink":"http://cycoe.cc/2017/03/15/postgraduate/","excerpt":"","text":"2017 年全國碩士研究生招生考試考生進入複試的初試成績基本要求（學術學位類）2017 年全國碩士研究生招生考試考生進入複試的初試成績基本要求（專業學位類） 爲方便考生調劑，3 月 17 日至 4 月 30 日，教育部將在“中國研究生招生信息網”（公網網址，教育網網址）開通“全國碩士研究生招生調劑服務系統”。 符合條件且有調劑願望的考生可及時上網瞭解調劑信息和調劑系統的使用方法，按要求申請調劑。","categories":[{"name":"blog","slug":"blog","permalink":"http://cycoe.cc/categories/blog/"}],"tags":[]},{"title":"[python機器學習-1]K近鄰算法實現驗證碼識別","slug":"KNN","date":"2017-03-11T16:00:00.000Z","updated":"2019-02-28T01:03:03.032Z","comments":true,"path":"2017/03/12/KNN/","link":"","permalink":"http://cycoe.cc/2017/03/12/KNN/","excerpt":"","text":"A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E. 機器學習在最近幾年有越來越火熱的趨勢。正巧打算做一個爬取教務網成績的爬蟲，碰到驗證碼識別的問題。於是通過各方瞭解後買了《機器學習實戰》這本書，開坑機器學習。機器學習的內容其實很廣，涉及的知識也非常的雜，包括概率論、統計學、逼近論、凸分析、算法複雜度理論和編程等等。因爲不是本科涉及的內容，只能一點一點的補。 分類機器學習分爲監督學習和無監督學習兩種，監督學習是指算法知道要預測的目標，即目標變量的分類信息；而無監督學習時，數據沒有類別信息，也不會給定目標值。 監督學習 無監督學習 k-近鄰算法 K-均值 樸素貝葉斯算法 DBSCAN 支持向量機 \\ 決策樹 \\ 核心思想k-近鄰算法的原理很簡單，即選取 m 個已分類的樣本作爲訓練集，每個樣本擁有 n 個特徵。待測試樣本與每個訓練樣本求歐式距離，對得到的距離順序排序。根據預設的 k 值（k 一般取一個比較小的數）取出前 k 個距離。最後統計每個類別出現的次數，取出現次數最多的類別作爲待測樣本的類別標籤。此處說明 KNN 算法的兩個特徵： 各個特徵等權重，不考慮各個特徵對類別的貢獻大小 最終的分類方法其實是投票表決的方法 代碼爲了提高代碼的運行效率及編碼效率，import 了 Numpy 庫，具體的函數看 官方文檔 ，或者 Numpy 教程 。 分類函數1234567891011121314def classify0(inX, dataSet, labels, k): #輸入(待測樣本向量，訓練樣本矩陣，標籤向量，k) dataSetSize = dataSet.shape[0] #shape函數用來讀取矩陣的維的長度，返回值爲(4L,2L) diffMat = tile(inX, (dataSetSize, 1)) - dataSet #tile函數用來重複 A=[1,2] tile(A,(2,3)) -&gt; [[1,2,1,2，1,2], [1,2,1,2,1,2]] sqDiffMat = diffMat**2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; for i in range(k): votedLabel = labels[sortedDistIndicies[i]] classCount[votedLabel] = classCount.get(votedLabel, 0) + 1 #dict.get(key, default_value)函數用來取鍵對應的值，若鍵不存在則值爲defalut_vlaue sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) #operator.itemgetter(1)表示根據多級列表的第二個元素進行排序 return sortedClassCount[0][0]","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://cycoe.cc/categories/Machine-Learning/"}],"tags":[]},{"title":"記第一次買域名以及搭建個人主頁","slug":"first-post","date":"2017-03-10T16:00:00.000Z","updated":"2019-02-28T01:03:03.512Z","comments":true,"path":"2017/03/11/first-post/","link":"","permalink":"http://cycoe.cc/2017/03/11/first-post/","excerpt":"","text":"看到好基友 @Yinr 搭建了個人主頁，也手癢花4塊錢在萬網上買了 cycoe.win 域名的一年使用權。fork 了 mzlogin 的項目（項目主頁在 GitHub Pages 上搭建了各人主頁，然後把 cycoe.win 域名解析到了 cycoe.github.io 上，經過一些小改，自己的主頁終於搭好了 :laughing: ！最後是去 163 的企業郵箱（163 企業郵箱註冊）申請了基於 cycoe.win 域名的郵箱，我的新郵箱就是 cycoe@cycoe.win。 感謝 GitHub 提供的 GitHub Pages 服務 mzlogin 的 Jekyll 模板","categories":[{"name":"blog","slug":"blog","permalink":"http://cycoe.cc/categories/blog/"}],"tags":[]},{"title":"如何同步GitHub上游更新","slug":"如何同步GitHub上游更新","date":"2017-03-10T16:00:00.000Z","updated":"2019-02-28T01:03:02.996Z","comments":true,"path":"2017/03/11/如何同步GitHub上游更新/","link":"","permalink":"http://cycoe.cc/2017/03/11/如何同步GitHub上游更新/","excerpt":"","text":"在 GitHub 上進行項目的團隊協作，一般都是 fork 組織倉庫到自己的賬號下，提交補丁後再提交 Pull Request。上游倉庫一直保持更新。由於最近在做 LCTT 項目，經常需要同步上游其他人的翻譯，下面就以 LCTT 項目爲例，記錄一下 GitHub 上 fork 倉庫同步上游更新的操作。 使用 git remote -v 查看當前的遠程倉庫別名，輸出如下： 1234LCTT https://github.com/LCTT/TranslateProject.git (fetch)LCTT https://github.com/LCTT/TranslateProject.git (push)origin git@github.com:cycoe/TranslateProject.git (fetch)origin git@github.com:cycoe/TranslateProject.git (push) 其中 origin 是自己賬號下的對應遠端倉庫地址別名， LCTT 是設定好的上游倉庫地址的別名。此處 LCTT 項目已經幫我們設置好了就不需要另外設置。 如果沒有設置上游倉庫地址，可通過 git remote add 上游倉庫別名 上游倉庫地址 命令來設置上游倉庫的別名。 同步上游倉庫更新到本地，併合並更新到本地倉庫 master 分支 123git fetch LCTT #從上游倉庫抓取更新git checkout master #切換到 master 分支git merge LCTT/master #合併上游更新到 master 分支 git push 命令推送本地倉庫到 fork 倉庫","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://cycoe.cc/categories/GitHub/"}],"tags":[]},{"title":"CPVC熱穩定劑","slug":"CPVC热稳定剂","date":"2017-03-08T16:00:00.000Z","updated":"2019-02-28T01:03:02.922Z","comments":true,"path":"2017/03/09/CPVC热稳定剂/","link":"","permalink":"http://cycoe.cc/2017/03/09/CPVC热稳定剂/","excerpt":"","text":"熱穩定劑是一類能防止或減少聚合物在加工使用過程中受熱而發生降解或交聯,延長複合材料使用壽命的添加劑。常用的穩定劑按照主要成分分類可分爲鹽基類、脂肪酸皁類、有機錫化合物、複合型熱穩定劑及純有機化合物類。 分類 鹽基類熱穩定劑:鹽基類穩定劑是指結合有“鹽基”的無機和有機酸鉛鹽,這類穩定劑具有優良的耐熱性、耐候性和電絕緣性,成本低,透明性差,有一定毒性,用量一般在0.5%~5.0%。 脂肪酸類熱穩定劑:該類熱穩定劑是指由脂肪酸根與金屬離子組成的化合物,也稱金屬皁類熱穩定劑,其性能與酸根及金屬離子的種類有關,一般用量爲0.1%~3.0%。 有機錫類熱穩定劑:該類熱穩定劑可與聚氯乙烯分子中的不穩定氯原子形成配位體,而且在配位體中有機錫的羧酸酯基與不穩定的氯原子置換。這類熱穩定劑的特點是穩定性高、透明性好、耐熱性優異,不足之處是價格較貴。 複合型熱穩定劑:該類熱穩定劑是以鹽基類或金屬皁類爲基礎的液體或固體複合物以及有機錫爲基礎的複合物,其中金屬鹽類有鈣—鎂—鋅、鋇—鈣—鋅、鋇—鋅和鋇—鎘等;常用的有機酸如有機脂肪酸、環烷酸、油酸、苯甲酸和水楊酸等。 有機化合物熱穩定劑:該類熱穩定劑除少數可單獨使用的主穩定劑(主要是含氮的有機化合物)外,還包括高沸點的多元醇及亞磷酸酯,亞磷酸酯常與金屬穩定劑並用,能提高複合材料的耐候性、透明性,改善製品的表面色澤。 PVC熱穩定劑的作用機理 吸收中和HCL,抑制其自動催化作用。這類穩定劑包括鉛鹽類、有機酸金屬皁類、有機錫化合物、環氧化合物、酚鹽及金屬硫醇鹽等。它們可與HCL反應,抑制PVC脫HCL的反應。 置換PVC分子中不穩定的烯丙基氯原子抑制脫PVC。如有機錫穩定劑與PVC分子的不穩定氯原子發生配位結合,在配位體中,有機錫與不穩定氯原子置換。 與多烯結構發生加成反應,破壞大共軛體系的形成,減少着色。不飽和酸的鹽或酯含有雙鍵,與PVC分子**軛雙鍵發生雙烯加成反應,從而破壞其共軛結構,抑制變色。 捕捉自由基,阻止氧化反應。如加入酚類熱穩定劑能阻滯脫HCL,是由於酚給出的H原子自由基能與降解的PVC大分子自由基偶合,形成不能與O2反應的物質,而具有熱穩定作用。這種熱穩定劑可具有一種或兼具幾種作用。 理想的PVC熱穩定劑應是一種多功能物質,或者是一些材料的混合物,它們能夠實現以下功能:一是置換活潑、不穩定的取代基;二是吸收並中和PVC加工過程中放出的HCL,消除HCL的自動催化降解作用;三是中和或鈍化對降解起催化作用的金屬離子及其他有害雜質;四是通過多種形式的化學反應可阻斷不飽和鍵的繼續增長,抑制降解着色;五是最好對紫外光有防護屏蔽作用。通常熱穩定劑根據各自的特殊效能配合使用,單獨使用的情況極少,而且大部分品種是粉末狀,一些是毒性很大的化學物質。爲了使用方便,防止粉塵中毒,減小毒性物質或代之以無毒性物質,近年國內外研製出許多種複合穩定劑,例如,世界著名的德國熊牌複合穩定劑系列,美國、德國、日本、荷蘭等國的有機錫或複合有機錫穩定劑,都在中國佔有相當的市場。因此,全力推廣應用我國研製的具有高效、低成本、無粉塵污染及無毒或低毒性的新型複合穩定劑,是我國塑料工業發展的迫切需要。 PVC加工需用熱穩定劑原理分析理想的PVC結構是首—尾結構-CH2-CHCl-CH2-CHCl-,是相當穩定的。但是至今合成PVC的方法還不能像合成順丁橡膠那樣,在齊格爾催化劑的作用下使順丁二烯進行定向有規聚合。氯乙烯的聚合是自由基的無規聚合,它除了有穩定的首—尾結構,還有首—首結構-CH2-CHCl-CHCl-CH-,尾—尾結構-CHCl-CH2-CH2-CHCl-;有偶合歧化生成乙烯基結CH2=CH-CHCl-CH2-結構和烯丙基氯-CH2-CH=CH-CHCl-CH2等。在PVC合成中生成烯丙基氯、叔碳氯和雙鍵等是其分子鏈結構中不穩定因素,不穩定順序爲:PVC分子鏈內部的烯丙基氯&gt;叔碳氯&gt;端基烯丙基氯&gt;仲氯。PVC加工時易於降解正是因爲PVC分子鏈的結構中存在着不穩定因素,如不進行穩定化改性,其分解溫度爲130℃左右,但要將PVC樹脂加工成有用的製品,成型溫度要在190℃以上。因此,必須添加熱穩定劑對其結構進行穩定化改進。 各類熱穩定劑受熱變色評析理想的熱穩定劑應同時具有吸收HCL、消除活性部位、向共軛多烯鏈加成、破壞碳正離子鹽、防止自動氧化等功能,而又不產生對PVC降解有催化作用的產物。實際的熱穩定劑因具有不同的功能而表現出不同的熱穩定特性,大致可分爲初期型、長期型、中間型和全能型四類。 鎘、鋅皁屬典型的初期型熱穩定劑,能快速吸收HCL,並在Cd、Zn的催化下有效地以羧酸根取代PVC鏈上的不穩定氯原子,從而有效抑制初期降解和着色,但因其消耗快而轉化產物CdC12、ZnC12,又是PVC脫HCL的高效催化劑,因而會引發PVC惡性降解使物料突然變黑,因此長期熱穩定性差。 鋇、鈣皁屬典型的長期型熱穩定劑,只有吸收HCL的功能,因此不能有效抑制PVC着色,但因轉化產物BaC12、CaC12不具催化活性,不會引起PVC突然變黑,長期熱穩定性較好。 脂肪酸有機錫屬中間型,既能吸收HCL,又能有效地以羧酸根取代PVC鏈上的不穩定氯原子,並且轉化產物不具催化活性。 硫醇有機錫則具有全能型特徵,能同時以各種機制穩定PVC,轉化產物也不具催化活性,因此兼具優異的初期和長期熱穩定效果。","categories":[{"name":"chemistry","slug":"chemistry","permalink":"http://cycoe.cc/categories/chemistry/"}],"tags":[]},{"title":"用GitHub-Pages和jekyll搭建個人主頁","slug":"用GitHub-Pages和jekyll搭建个人主页","date":"2017-03-08T16:00:00.000Z","updated":"2019-02-28T01:03:02.959Z","comments":true,"path":"2017/03/09/用GitHub-Pages和jekyll搭建个人主页/","link":"","permalink":"http://cycoe.cc/2017/03/09/用GitHub-Pages和jekyll搭建个人主页/","excerpt":"","text":"閒來無事，打算搭建個人主頁。查閱了各種資料，發現目前最省錢省力的方法就是在 GitHub Pages 上利用 jekyll 靜態網頁生成器搭建。對於 Web 開發小白來說，自己寫網頁代碼不太現實。 好在GitHub 上有許多其他大神製作好的 jekyll 模板，直接 fork 過來修改一下就可以使用，其餘的精力都可以用在文章內容本身上。 搭建步驟 在 GitHub 上找到自己喜歡的 jekyll 模板， fork 到自己的倉庫下，然後點擊 Setting 修改倉庫名稱爲 username.github.io 將 fork 後的項目 clone 至本地 打開 _config.yml 文件修改其中的信息，包括網站名稱、用戶信息等 將 html 或 MarkDown 格式的文章和博客添加到 _posts 文件夾 使用以下命令即可提交更新並推送更新至遠端倉庫 123git add .git commit -am \"post update\"git push 完成以上步驟後，你就應該可以通過 username.github.io 訪問你的主頁了 :clap: ！ 注意事項comments_provider: duoshuo duoshuo_username: cycoe disqus_username: cycoe lazy_load_duoshuo: true 此處的usrname一定要填自己申請的賬號名 進階配置 申請域名 本博客使用的主題爲 mzlogin 的 碼志 主題","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://cycoe.cc/categories/GitHub/"}],"tags":[]}]}