{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"Tag Cloud","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Archlinux 安裝小記","text":"针对 Archlinux 安装的前期准备工作做一个记录。 準備工作 ethernet 用戶無需對網絡連接做過多設置，wifi 用戶可使用 wifi-menu 工具進行無線網連接 對 /etc/pacman.d/mirrorlist 文件中的源進行排序 分區 利用 cfdisk 或 fdisk 工具進行分區 使用 mkfs.ext4 /dev/sdxY 進行分區的格式化，btrfs 分區運行 mkfs.btrfs -f /dev/sdxY 掛載按順序執行如下命令1mount /dev/sdxY /mnt # 掛載根分區23mkdir /mnt/home4mkdir /mnt/boot5mkdir /mnt/boot/grub6mkdir /mnt/boot/efi78mount /dev/sdxY /mnt/home9mount /dev/sdxY /mnt/boot/efi10mount /dev/sdxY /mnt/boot/grub 若根分區爲 btrfs 格式，則需要先使用如下命令掛載根分區1mount /dev/sdxY /mnt #掛載根分區2cd /mnt3btrfs subvolume create @ #創建名爲 @ 的子卷4cd ~5umount /mnt6mount /dev/sdxY /mnt -o subvol=@,compress=lzo 分區掛載完畢後可運行 lsblk 查看掛載信息 安裝運行自動化安裝工具 pacstrap -i /mnt base 需要 gcc 等開發工具的用戶需要裝上 base-devel 包 btrfs 分區需要 btrfs-progs 包 wifi 用戶需要同時安裝 dialog wpa_supplicant 來使用 wifi-menu 引導管理器可選擇 grub，efi 主板用戶需加上 efibootmgr，多系統檢測需要 os-prober示例：pacstrap -i /mnt base base-devel btrfs-progs dialog wpa_supplicant grub efibootmgr os-prober 運行 genfstab -U /mnt 查看掛載信息是否正確，檢查無誤後運行 genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 將掛載信息寫入 fstab 配置 使用 archlinux 自帶的 arch-chroot /mnt 接管新系統 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 設置時區 1# nano /etc/locale.gen2en_US.UTF-8 UTF-83zh_CN.UTF-8 UTF-84zh_TW.UTF-8 UTF-8","link":"/2017/07/09/Archlinux%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/"},{"title":"[python機器學習-1]K近鄰算法實現驗證碼識別","text":"A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E. 機器學習在最近幾年有越來越火熱的趨勢。正巧打算做一個爬取教務網成績的爬蟲，碰到驗證碼識別的問題。於是通過各方瞭解後買了《機器學習實戰》這本書，開坑機器學習。機器學習的內容其實很廣，涉及的知識也非常的雜，包括概率論、統計學、逼近論、凸分析、算法複雜度理論和編程等等。因爲不是本科涉及的內容，只能一點一點的補。 分類機器學習分爲監督學習和無監督學習兩種，監督學習是指算法知道要預測的目標，即目標變量的分類信息；而無監督學習時，數據沒有類別信息，也不會給定目標值。 監督學習 無監督學習 k-近鄰算法 K-均值 樸素貝葉斯算法 DBSCAN 支持向量機 \\ 決策樹 \\ 核心思想k-近鄰算法的原理很簡單，即選取 m 個已分類的樣本作爲訓練集，每個樣本擁有 n 個特徵。待測試樣本與每個訓練樣本求歐式距離，對得到的距離順序排序。根據預設的 k 值（k 一般取一個比較小的數）取出前 k 個距離。最後統計每個類別出現的次數，取出現次數最多的類別作爲待測樣本的類別標籤。此處說明 KNN 算法的兩個特徵： 各個特徵等權重，不考慮各個特徵對類別的貢獻大小 最終的分類方法其實是投票表決的方法 代碼爲了提高代碼的運行效率及編碼效率，import 了 Numpy 庫，具體的函數看 官方文檔 ，或者 Numpy 教程 。 分類函數1def classify0(inX, dataSet, labels, k): #輸入(待測樣本向量，訓練樣本矩陣，標籤向量，k)2 dataSetSize = dataSet.shape[0] #shape函數用來讀取矩陣的維的長度，返回值爲(4L,2L)3 diffMat = tile(inX, (dataSetSize, 1)) - dataSet #tile函數用來重複 A=[1,2] tile(A,(2,3)) -&gt; [[1,2,1,2，1,2], [1,2,1,2,1,2]]4 sqDiffMat = diffMat**25 sqDistances = sqDiffMat.sum(axis=1)6 distances = sqDistances**0.578 sortedDistIndicies = distances.argsort()9 classCount = {}10 for i in range(k):11 votedLabel = labels[sortedDistIndicies[i]]12 classCount[votedLabel] = classCount.get(votedLabel, 0) + 1 #dict.get(key, default_value)函數用來取鍵對應的值，若鍵不存在則值爲defalut_vlaue13 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) #operator.itemgetter(1)表示根據多級列表的第二個元素進行排序14 return sortedClassCount[0][0]","link":"/2017/03/12/KNN/"},{"title":"Construct Dwarf Fortress Lazy Newbee Package in ArchLinux","text":"Included With This Package:DwarfFortress-LNP 也就是我们常说的懒人包，由游戏本体、工具包和图形包组成。在 archlinux 上，我们无法通过 aur 简单地安装懒人包，因此我们需要分别安装懒人包中的各个部分来达到同样的效果。 懒人包主要包括如下部分： Pidgeot’s PyLNP 0.13 Lazy Newb Pack Python interface Utilities: DFHack Linux V0.44.09-r1 (gcc 5.4.0) TWBT 6.41 Dwarf Therapist v39.3.1 (compiled with qt5.5.1) Soundsense r2016-1 SoundCenSe GTK 1.4.2 (Requires Mono, go HERE for install instructions) qfconvert 2.04 (See ./LNP/about/qfconvert.md for usage instructions) DF Announcement Filter 1.01 (Requires Java) Legends Browser 1.17.1 (Requires Java 8) Armok Vision 0.19.1 Graphics (Now using fricy’s Updated tilesets!) [16x16] ASCII [16x16] Afro [20x20] AutoReiv [18x18] CLA [24x24] GemSet [16x16] Ironhand [12x12] Jolly Bastion [16x16] Mayday [32x32] Meph-lite [16x16] Obsidian [16x16] Phoebus [16x16] Rally Ho [16x16] Spacefox [20x20] Taffer [16x16] Tergel [16x16] Wanderlust UtilitiesDFHack Linux V0.44.09-r1 (gcc 5.4.0)DfHack is an attempt to unite the various ways hack tools access DF memory and allow for easier development of new tools (and of course, make the game more enjoyable for players). In archlinux, we can get DfHack by install it with yay:1yay -S dfhack-twbt-binAs we can see, we installed a DfHack version integrated with TWBT. That means we don’t need to install TWBT again. What’s more, package ‘dfhack-twbt-bin’ depends on the package ‘dwarffortress’ in community repository. But as default, the ‘PKGBIULD’ file of ‘dfhack-twbt-bin’ will download the dfhack binary compiled with gcc-4.8, which provide an out-of-date version of remotefortressreader plugin. To avoid this, you can command the PKGBIULD to download dfhack compiled with gcc-7. To get this magic as below, edit PKGBIULD with editor:1...2# https://github.com/DFHack/dfhack/releases/download/$_pkgver/dfhack-$_pkgver-Linux-64-gcc-4.8.tar.bz23https://github.com/DFHack/dfhack/releases/download/$_pkgver/dfhack-$_pkgver-Linux-64-gcc-7.tar.bz24...5md5sums=('e630ae2fc93c6c7b55552336da2b6c07'6 '3853c6f890d3541f710f2c4833a9e696'7 '6730da5fec400ece9102552e77996fcb'8 '052a58e7f5f1af8be3ddefe9677b8fc6'9 # 'e200a6225dcf285e2eac19c1d1e118ea'10 'bdbe256099ec9ffd90f391f0d069742f'11 '8eac5ae59dad0397090c4f50d50ef841')12... Then run makepkg to download lacking files. TWBT 6.41This plugin improves various aspects the game interface. Originally I wrote a small plugin because I was tired seeing coffins instead of zeroes and all that stuff. It has greately evolved since then. Some functions may not work or have issues in Adventurer Mode. See readme for all details. Main function is to use separate fonts (tilesets) for map tiles and for text. Text and map font may also have different sizes. Map tiles can have any size, no requirement to have at least 80x25 grid anymore. Multi-level rendering. Allows to override tile numbers for buildings, items and various tile types. mapshot command saves image of the entire map in full size. “Multilayered” rendering where floor is visible behind buildings and items. (see here for details) Tiles can have parts that will and parts that will not be affected by material colour. (see here for details) “Multilayered” rendering for units too. (see here for details) An option to hide stockpiles (background, not items of course) unless in [q], [p] and [k] modes. (see here for details) To make a long story short, TWBT can greately improve the graphics. Dwarf Therapist v39.3.1 (compiled with qt5.5.1)Another life-change utility, as it can access memory when df is running, then you can manage then labor of dwarves with it. (Conflict with auto-labor in DfHack) You can install it with yay -S dwarftherapist-git. It’s a GUI program written with Qt. Open it after you opened a map in df, then you can see the labor informations organized in table. Soundsense r2016-1Sound package for df that can be installed with yay -S soundsense. It provide sounds by parsing event changes in ~/.dwarffortress/gamelog.txt. SoundCenSe GTK 1.4.2 (Requires Mono, go HERE for install instructions)Maybe a fork of Soundsense written by c# and GTK2, by I never run successfully. qfconvert 2.04 (See ./LNP/about/qfconvert.md for usage instructions)Quickfort 2 is a utility for Dwarf Fortress that helps you build fortresses from “blueprint” .CSV, .XLS, and .XLSX files. DF Announcement Filter 1.01 (Requires Java)This utility gives you a live feed of announcements without having to pause the game to check the announcement page. It’s configurable, allowing you to only see the announcements you’re actually interested in, and you can also have combat announcements show up in the feed rather than checking the reports screen. Legends Browser 1.17.1 (Requires Java 8)Legends Browser is an multi-platform, open source, java-based legends viewer for dwarf fortress 0.44. You can read about the legends and stories in browser interactively. You can download the latest release version in this page, then run it with java -jar legendsbrowser-1.17.1.jar. Before that, you should export a xml file in legend mode. Armok Vision 0.19.1A 3d realtime visualizer for Dwarf Fortress rendering with unity, similar with stonesense, but can run independent with df. GraphicsI prefer the Spacefox graphics pack. This is a fork with installation script.","link":"/2019/08/09/Construct-Dwarf-Fortress-Lazy-Newbee-Package-in-ArchLinux/"},{"title":"Nocturnal使用說明","text":"Nocturnal by CycoeGitHub 地址如果在使用過程中發現 bug，可到此處進行反饋，或者直接提交修復 PR，感謝支持！ 聲明Nocturnal 是我課餘時間練習 python 代碼編寫的程序，針對使用引起的一切後果本人概不負責。 關於捐贈Nocturnal 不併強制要求捐贈，但爲了防止軟件被濫用而出現的一系列問題，因此需要提供解密密鑰才能使用，具體操作如下： 打開軟件，此時會自動彈出一個命令提示符窗口和一個二維碼 微信掃描二維碼添加我爲好友 你能在命令提示符窗口上看到類似這樣一段話1你的 id 爲 2160。請將 id 發給開發者獲取解鎖密鑰2請輸入解密密鑰: 將其中的 id 發給我，我會生成解密密鑰 輸入密鑰後即可使用 （可選）如果你覺得這個軟件給你帶來了便利，你可以給開發者包個紅包，建議 5 元 使用說明命令幫助 命令全稱 縮寫 描述 help h 打印幫助信息 emailLogin el 綁定通知郵箱 grade g 成績抓取模式 report r 選報告模式 class c 選課模式 add a 添加待選課程名稱 delete de 刪除待選課程名稱 list l 列出待選課程名稱 donate d 捐贈 quit q 退出 以上表格第一列爲命令的全稱，第二列爲命令的縮寫，輸入全稱與縮寫擁有同樣的效果。 軟件符號說明Nocturnal 使用字符界面（TUI）進行交互，雙擊 Nocturnal.exe 打開軟件後可看到一個黑底白字的字符界面，這不是因爲軟件運行出錯，而是 Nocturnal 本來就是這樣的。現在你應該能在界面上看到一些表格，最上面的表格爲 Nocturnal 的基本信息，中間的表格爲使用幫助。在最下方你可以看到類似這樣的提示符 [0] &gt;&gt;&gt;，該提示符表明此時你可以輸入命令運行相關功能，[0] 中的數字表示後臺正在運行的任務數量。 成績抓取模式在 [0] &gt;&gt;&gt; 後輸入 grade 或 g 回車即可運行成績抓取功能。第一次使用時會自動提示你輸入用戶名和密碼，也就是你的教務網學號和密碼。運行成功後不會有提示，但 Nocturnal 就會在後臺自動抓取成績，並在出新成績時自動通知。 選報告模式在 [0] &gt;&gt;&gt; 後輸入 report 或 r 回車即可運行選報告模式，運行成功後 Nocturnal 會在後臺自動抓取報告列表，並在有新報告放出時自動選報告，並通過郵件通知你。 選課模式選課模式與成績抓取模式和選報告模式不同，選課模式需要在前臺運行。選課模式通過匹配關鍵字實現，針對每門課程可以添加多個關鍵字。比如你想要選 ‘高分子研究方法’ 這門課，則可以在一級關鍵字後輸入 ‘高分子研究方法’ 並回車。但一般課程會有多個時間開課，如果想要指定特定時間或特定老師的課程，則可在二級關鍵字後輸入 ‘週一’ 或 ‘某某某老師’ 即可。Nocturnal 會首先檢查一級關鍵字，如果一級關鍵字對應多個候選，那麼會繼續以二級關鍵字進行過濾，優先選擇符合二級關鍵字的候選。但如果二級關鍵字過濾後沒有可選課程，那麼會返回一級關鍵字的候選列表，並隨機選取一個候選作爲最終選擇。總而言之，Nocturnal 中的關鍵字列表並不是選課的唯一列表，而是一個優先列表，Nocturnal 會按關鍵字列表所給的優先順序依照選取所有可選課程。 注意：選課模式還未經過測試，選課完成後務必登錄教務網檢查已選課程。 具體流程如下： 輸入 a 回車添加需要選的課程名稱，輸入 a 後提示如下：1[0] &gt;&gt;&gt; a2please input 1th key3&gt; &gt; 表示此時你可輸入一級關鍵字，一般我們會將課程名稱作爲一級關鍵字，如此時你可輸入 ‘高分子研究方法’ 回車添加一個關鍵字，完成後程序會提示你輸入二級關鍵字如下：1[0] &gt;&gt;&gt; a2please input 1th key3&gt; 高分子研究方法4please input 2th key5&gt; 此時你可直接輸入回車來結束關鍵字的輸入（在輸入任一關鍵字時，你都可通過直接回車來結束輸入），或者輸入 ‘週六’ 回車作爲想要上課的時間。 重複以上步驟直至你輸入了所有想要選的課程。 輸入 l 查看已經輸入的課程列表 輸入 d 刪除不想選的課程 郵件通知Nocturnal 目前只有通過郵箱一種方式對你進行通知，你可通過輸入 el 來綁定郵箱，Nocturnal 會提示你一步一步進行操作。&lt;接收郵箱&gt;爲你要接收通知的郵箱，建議使用 qq 郵箱，這樣使用微信綁定 qq 郵箱後就可以的即時地收到郵件通知消息。&lt;發送郵箱&gt;可以使用任意郵箱，但發送郵箱需要輸入密碼。 爲發送郵箱的主機地址，qq 郵箱對應的是 ‘smtp.qq.com’，163 郵箱對應 ‘smtp.163.com’，其他郵箱請自行百度。&lt;端口&gt; 默認值爲 ‘25’（注意：使用端口 25 意味着不使用 SSL 加密，希望郵件加密的同學請自行百度）。每步輸入過程中，提示符後括號中爲原始值，如果你不希望更改原始值，直接回車即可。 更新日誌Date: 2017-1-3Version: V4.0 Date: 2017-12-15Version: V3.1 [bug fix] 修復掉線後不能重新登錄的問題 修復達到最大重試次數後不會自動停止的問題 [optimization] 重新登錄時清理內存 簡化代碼結構 新增等待時的動畫效果 完善自定義郵箱登錄 Date: 2017-12-14Version: V3.0 [bug fix] 修復選報告時的崩潰問題 [optimization] 重磅更新！新增驗證碼自動識別，花了大力氣才寫出來，現在無需手動輸入驗證碼登錄 更新了選報告的入口，優化了休眠邏輯 命令行提示已漢化 優化郵件提醒，現在只會發送最新選到的報告列表 新增報告黑名單，選到的報告自動加入黑名單列表中，防止手動退了後又重複選上 新增捐贈入口，希望大家多多支持！ 打包成安裝文件，不用再手動解壓","link":"/2018/09/06/Nocturnal%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"},{"title":"Linux下常用軟件和配置記錄","text":"隨着使用 Linux 系統的年頭越來越長，積累的相關技巧也越來越多。最近一次重裝系統突然發現很多配置都已經忘的差不多了，想要配置系統還需要去網上到處搜刮資料實在是麻煩，因此打算用一篇博客記錄關於 Linux 系統的配置及常用軟件的介紹。 硬件相关配置一般来说，在 Windows 上驱动是随硬件的发布同步释出的，而 Linux 上需要硬件先发布，开源驱动才能跟上。Linux 内核能较好地适配所有不太新的硬件，太新的硬件就自求多福了。目前遇到最有可能出问题的硬件有无线网卡、触摸板、显卡等。因此，这些驱动需要单独配置。 APU 核显就目前形式来看，牙膏厂的 CPU + iGPU 是问题概率最小的组合，虽然 10 代以前 Intel 核显的性能鸡肋得不行，但胜在稳定。APU 次之，本来我以为 APU 是与 Intel 同等稳定的存在，但 xf86-video-amdgpu 驱动竟然遇到了问题… Intel CPU + NVIDIA GPU 的组合在早些年是绝对不推荐的，但是最近 bumblebee 和 prime 等项目趋于成熟，NVIDIA 显卡的使用体验好了不少，但还是比不上 Intel 和 AMD 的核显。我的 CPU 和 显卡型号如下：1CPU: Topology: Quad Core model: AMD Ryzen 5 3550H with Radeon Vega Mobile Gfx2 bits: 64 type: MT MCP arch: Zen+ rev: 1 L2 cache: 2048 KiB3 flags: avx avx2 lm nx pae sse sse2 sse3 sse4_1 sse4_2 sse4a ssse3 svm4 bogomips: 335505 Speed: 2203 MHz min/max: 1400/2100 MHz boost: enabled Core speeds (MHz):6 1: 2011 2: 1879 3: 1198 4: 1199 5: 1202 6: 1206 7: 1199 8: 11997Graphics: Device-1: AMD Picasso vendor: Lenovo driver: amdgpu v: kernel bus ID: 03:00.08 chip ID: 1002:15d89 Display: x11 server: X.Org 1.20.5 driver: amdgpu resolution: 2560x1600~60Hz10 OpenGL: renderer: AMD RAVEN (DRM 3.33.0 5.3.12-arch1-1 LLVM 9.0.0)11 v: 4.5 Mesa 19.2.4 direct render: Yes 此处只有一点需要注意，不要安装官方源的 xf86-video-amdgpu，会导致机器异常耗电并且无法挂起大量发热。安装 AUR 上的 Git 版本可暂时解决问题。1yay -S xf86-video-amdgpu-git 在 /etc/X11/xorg.conf.d/20-amdgpu.conf 配置中加入如下 section 启用 TearFree1Section &quot;Device&quot;2 Identifier &quot;AMD&quot;3 Driver &quot;amdgpu&quot;4 Option &quot;TearFree&quot; &quot;true&quot;5EndSection 亮度配置Intel 核显与 AMD 核显调节亮度的方法不太相同，具体步骤参考我的另一篇博客 Archlinux 配置讓 Qt5 程序使用原生 GTK+ 主題Qt5 程序在 GTK3 環境下主題不統一真的很難受，尤其是 GTK3 用了黑色主題而 Qt5 還是刺眼的白色主題的時候。不像在 KDE 設置中設置 GTK3 主題那麼方便，設置 Qt5 主題可需要好好折騰一番。而且這個解決方案也是我使用了近一年後才找到的答案。 首先你需要安裝 qt5ct 來提供 Qt5 程序主題的設置入口。此時直接在應用列表中打開 qt5ct 會提示未設置環境變量，編輯 .xprofile 文件，並在其中加入如下內容1[ \"$XDG_CURRENT_DESKTOP\" = \"KDE\" ] || [ \"$XDG_CURRENT_DESKTOP\" = \"GNOME\" ] || export QT_QPA_PLATFORMTHEME=\"qt5ct\"註銷後重新登錄，此時打開 qt5ct 應該就不報錯了。但此時你會發現主題列表中只有 Qt5 自帶的幾個樣式，而沒有 Gtk3 主題。你需要安裝 qt5-styleplugins 來使 Qt5 支持 GTK2 主題。你沒有看錯，我也不知道爲啥 Qt5 只支持 GTK2 的主題。但是我們要如何設置 GTK2 主題呢，好吧，又需要安裝一個叫 gtk-theme-switch2 的工具。在 gtk-theme-switch2 中設置好滿意的 GTK2 主題後，再在 qt5ct 中設置 Qt5 主題爲 GTK2 即可。 2019-08-11 更新事实上現在有个更加好用的 qt 主题引擎叫 Kvantum，样式更加現代并且支持透明。sudo pacman -S kvantum-qt5 安装完成后，在 qt5ct 中将 kvantum 设置为默认主题引擎，并在 kvantum 中設置主题即可。 variety 无法设置壁紙目前我遇到过两种情况可能导致 variety 无法设置壁紙。 未安装 feh，虽然 variety 的依赖项中并没有 feh，但是缺少 feh 确实无法设置壁紙。 如果没有安装 display manager，variety 无法获取当前桌面的环境变量，在 .xinitrc 中添加1# variables set identifying which DE / WM you're using,2# so variety can know what to do. 3export XDG_CURRENT_DESKTOP=i3-gaps dunst 无法显示通知同样是由于没有 display manager 导致的，在 .xinitrc 中添加1# When using dunst without a Display Manager,2# the DISPLAY environment variable might not be correctly set.3systemctl --user import-environment DISPLAY 小鹤双拼每次重装系统都需要重新配置输入法，更蛋疼的是在 Rime 中添加鹤形码表时，总出现部署错误。虽然最后折腾半天总是莫名其妙地整好了，但是不得不感叹配置 Rime 真是玄学（虽然很不想承认是自己对 Rime 的配置文件一窍不通:laughing:）。特此记录一下给 Rime 添加鹤形的过程，虽然以后按相同的步骤也不一定能配置成功。 第一步，安装 fcitx 框架（ibus 框架就不考虑了，fcitx 用习惯了）和 Rime 的 fcitx 实现。1# Archlinux2sudo pacman -S fcitx fcitx-rime fcitx-configtool3# openSUSE4sudo zypper in fcitx fcitx-rime fcitx-config-gtk第二步，在 fcitx 设置中加入 rime 输入法，记得关闭“只显示当前语言输入法选项”。切换到 Rime 输入法，此时应该会自动运行一次 deploy。 第三步，将我的配置中的 .config/fcitx 目录复制到对应的路径，其中已经包含了 flypy 使用的码表（之前小鹤双拼官网发布的挂接码表文件，但因为没有通用的配置方法目前已经下架），并将运行下面的命令将配置文件复制到 Rime 系统级路径中（尝试过复制到 .config/fcitx/rime/build/default.custom.yaml，没有效果）。1# 备份原配置2sudo mv /usr/share/rime-data/default.yaml /usr/share/rime-data/default.yaml.bak3# 复制新配置4sudo cp default.yaml /usr/share/rime-data/default.yaml 第四步，在 fcitx 上右键，选择 deploy，此时会提示部署错误，但是惊喜地发现输入法已经可以使用。 常用软件用了几年 Linux 后发现其实 Linux 平台的软件并不少（当然 Adobe 全家桶和 MS Office 除外，要做设计或者办公还是老老实实 Windows 吧:speak_no_evil:），只是与 Windows 和 Mac 平台常用的软件不同而已。Linux 的真正强大之处是命令行软件，几条简单的命令组合就可以完成复杂的功能。 Dia一個非常小的流程圖繪製軟件，但是功能夠用。 ncduncdu (NCurses Disk Usage) 是一個基於 NCurses 系統的磁盤用量分析命令行軟件，相似功能的還有基於 GTK+ 的 Baobab（從版本號來看應該是屬於 Gnome 桌面套裝）。其實對我來說真的很少使用此類軟件，畢竟我很少刪除磁盤文件，但是最近 /Home 分區接近爆滿讓我很難受，還是需要從磁盤的角落翻出以後再也用不上的大文件以刪除之。 xreaderpdf 文檔閱讀器，X-Apps 計劃中的一員（這個計劃好像只有個閱讀器？:laughing:）。體積小巧，優點是可以使用 hjkl 等 vim 鍵位進行控制。缺點是沒有高級功能，單純作爲一個閱讀器還是不錯的。 pcmanfmLXDE 桌面環境默認文件管理器，實話說比 Gnome 的鸚鵡螺好用太多，功能上與 Dolphin 相近。Archlinux 上有單獨提供 pcmanfm-gtk3 的安裝包，其他髮型版上應該默認使用的就是 GTK3 了。 lxappearanceGTK+ 界面主題設置工具，又是 LXDE 的一員。LXDE 自帶的幾款軟件質量都挺高，界面風格統一併且功能強大。 gpickviewLXDE 默認的圖片查看器，體積小巧，沒有太多花哨功能。 sxivSimple X11 Image Viewer zathuraSuckless pdf 阅读器 rangerpython 写成的基于命令行的文件管理器，有与 Vim 类似的键位绑定，全键盘操作效率爆表。拥有 ranger 就不太需要 pcmanfm 了。 初次使用通过运行 ranger --copy-config=all 拷贝所有配置文件到用户家目录。包含以下文件1commands_full.py # ranger 所有命令2commands.py # 自定义命令3rc.conf # ranger 配置文件4rifle.conf # 文件打开方式配置5scope.sh # 预览配置 文件预览在 rc.conf 中檢查所有 ‘preview’ 的选项1...2# Use non-default path for file preview script?3# ranger ships with scope.sh, a script that calls external programs (see4# README.md for dependencies) to preview images, archives, etc.5set preview_script ~/.config/ranger/scope.sh67# Use the external preview script or display simple plain text or image previews?8set use_preview_script true9...10# 设置图片的 method，虽然 w3m bug 很多，但也是唯一一个选择了11set preview_images_method w3m12... 预览其他类型的文件需要安装对应的依赖1Optional Deps : atool: for previews of archives2 elinks: for previews of html pages3 ffmpegthumbnailer: for video previews4 highlight: for syntax highlighting of code5 libcaca: for ASCII-art image previews6 lynx: for previews of html pages7 mediainfo: for viewing information about media files8 odt2txt: for OpenDocument texts9 perl-image-exiftool: for viewing information about media files10 poppler: for pdf previews11 python-chardet: in case of encoding detection problems12 sudo: to use the &quot;run as root&quot;-feature13 transmission-cli: for viewing bittorrent information14 w3m: for previews of images and html pages但不建议开启压缩包的预览，会大幅影响速度，修改 scope.sh 文件，注释掉压缩包的预览1# Archive2a|ace|alz|arc|arj|bz|bz2|cab|cpio|deb|gz|jar|lha|lz|lzh|lzma|lzo|\\3rpm|rz|t7z|tar|tbz|tbz2|tgz|tlz|txz|tZ|tzo|war|xpi|xz|Z|zip)4 # atool --list -- &quot;${FILE_PATH}&quot; &amp;&amp; exit 55 # bsdtar --list --file &quot;${FILE_PATH}&quot; &amp;&amp; exit 56 exit 1;; 批量重命名ranger 有个非常 sexy 的功能，那就是批量重命名。选中多个文件后，输入 :bulkrename，ranger 会帮你自动打开一个 Vim 编辑器。在 Vim 中你可以利用 Vim 的强大功能对文件名做任何处理，修改完成后保存退出即可。1# This file will be executed when you close the editor.2# Please double-check everything, clear the file to abort.3mv -vi -- test today_test4mv -vi -- test.md today_test.md5mv -vi -- test.pdf today_test.pdf","link":"/2018/11/09/Linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"title":"Planche training calendar","text":"A planche is a skill in gymnastics in which the body is held parallel to the ground, giving the illusion of floating. It is a move that requires significant strength and balance. 剛進大學的時候 ，無意間在 B 站看到一個關於俄挺的視頻，能夠完成俄挺成了我的一個夢想。本科的時候陸陸續續地練過一段時間，練練俯臥撐和團身，團身也就是剛剛高團 2-3 秒的程度。後來因爲實在沒什麼進展也就漸漸放棄了。前幾天回家的路上吹了點小風就感冒了，意識到自己的小身板太弱，再加上最近想要增重，決定重新開始練習俄挺。 2018-04-05從今天開始練習，因爲也好久沒有做俯臥撐了，目前的水平實在太爛。 標準俯臥撐 10 個 衝肩維持 5 秒 2018-04-13練了一個星期的衝肩，每天都在堅持。 衝肩維持 10 秒 窄距俯臥撐 10 個 2018-06-10最近右手小臂疼的厲害，應該是跟前幾天每天用鼠標做視頻有關，看來要好好休息幾天了，最近下調訓練強度，少用鼠標。。不過值得激動的是，目前已經可以比較輕鬆地做團身了，高階團身應該也能 10 來秒了，接下來準備練團身舉腿。 衝肩維持 30 秒 窄距俯臥撐 25 個 衝肩俯臥撐 15 個 團身維持 10 秒 引體向上 7 個 2018-07-25最近一個月因爲手腕一直還是有點疼，尤其搬重物的時候，也就沒怎麼敢繼續練團身，轉而練習引體和前水平。打算先通過前水平鍛鍊背部力量，通過雙力臂鍛鍊手腕力量，等基礎打好後再練習俄挺。引體的話其實應該一組能做個 10 個左右，但是後面幾組做的時候因爲可能是翻腕了的原因，導致手腕還是會疼，發現在雲梯上練習就沒事了，可能是手的朝向的問題。 雙力臂其實還是沒有太大進展，前水平的話一條腿伸直是能保持了，接下來就是要延長持續的時間，然後慢慢向雙腿進步。在宿舍也可以每天都練前水平。 另外利用操場上的槓鈴可以做很多其他的訓練，比如正手擡、反手拉、單手拉、臥推。利用器材可以取得更好的訓練效果。 最後有個非常重要的想法：在家的這幾天發現，想要找個健身器材齊全的公園實在不是很容易，因此希望能做個 App，街健愛好者可以在上面共享健身器材所在的位置，另外可以認識附近的街健愛好者。 衝肩俯臥撐 20 個 前水平團身 10 秒 單槓硬拉 4 個 引體 10 個","link":"/2018/04/13/Planche-training-calendar/"},{"title":"convert format of documents with pandoc","text":"Pandoc 是一個強大的文檔格式轉換軟件，可以對 html、markdown、ppt、doc、pdf 等多種格式進行相互轉換，但在將 markdown 文件轉換爲 pdf 文件的過程中，發現會出現中文編碼的問題，因此需要使用如下命令指定渲染的引擎 pandoc -f markdown_github my.md -o my.pdf --pdf-engine=xelatex -V mainfont=&quot;Your Font&quot;","link":"/2018/06/29/convert-format-of-documents-with-pandoc/"},{"title":"Spawn your blog site with hexo","text":"最近，由於 GitHub 在國內的訪問越來越不穩定，我決定將博客遷移至 Coding（一個國內的代碼託管平臺）。Coding 與 GitHub 類似的可以直接展示靜態的個人主頁，整個配置流程與 GitHub 類似。但是之前使用的是 Jekyll 博客生成器進行構建，Jekyll 的優點是可以直接將代碼 Push 上去，GitHub 可以直接根據 Jekyll 格式的目錄進行部署，無需本地的部署環境，但是由於 Ruby 的性能問題，整個部署過程需要至少幾分鐘，因此尋求其他的生成器解決辦法。後來瞭解到 Hexo，一個由 NodeJS 驅動的博客生成器，於是決定趁遷移嘗試一下。 環境安裝安裝 NodeJSHexo 既然是由 NodeJS 驅動的，那必然 NodeJS 環境是必不可少，另外爲了更方便地管理第三方庫，還需要安裝 npm 管理器。對於我使用的 ArchLinux 爲例，只需要運行以下命令即可完成安裝。 $ sudo pacman -S nodejs npm 安裝 hexo 先創建一個文件夾用於存放博客的資源文件，然後 cd 到該目錄下 安裝 hexo：sudo npm install hexo -g 安裝完成後通過 hexo -v 查看版本 通過 hexo init 將本目錄初始化爲博客的根目錄，可以看到目錄下自動生成了一些文件 各文件解釋如下： node_modules：依賴包 public：存放構建生成的頁面 scaffolds：命令生成文章等的模板 source：用命令創建的各種文章 themes：主題目錄 _config.yml：整個博客的配置 db.json：source 解析得到的信息 package.json：項目所需模塊的配置信息 開始寫博客可以選擇 typora 或者其他的 Markdown 編輯器進行編輯，此處我選擇了 vim 進行文件編輯。要想要 vim 支持 Markdown 的語法高亮需要以下幾個插件 Plugin ‘godlygeek/tabular’ Plugin ‘gabrielelana/vim-markdown’ 部署博客hexo 可以用 $ hexo d -g 命令方便的對博客系統進行部署，但首先需要在博客配置文件 _config.yml 的 Deployment 節中做配置1deploy:2 type: git # 此處是部署的方式3 repo: # 此處是所有需要部署的倉庫，倉庫的設置與 Jekyll 類似4 coding: git@git.coding.net:cycoe/cycoe.git 然後在 Coding 上新建一個名爲 cycoe 的空倉庫（由於 Coding 本身的限制，該倉庫應與用戶名同名），在本機的博客根目錄運行 hexo d -g 即可將博客部署至 Coding。然後打開倉庫設置，將此倉庫設置爲 Coding Pages 即可。 2018-06-05 更新最近 Coding 不知是怎麼了，我的博客總是打不開。湊巧最近剛租了個包月的服務器，於是決定將整個博客遷移到自己的服務器上。 Hexo 和 Jekyll 博客系統的部署原理不太一樣，$ hexo g 是 $ hexo generate 的縮寫，其原理是在本地使用 Hexo 引擎將 _posts 目錄的 Markdown 文件生成網頁結構，結果保存在 public 目錄下，可直接由 Apache 或 Nginx 驅動。 而 $ hexo deploy 正是將 public 目錄下的網頁部署到 Git 倉庫中。因此如果能將倉庫克隆到服務器上進行部署，那麼問題就能解決。 在服務器上建立 Git 倉庫初始化 Git 倉庫$ sudo git init --bare sample.git Git 就會創建一個裸倉庫，即會在當前路徑下創建一個名爲 sample.git 的倉庫。裸倉庫沒有工作區，因爲服務器上的 Git 倉庫純粹是爲了共享，所以不讓用戶直接登錄到服務器上去改工作區，並且服務器上的 Git 倉庫通常都以 .git 結尾。然後，把 owner 改爲服務器的用戶名，不然沒有權限將修改寫入該倉庫。 $ sudo chown -R ubuntu:ubuntu sample.git 將倉庫加到 Hexo 的配置文件1deploy:2 type: git3 repo:4 #coding: git@git.coding.net:cycoe/cycoe.git5 my_server: ubuntu@139.199.95.151:/home/ubuntu/git/blog.git 此處 @ 前的用戶名一定要與服務器倉庫的權限對應，: 後面是倉庫的絕對路徑。 部署此時運行 $ hexo d- g 即可將博客網頁目錄部署到倉庫，但此時查看倉庫會發現目錄下並不是網頁的結構，因爲這個倉庫是裸倉庫，下面並沒有工作區，所以看到的並不是我們 Push 上來的內容。 Git Hook 事件事實上，如果我們此時將該倉庫克隆到另一個目錄下就可以看到工作區了。首先 cd 到需要保存網頁的路徑下 $ cd /home/ubuntu/www/，然後運行 $ git clone /home/ubuntu/git/blog.git 將倉庫克隆至當前路徑。 但是如果每次都要登上服務器手動克隆就違揹我們自動化部署的初衷了。因此此處需要用到 Git 自帶的 Hook 功能，簡單來將講就是在倉庫發生變化前/後所要執行的操作。 Hook 的事件放在裸倉庫目錄的 hooks 文件夾下，這裏我們新建一個名爲 post-receive 的事件，該事件是在倉庫更新合併完成後自動運行，文件中加入如下內容 1#!/bin/bash2cd /home/ubuntu/www/blog # cd 到網頁的展示倉庫3unset GIT_DIR # 非常重要！如果不解綁 GIT_DIR 環境變量無法切換路徑4git config --list5git pull origin master 運行 $ chmod +x post-receive 賦予執行權限 此時再在本機運行 $ hexo d -g 發現網頁目錄也自動更新了 2018-08-18 更新今天寫了一篇博客，運行 $ hexo d -g 想要更新博客，結果發現網頁並沒有變化。登上服務器一看 /home/ubuntu/git/blog.git 倉庫已經更新了，懷疑是更新後沒有成功運行 post-receive。但是自從上次設置好 post-receive 後就沒有改過，按理說應該能夠運行。運行 $ ls -l 命令後發現，/home/ubuntu/git/blog.git 目錄的歸屬者是 ubuntu，而 /home/ubuntu/www/blog 目錄的歸屬者是 nginx，應該是上次我在設置 nginx 的時候不小心把 /home/ubuntu/www 目錄遞歸修改成歸屬 nginx 了。而 post-receive 所做的工作實際上是在我把更新 push 到 /home/ubuntu/git/blog.git 倉庫後，cd 到了 /home/ubuntu/www/blog 目錄並拉取更新。因此我是以 ubuntu 用戶的身份做的 push，又是以 ubuntu 用戶的身份運行的 post-receive，因此在 /home/ubuntu/www/blog 目錄中是沒有權限拉取更新的。 既然已經發現了問題出在用戶權限上。那就可以通過運行 $ sudo chown -R ubuntu:users /home/ubuntu/www 將整個目錄都改爲 ubuntu 所屬，也就不關 nginx 用戶什麼事了，這樣確實非常方便的解決了這個問題。另外 post-receive 在更改用戶歸屬後執行權限丟失了，記得運行 $ chmod +x post-receive 重新賦予執行權限。事實上當初建立 nginx 用戶也是因爲安裝了 nginx 服務，想要弄得更規範些。但因爲懶一直沒給 nginx 建立自己的 Home 目錄，按理說把跟 nginx 相關的目錄都扔到 nginx 用戶對應的 Home 下是最好的。 2018-10-24 更新最近寫的新博客中需要開啓 LaTeX 公式支持，但 hexo 本身對數學公式的支持有些問題，Hexo 默認使用 “hexo-renderer-marked” 引擎渲染網頁，該引擎會把一些特殊的 markdown 符號轉換爲相應的 html 標籤，比如在 markdown 語法中，下劃線 ‘_’ 代表斜體，會被渲染引擎處理爲 標籤。 解決方法更換 Hexo 的 markdown 渲染引擎，使用 ‘hexo-renderer-kramed’ 引擎替代 ‘hexo-renderer-marked’ 引擎，前者在後者的基礎上修復了一些 bug。執行以下命令卸載原引擎並安裝新引擎。1npm uninstall hexo-renderer-marked --save2npm install hexo-renderer-kramed --save此時行間公式應該就可以正常渲染了，但行內公式還是有問題。接下來在博客根目錄中，找到 node_modules\\kramed\\lib\\rules\\inline.js，修改 11 行的 escape 變量的值。1// escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/,2escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/,這一步是在原基礎上取消了對 ‘\\, {, }’ 的轉義(escape)。同時把第 20 行的 em 變量也要做相應的修改。1// em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,2em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,然後運行 hexo clean 清除構建，再 generate 即可解決問題。 在主題中開啓 mathjax 開關打開 themes/next/_config.yml，將 math 的 enable 設爲 true，將 per_page 設爲 true，表示針對每頁單獨決定是否開啓 mathjax 支持。1math:2 enable: true34 # Default(true) will load mathjax/katex script on demand5 # That is it only render those page who has 'mathjax: true' in Front Matter.6 # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE.7 per_page: true89 # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.10 mathjax:11 enable: true12 # See: https://mhchem.github.io/MathJax-mhchem/13 mhchem: false因爲 per_page 設爲 true，因此需要在文章的 Front-matter 裏打開 mathjax 開關。1---2title: Spawn your blog site with hexo3date: 2018-04-14 13:50:184categories: linux5tag: hexo6mathjax: true7---","link":"/2018/04/14/Spawn-your-blog-site-with-hexo/"},{"title":"記第一次買域名以及搭建個人主頁","text":"看到好基友 @Yinr 搭建了個人主頁，也手癢花4塊錢在萬網上買了 cycoe.win 域名的一年使用權。fork 了 mzlogin 的項目（項目主頁在 GitHub Pages 上搭建了各人主頁，然後把 cycoe.win 域名解析到了 cycoe.github.io 上，經過一些小改，自己的主頁終於搭好了 :laughing: ！最後是去 163 的企業郵箱（163 企業郵箱註冊）申請了基於 cycoe.win 域名的郵箱，我的新郵箱就是 cycoe@cycoe.win。 感謝 GitHub 提供的 GitHub Pages 服務 mzlogin 的 Jekyll 模板","link":"/2017/03/11/first-post/"},{"title":"从自然数开始","text":"素数（Prime）对于一个自然数 $n\\in\\mathbb{N}$，若其只能被 $1$ 和它本身整除（即只有两个因子），则被称为素数；若其有多于两个因子，则被称为合数。素数是不能够进行质因式分解的最小单元，因此合数具有唯一的质因式分解（质因子不可再分）。 1 的特殊性1 能够被 $1$ 及其自身整除，但为了体系的自洽，不认为 $1$ 是素数。有如下两个原因： 若 $1$ 是素数，则任意自然数的质因式分解将不是唯一的。$6=2\\times 3=1\\times 2\\times 3$。 任意素数 $p$ 可被分解为 $p=1\\times p$，若 $1$ 为素数，则 $p$ 为合数，与 $p$ 为素数相矛盾。 寻找素数针对素数，我们希望研究： 对于任意 $n\\in \\mathbb{N}$，判断其是否为素数； 对于任意 $n\\in \\mathbb{N}$，找到所有小于 $n$ 的素数，或等价于求小于 $n$ 的素数的个数； 对于任意 $n\\in \\mathbb{N}$，求其质因式分解。 质因式分解前几天，看杂志时发现一个有趣的问题，“对任意一个自然数 $n$，如何求其所有因子的和”。这个问题本身并不困难，但从中可以继续思考质数的相关规律。 既然是要求因子的和，那么我们首先需要用数学语言将因子表示出来。在此之前，我们需要先将这个自然数表示出来。 设 $n$ 有 $m+1$ 个质因子 $p_0 &lt; p_1 &lt; \\cdots &lt; p_m$，则存在如下唯一的质因式分解 n = p_0^{a_0} \\times p_1^{a_1} \\times \\cdots \\times p_m^{a_m}则 $n$ 的因子 $f$ 满足 f = p_0^{b_0} \\times p_1^{b_1} \\times \\cdots \\times p_m^{b_m}其中 \\left\\{\\begin{array}{c} 0 \\leq b_0 \\leq a_0\\\\ 0 \\leq b_1 \\leq a_1\\\\ \\vdots\\\\ 0 \\leq b_m \\leq a_m \\end{array}\\right.,\\ 且\\ b_0, b_1, \\cdots, b_m \\in \\mathbb{N}记所有质因子之和为 $S(n)$，即为所有满足上式的 $f$ 之和 \\begin{split} S(n) &= (p_0^0+p_0^1+\\cdots+p_0^{a^0})\\times (p_1^0+p_1^1+\\cdots+p_1^{a^1})\\times \\cdots \\times (p_m^0+p_m^1+\\cdots+p_m^{a^m})\\\\ &= \\dfrac{p_0^{a_0+1}-1}{p_0-1}\\times \\dfrac{p_1^{a_1+1}-1}{p_1-1}\\times \\cdots \\times\\dfrac{p_m^{a_m+1}-1}{p_m-1}\\\\ &= \\prod\\limits_{i=0}^m \\dfrac{p_i^{a_i+1}-1}{p_i-1} \\end{split}至此，我们已经得到已知自然数 $n$ 所有因子和 $S(n)$ 的表达式。接下来验证一下，$24$ 的所有因子有 $1, 2, 3, 4, 6, 8, 12, 24$，求和得 $S_1(24)=60$。$24$ 的质因式分解为 $24=2^3\\times3^1$，则 $S_2(24)=(2^0+2^1+2^2+2^3)\\times(3^0+3^1)=60$。答案正确！ 但通过观察发现，表达式的值并不直接与 $n$ 相关，而是与 $n$ 的所有质因子相关。我们知道，因式分解是一个 NPC 问题，我们无法在多项式时间内对 $n$ 进行因式分解。那么，我们有没有办法对 $S(n)$ 进行粗略的估计呢？即有没有办法用 $n$ 来表示 $S(n)$ 的上下界？或者更具体的，$S(n)$ 与 $n$ 是否存在某种倍数关系？ 对 $S(n)$ 的表达式进行缩放我们得到 \\begin{split} S(n) &= \\dfrac{p_0^{a_0+1}-1}{p_0-1}\\times \\dfrac{p_1^{a_1+1}-1}{p_1-1}\\times \\cdots \\times\\dfrac{p_m^{a_m+1}-1}{p_m-1}\\\\ &< \\dfrac{p_0^{a_0+1}}{p_0-1}\\times \\dfrac{p_1^{a_1+1}}{p_1-1}\\times \\cdots \\times\\dfrac{p_m^{a_m+1}}{p_m-1}\\\\ &= \\dfrac{p_0}{p_0-1}\\times \\dfrac{p_1}{p_1-1}\\times \\cdots \\times\\dfrac{p_m}{p_m-1}\\times n \\end{split}得到 \\dfrac{S(n)}{n} < \\dfrac{p_0}{p_0-1}\\times \\dfrac{p_1}{p_1-1}\\times \\cdots \\times\\dfrac{p_m}{p_m-1} = \\Pi_p(m)接下来，我们希望知道两件事 对于任意大的 $m$，$\\Pi_p(m)$ 是否存在上界，若 $\\Pi_p(m)$ 的上界存在，则 $\\dfrac{S(n)}{n}$ 的上界存在。 若$\\Pi_p(m)$ 的上界不存在，那么对于确定的 $n$，我们能否得到 $\\dfrac{S(n)}{n}$ 的上界。 首先来解决第一个问题。使用计算机进行计算发现，前 $2^k$ 个质数的 $\\Pi_p(2^k)$ 与 $k$ 呈近似线性关系 \\Pi_p(2^k) = ak + b另外 $2^k$ 以内的质数的分式乘积 $\\Pi_p(\\eta)$ 也与 $k$ 呈近似线性关系。 设 $\\Pi(n)$ 为前 $n$ 个自然数的类似分式积表达式 \\Pi(n) = \\dfrac21 \\times \\dfrac32 \\times \\cdots \\times \\dfrac{n}{n-1} = n则前 $n$ 个质数的 $\\Pi(n)$ 与 $n$ 呈线性关系。 一个为质数， 一个为自然数，其中必然蕴含着质数分布的某种真理。","link":"/2019/02/28/%E4%BB%8E%E8%87%AA%E7%84%B6%E6%95%B0%E5%BC%80%E5%A7%8B/"},{"title":"使用 Emacs 与 Graphviz 绘制流程图","text":"前几天在写 使用 Emacs 与 Org mode 进行 GTD 管理 博客时，用到了 Graphviz 绘制流程 图。正巧之前在 LaTeX 中也用它画过一些图，但都没有系统地入过门，那就趁最近学习一 下吧。 从官网上可以看到，Graphviz 的全称为图Graph可视化 Visualization工具Software，这里的图说的应该不是数学意 义上的函数图像那种图，而是数据结构中的图，强调的关系。 安装 Graphviz Graphviz 本质上是一个命令行工具，在 Archlinux 上只需要通过 sudo pacman -S graphviz 安装即可，其他系统类似。 graphviz-dot-mode Graphviz 在 Emacs 中的集成是通过 graphviz-dot-mode 这个包来实现的，只需要 &lt;M-x&gt; package-install graphviz-dot-mode &lt;RET&gt; 即可。 然后在 Emacs 配置中加入以下内容来启用 1 (use-package graphviz-dot-mode 2 :ensure t 3 :config 4 (setq graphviz-dot-indent-width 4)) 5 6 (use-package company-graphviz-dot) 布局器 Graphviz 中包含了众多的布局器： dot 默认布局方式，主要用于有向图 neato 基于 spring-model（又称 force-based）算法 twopi 径向布局 circo 圆环布局 fdp 用于无向图 基本使用 Graphviz 构建组件为图，节点，边，用属性对其进行描述。 创建一个 dot 布局的图，可以使用以下代码 1 digraph first{ 2 a; 3 b; 4 c; 5 d; 6 a-&gt;b; 7 b-&gt;d; 8 c-&gt;d; 9 } 上述代码等价于 1 digraph first{ 2 a-&gt;b; 3 b-&gt;d; 4 c-&gt;d; 5 } 如果要直接在命令行进行绘图，使用命令 =dot -Tpng first.dot -o first.png=。如果利 用 Emacs Babel 进行绘制，需要如下所示的 Headers。 1 #+begin_src dot :file first.png :cmdline -Tpng :results silent 2 digraph first{ 3 a-&gt;b; 4 b-&gt;d; 5 c-&gt;d; 6 } 7 #+end_src 其中，=:results silent= 表示不在 Org 文件中进行任何输出。 绘制属性 一个图中可能有非常多的节点与边，如果每次都需要声明一个节点的属性会非常麻烦。类似 于面向对象编程的思想，我们可以用 node 和 edge 类标签来设置全局的属性，也可以用对 象标签设置单个节点与边的属性。 1 digraph G{ 2 // 设置图片最大尺寸 3 size = \"40, 40\"; 4 // 设置节点排布方向 5 rankdir = LR; 6 // 设置节点字体 7 node[fontname=\"SimHei\"]; 8 // 设置连线字体 9 edge[fontname=\"SimHei\"]; 10 11 // 设置默认节点属性 12 node[shape=box, color=blue, style=unfilled]; 13 // 设置边的属性 14 edge[color=red]; 15 16 // 节点 17 小蓝; 18 小红[color=red]; 19 // 边 20 小蓝-&gt;小红; // 默认边属性 21 小红-&gt;小蓝[color=blue, style=dashed]; // 自定义边属性 22 } 所有可用的属性见 官网，此处列举部分常用的属性 charset 编码，一般设置 UTF-8 fontname 字体名称，这个在中文的情况需要设置，否则导出图片的时候会乱码，一般设 置微软雅黑(\"Microsoft YaHei\"), linux 下也是同样设置系统带的字体就好，其他字体 设置见fontpath 属性 fontcolor 字体颜色 fontsize 字体大小，用于文本内容 fillcolor 用于填充节点或者集群(cluster)的背景颜色。 size 图形的最大宽度和高度 label 图形上的文本标记 margin 设置图形的边距 pad 指定将绘制区域扩展到绘制图形所需的最小区域的长度（以英寸为单位） style 设置图形组件的样式信息。 对于聚类子图或者节点，如果 style = filled，则 填充聚类框的背景 rankdir 设置图形布局的排列方向 (全局只有一个生效). \"TB\", \"LR\", \"BT\", \"RL\", 分 别对应于从上到下，从左到右，从下到上和从右到左绘制的有向图。 1 digraph { 2 rankdir = RL; 3 A-&gt;B-&gt;C[color=green]; 4 A-&gt;C[label=\"RL\"]; 5 } ranksep 以英寸为单位提供所需的排列间隔 ratio 设置生成图片的纵横比 节点 节点的默认属性为 shape = ellipse, width = .75, height = 0.5 并且用节点标识符作为 节点的显示文字。 如 图 1 中所示，声明两个节点 小蓝 和 小红/，/小蓝 或 小红 就表示这个节点的节点标 识符，后面紧跟的是该节点的属性列表；另一种用法为 节点标识符:节点部分:方向[属性列 表] 小蓝:body[style=filled color=lightblue], 这个为单一节点声明的方式。 节点中的基本属性有 shape 形状，全部形状见 Graphviz 官网，一些常用的图形有 box, circle, ellipse, plaintext, square width height, 图形的宽度和高度，如果设置了 fixedsize 为 true，则宽和高为最终的 长度 fixedsize 如果为false，节点的大小由其文本内容所需要的最小值决定 rank 子图中节点上的排列等级约束. 最小等级是最顶部或最左侧，最大等级是最底部或 最右侧。 same. 所有节点都位于同一等级 min. 所有节点都位于最小等级上 source. 所有节点都位于最小等级上，并且最小等级上的唯一节点属于某个等级 source 或 min 的子图 max sink. 和上类似 边 有向图中的的边用 -&gt; 表示，无向图用 -- 表示。 可以同时连接多个节点或者子图，但是只能有一个属性列表，如下 1 digraph { 2 rankdir = LR 3 A -&gt; B -&gt; c[color=green] 4 } 一些关于边的属性如下： len 首选边的长度 weight 边的权重, 权重越大越接近边的长度 如果我们希望图中的绿色边为主要逻辑分支，需要设置 A-&gt;B-&gt;C-&gt;D-&gt;F 的权重最大，修改 绿色的分支的权重为 100，使其变成主要逻辑分支，修改后的效果如下 1 digraph { 2 rankdir = LR 3 splines = ortho 4 5 A -&gt; B -&gt; C -&gt; D -&gt; F [color=green, weight=100] 6 E -&gt; F -&gt; B -&gt; D [color=blue] 7 B -&gt; E -&gt; H[color=red] 8 } lhead 逻辑边缘的头部(箭头那个位置)，compound 设置为 true 时，边被裁减到子图的边界处 ltail 类似 lhead headlabel 边上靠近箭头部分的标签 taillabel 边上靠近尾部部分的标签 splines 控制如何显示边，取值可以是 none 或者 \"\", 无边 1 digraph { 2 rankdir = LR 3 splines = none 4 5 A -&gt; B -&gt; C -&gt; D -&gt; F [color=green] 6 E -&gt; F -&gt; B -&gt; D [color=blue] 7 B -&gt; E -&gt; H[color=red] 8 } true 或者 spline, 样条线（无规则，可为直或者曲线） 1 digraph { 2 rankdir = LR 3 splines = spline 4 5 A -&gt; B -&gt; C -&gt; D -&gt; F [color=green] 6 E -&gt; F -&gt; B -&gt; D [color=blue] 7 B -&gt; E -&gt; H[color=red] 8 } false 或者 line, 直线 1 digraph { 2 rankdir = LR 3 splines = line 4 5 A -&gt; B -&gt; C -&gt; D -&gt; F [color=green] 6 E -&gt; F -&gt; B -&gt; D [color=blue] 7 B -&gt; E -&gt; H[color=red] 8 } polyline, 折线 1 digraph { 2 rankdir = LR 3 splines = polyline 4 5 A -&gt; B -&gt; C -&gt; D -&gt; F [color=green] 6 E -&gt; F -&gt; B -&gt; D [color=blue] 7 B -&gt; E -&gt; H[color=red] 8 } curved, 曲弧线，看起来像贝塞尔曲线 1 digraph { 2 rankdir = LR 3 splines = curved 4 5 A -&gt; B -&gt; C -&gt; D -&gt; F [color=green] 6 E -&gt; F -&gt; B -&gt; D [color=blue] 7 B -&gt; E -&gt; H[color=red] 8 } ortho, 正交折线 1 digraph { 2 rankdir = LR 3 splines = ortho 4 5 A -&gt; B -&gt; C -&gt; D -&gt; F [color=green] 6 E -&gt; F -&gt; B -&gt; D [color=blue] 7 B -&gt; E -&gt; H[color=red] 8 } 边的方向 示例 声明多部分节点，以及对各部分进行单独设置 1 node0 [label = \"&lt;postid1&gt; string|&lt;postid2&gt; string|&lt;postid3&gt; string3\", height=.5]; 2 node0:head[color=lightblue]; 1 digraph action { 2 node [shape = record,height=.1]; 3 4 node0 [label = \"&lt;head&gt; head|&lt;body&gt; body|&lt;foot&gt; foot\", height=.5] 5 node2 [shape = box label=\"mind\"] 6 7 node0:head:n -&gt; node2:n [label = \"n\"] 8 node0:head:ne -&gt; node2:ne [label = \"ne\"] 9 node0:head:e -&gt; node2:e [label = \"e\"] 10 node0:head:se -&gt; node2:se [label = \"se\"] 11 node0:head:s -&gt; node2:s [label = \"s\"] 12 node0:head:sw -&gt; node2:sw [label = \"sw\"] 13 node0:head:w -&gt; node2:w [label = \"w\"] 14 node0:head:nw -&gt; node2:nw [label = \"nw\"] 15 node0:head:c -&gt; node2:c [label = \"c\"] // center，中间 16 node0:head:_ -&gt; node2:_ [label = \"_\"] // 任意 17 18 node0:body[style=filled color=lightblue] 19 } 子图 subgraph 必须配合 cluster 一起使用，用法为 =subgraph cluster* {} 。 需要设置 compound 为 true，则在群集之间留出边缘，子图的边界关系在 边 的定义中有给出，这里直接给个示例。 1 digraph G { 2 compound = true // 允许子图间存在边 3 ranksep = 1 4 node [shape = record] 5 6 subgraph cluster_hardware { 7 label = \"hardware\" 8 color = lightblue 9 CPU Memory 10 } 11 12 subgraph cluster_kernel { 13 label = \"kernel\" 14 color = green 15 Init IPC 16 } 17 18 subgraph cluster_libc { 19 label = \"libc\" 20 color = yellow 21 glibc 22 } 23 24 CPU -&gt; Init [lhead = cluster_kernel ltail = cluster_hardware] 25 IPC -&gt; glibc [lhead = cluster_libc ltail = cluster_kernel] 26 }","link":"/2020/03/11/%E4%BD%BF%E7%94%A8-Emacs-%E4%B8%8E-Graphviz-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/"},{"title":"Vim- 一款讓我相見恨晚的編輯器","text":"Vim 簡介 Vim is a greatly improved version of the good old UNIX editor Vi. Many new features have been added: multi-level undo, syntax highlighting, command line history, on-line help, spell checking, filename completion, block operations, script language, etc. There is also a Graphical User Interface (GUI) available. 以上關於 Vim 的描述來自 Vim 的官方 GitHub 倉庫。Vim 是一款古老且強大的編輯器，從其誕生之日起到現在已經有二十多年的歷史（比我的年齡都要大 orz）。很多人聽說它的大名一般是因爲它與 Emacs 並稱編輯器之神與神之編輯器。爲什麼會有這樣的名號？除了它們的功能極其強大之外，還因爲它們極其難以上手。以下圖片爲網友戲稱的常用編輯器的學習曲線。 即便如此，Vim 和 Emacs 仍流行到了現在，以至於後來經常能在各處看到的 Vimer（Vim 黨）和 Emacser（Emacs 黨）的編輯器之爭，雖然有的時候可能只是類似於“php 是世界上最好的語言”之類的梗，但足以看出 Vim 確實非常強大，並且用上了就再也回不去了。 安裝 VimVim 在所有的 Linux 發行版上都易於獲得，只需要使用對應的包管理器進行安裝即可，Windows 上也有編譯好的二進制包，但實際在安裝過程中仍會面臨幾個選擇。 以 Archlinux 爲例，Archlinux 的官方倉庫中包含的 Vim 在編譯過程中並沒有編譯進 python、lua 等支持，導致很多插件無法使用，因此爲了能使用上 Vim 的完全體，可以選擇 Gvim。Gvim 是基於 Vim 的一個帶有圖形界面的版本，並在編譯過程中包含進了所有可用組件。如果選擇 Vim 分支，強烈建議使用 Gvim，並且使用 8.0 之後的版本。下載鏈接在此處。 另一個可供選擇的版本是 Neovim，Neovim 是 Vim 的一個 fork 版本，比 Vim 具有更多的特性（Neovim 先首先支持的異步架構和內置 terminal，隨後 Vim 也提供了支持），目前開發活躍，推薦進行嘗試。下載鏈接在此處。 以上的所有版本在下文中都將統一稱爲 ‘Vim’（雖然事實上 Vim 與 Neovim 並不是同一個項目，但在配置和使用方法上是類似的）。無論安裝哪個版本，安裝完成後從應用啓動菜單或命令行應該就能成功啓動。恭喜你！此時已經完成了安裝 Vim 的第一步，現在你看到的是一個黑底白字的字符界面。不過彆着急，接下來我們會一步一步將 Vim 配置成稱手的編輯器。 退出 Vim - 使用 Vim 的第一大難題？雖然客觀上講，退出 Vim 相較於 Vim 其他功能要容易的多，但是確實是第一次使用 Vim 會遇到的一個問題。相對於其他的編輯器，Vim 沒有直觀的退出方式，以至於在 Stack Overflow 上有個專門的問題（見此處）解答如何退出 Vim。甚至有了如下的梗： 看來確實有必要對 Vim 的退出方式做個總結，之列出平常最常用的幾種退出方式 :q 正常退出 :q! 強制退出不保存 :wq 保存並退出 :x 保存並退出，與 :wq 不同之處在於如果文件未做修改則不更新時間戳 強制關機 使用 Vim 前先看幫助文檔安裝好 Vim 後，你可能想要馬上嘗試輸入。但我強烈建議先閱讀軟件自帶的幫助文檔，一款優秀的軟件都會帶有一個詳細的用戶手冊以及一個簡要的使用說明，這有助於降低你在接觸新軟件時的痛苦感。你可以在 Vim 中隨時通過輸入 :help&lt;CR&gt;（ 代表回車）來呼出幫助文檔。 配置 Vim - 從 .vimrc 開始由於 Vim 的流行，GitHub 上有各種各樣現成的 ‘vimrc’（Vim 的配置文件）可供使用。對於不想自己折騰配置的用戶來說，從 GitHub 上下載安裝其他用戶已經編輯好的 ‘vimrc’ 是最好的選擇。甚至還有像 SpaceVim 這樣的模塊化 Vim 配置可以一鍵安裝使用，能大大減少配置所需的時間。 另一些用戶可能想要繼續對 Vim 進行自定義配置，那麼就需要對 ‘vimrc’ 進行修改。在 Linux 系統中，Gvim 與 Vim 的配置文件默認存放在 ‘$HOME/.vimrc’（Neovim 存放在 ‘$HOME/.config/nvim/init.vim’），Windows 下存放在 ‘$VIM/vimrc’。 你可以選擇自己新建一個文件從頭開始。不過還是建議拷貝官方自帶的配置示例，一方面可以省去一部分對常規配置的修改時間，另一方面，官方示例中對各配置語句對應有詳細的註釋。或者也可以選擇從 GitHub 上尋找一個適合你的 ‘vimrc’，或者參考我的配置。 常規配置在使用 Vim 之前，我們需要對其進行一些常規配置，來使它看起來更像一般的編輯器（以下步驟默認了你已經學會 Vim 的基本操作，包括移動光標、輸入、模式切換等）。 首先，通過輸入 :e $HOME/.vimrc&lt;CR&gt; 打開配置文件（’$HOME/.vimrc’ 替換爲你平臺對應的配置文件路徑）。這時，如果此前你已經拷貝了 Vim 的示例配置文件，或者是從網上下載安裝了其他人的配置，那麼你打開的文件裏應該就有那些內容，如果此前還未做過配置，那麼打開的就是一個空文件。 接下來可以選擇下面的配置中你需要的部分拷貝進你的 ‘vimrc’ 1\" about vim setup2set nocompatible \" disable compatible for vi3set shell=/bin/bash \" setup default shell4set shortmess=at \" 啓動時隱去援助提示5set mouse=a \" active mouse control6set clipboard+=unnamed \" support system clipboard7let mapleader=';' \" remap &lt;leader&gt;8\" display setup9set relativenumber \" display relative row number10set ruler \" 顯示標尺，就是在右下角顯示光標位置11set spell spelllang=en_us,cjk \" Spell checking for English, escape Chinese12set langmenu=zh_CN.UTF-813set helplang=cn \" 設置幫助文檔爲中文，需要 'yianwillis/vimcdoc'14syntax enable \" syntax highlight enable15syntax on \" syntax highlight on16set background=dark \" setup background color17colorscheme gruvbox \" setup color scheme18set wildmenu \" select the candidates in interactive way19set backspace=indent,eol,start \" more powerful backspacing20set cursorcolumn \" 淺色高亮當前列21set cursorline \" 淺色高亮當前行22set novisualbell \" 關閉視覺響鈴23set laststatus=2 \" 啓動顯示狀態行24set showcmd \" show the command executed by shortcuts25set noshowmode \" don't show the mode status, avoid override argvs hint26set hlsearch \" highlight for searched results27set incsearch \" highlight for searching results28set showmatch \" show the match of brackets and Quotation mark29set ignorecase \" ignore case when searching and command completion30set gdefault \" default substitute in the whole line 其中，最重要的一條設置就是 set nocompatible，它的作用是關閉對 Vi 的兼容性。Vi 是一款更加古老的編輯器，可視作是 Vim 的前身。如果保留對 Vi 的兼容性也就意味着你放棄了很多 Vim 獨有的特性。set shell=/bin/bash 顯式地聲明瞭 Vim 在運行腳本時調用的解釋器，如果是 Windows 用戶則需要去掉這行。 此時保存配置文件並通過 :so \\$HOME/.vimrc&lt;CR&gt; 重載配置後應該就能看到改變了。但此時你可能會注意到幾條錯誤信息，不要緊張，這是因爲我們在配置中引用了一些插件功能，但事實上我們現在還未安裝插件，安裝插件後你會看到錯誤就消失了。 安裝插件管理器 - 管理插件的插件Vim 有非常多的插件管理器可以使用，除去功能上的細微差異，我們可以將所有插件管理器分爲異步型和同步型。可以簡單地理解爲異步型可以同時下載安裝多個插件，而同步型一次只能處理一個。在 Vim 7.4 版本出來之前，插件管理器都是同步型的，包括大名鼎鼎的 Vundle。 在我剛開始使用 Vim 的時候，Vim 和 Neovim 都已經支持異步架構，但由於當時查的是中文資料，很多都是非常老的文章。基本上所有文章都推薦使用 Vundle 作爲插件管理器，事實上在你用過 vim-plug 之類的異步插件管理器後，你會無法再忍受 Vundle 的速度。這告訴我們技術型的文章還是要去 Google… 不會有人再去使用 Vim 7.4 之前的版本了，所以這裏我推薦使用 vim-plug 作爲插件管理器。vim-plug 的優點是異步下載安裝、插件更新方便、支持插件按需加載，並且只包含一個文件。它的 GitHub 倉庫上有詳細的安裝教程。 安裝插件 - 本體不夠再打 mod雖然 Vim 並不是擴展性最好的編輯器，但它仍支持成千上萬個插件。尋找插件最好的途徑是 GitHub 和 Vim Scripts。以下是我使用的插件列表： 1let g:python3_host_prog = \"/usr/bin/python3\"2call plug#begin('~/.vim/plugged')3Plug 'tomasr/molokai' \" molokai color scheme4Plug 'morhetz/gruvbox' \" gruvbox colorscheme theme5Plug 'mhinz/vim-startify' \" an awesome startup screen6Plug 'vim-scripts/fcitx.vim' \" auto switch fcitx status7Plug 'manu-mannattil/vim-sdcv' \" a simple dictionary for vim8Plug 'vim-airline/vim-airline' \" add status line9Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' } \" directory tree10Plug 'majutsushi/tagbar', { 'on': 'TagbarToggle' } \" Class structure viewer, need ctags installed11Plug 'mbbill/undotree', { 'on': 'UndotreeToggle' } \" undo tree manager12Plug 'tpope/vim-fugitive' \" git support13Plug 'junegunn/gv.vim' \" view git commits in Vim14Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' } \" fuzzy file searcher15Plug 'junegunn/fzf.vim' \" provide many other search functions16Plug 'tpope/vim-commentary' \" a better comment tool17Plug 'vim-scripts/EasyMotion' \" enhance default motions18Plug 'Yggdroot/indentLine' \" indent line indicator19Plug 'jiangmiao/auto-pairs' \" auto add pairs20Plug 'junegunn/rainbow_parentheses.vim' \" a much simpler-using fork of above21Plug 'junegunn/limelight.vim' \" dim others22Plug 'junegunn/goyo.vim' \" provide a dim writing environment23Plug 'w0rp/ale' \" syntax error check24Plug 'Valloric/YouCompleteMe', \" auto complete25 \\{ 'do': './install.py --clang-completer' }26Plug 'SirVer/ultisnips' \" auto complete string27Plug 'honza/vim-snippets' \" complete rules for ultisnips28Plug 'junegunn/vim-easy-align' \" align tool29Plug 'godlygeek/tabular' \" advanced align tool30Plug 'gabrielelana/vim-markdown', { 'for': 'markdown' } \" markdown plugin31Plug 'joker1007/vim-markdown-quote-syntax', { 'for': 'markdown' } \" syntax highlight for quoted code32Plug 'iamcco/mathjax-support-for-mkdp', { 'for': 'markdown' } \" mathjax support for markdown preview33Plug 'iamcco/markdown-preview.vim', { 'for': 'markdown' } \" markdown preview support34Plug 'vim-scripts/indentpython.vim', { 'for': 'python' } \" auto indent for python35Plug 'nvie/vim-flake8', { 'for': 'python' } \" flake8 style code check, need install flake836\" 這兩個插件被 neoformat 替代了37\" Plug 'tell-k/vim-autopep8', { 'for': 'python' } \" a python code format tool wrapper for autopep838\" Plug 'fisadev/vim-isort', { 'for': 'python' } \" imports sorter for python39Plug 'vim-latex/vim-latex', { 'for': 'tex' } \" latex edit environment40Plug 'skywind3000/asyncrun.vim' \" AsyncRun plugin41Plug 'hotoo/pangu.vim' \" Chinese text format42Plug 'vimwiki/vimwiki' \" write wiki in vim43Plug 'yianwillis/vimcdoc' \" a Chinese help handbook for Vim44Plug 'sbdchd/neoformat' \" a collection of format tools45Plug 'ludovicchabant/vim-gutentags' \" generate tags for project46Plug 'mhinz/vim-signify' \" show file modifying status for git47Plug 'Shougo/echodoc.vim' \" show argvs hint on the command line48\"======================\"49\" text object 全家桶 \"50\"======================\"51Plug 'kana/vim-textobj-user' \" 用戶自定義 text object52Plug 'kana/vim-textobj-indent' \" 縮進對象，關鍵字 &lt;i&gt;53Plug 'kana/vim-textobj-syntax' \" 語法對象54Plug 'kana/vim-textobj-function', { 'for':['c', 'cpp', 'vim', 'java'] } \" 函數對象，關鍵字 &lt;f&gt;55Plug 'sgur/vim-textobj-parameter' \" 參數對象，關鍵字 &lt;,&gt;56Plug 'coderifous/textobj-word-column.vim' \" 列對象，關鍵字 &lt;c&gt;57Plug 'bps/vim-textobj-python' \" python 對象合集，&lt;c&gt; 類，&lt;f&gt; 函數58Plug 'tpope/vim-surround' \" deal with surround for text object59call plug#end()60filetype plugin indent on 由於 vim-plug 的強大，我們只需要將上述配置粘貼進 vimrc 中，重載配置文件後運行 :PlugInstall&lt;CR&gt; 就會自動安裝所有插件，甚至 vim-plug 會幫我們做好安裝後的處理。 必裝插件配置 - 大大提高生產力通過 vim-plug 安裝的插件大部分都是即裝即用的，但也包括小部分需要在安裝完成後進行一定的配置才能舒適地使用。 YouCompleteMe - 最強補全神器YouCompleteMe 是谷歌程序員 Valloric 開發的一款智能補全插件。在 YouCompleteMe 出來之前，大部分補全插件都是基於 tag 分析，也就是從當前文件以及其他 buffer 中的文件文本中匹配類似字符串進行補全，說白了就是靠猜。而 YouCompleteMe 是真正支持程序語義分析的補全，能夠理解程序語言進行補全，準確率大大提高，並且體驗也提升了很多。 盜用 YouCompleteMe 官方倉庫上的一張效果圖 雖然 YouCompleteMe 效果看起來很炫酷，但它也被稱爲“最難安裝的插件”。它的底層是用 C++ 寫成的，爲了能作爲 Vim 的插件，外層又用 Python 做了封裝，因此它也是最複雜的插件。Plug 'Valloric/YouCompleteMe', { 'do': './install.py --clang-completer' } 命令要求 vim-plug 將 YouCompleteMe 插件下載下來後自動編譯，但如果你的終端上缺少編譯的依賴會導致編譯失敗，此時我們需要手動進行編譯。 在 Linux 下進行安裝會相對比較容易，在編譯之前你需要但不限於以下工具： cmake automake python3-dev（python2 或 python3） 之後運行 cd ~/.vim/plugged/YouCompleteMe/ 進入 YouCompleteMe 的安裝目錄，運行 ./install.py --clang-completer 進行安裝，如果不需要 C 語言補全支持的話無需 --clang-completer 選項。安裝程序會自動下載 libclang 依賴，等待安裝完成即可。Windows 的安裝過程大部分相似，可參考 YouCompleteMe 的官方倉庫文檔。 再次使用 Vim 打開一個 Python 或 cpp 文件應該就能自動補全了。但接下來你會發現 YouCompleteMe 彈出的補全菜單裏只會包括前面你輸入過的關鍵字，並沒有進行語義識別，那不是和自帶的 omni 補全沒區別！還浪費我這麼長時間安裝！其實之前我也是這麼想的，直到有一天我看到這篇文章，我才發現原來我一直用的是半殘的 YouCompleteMe，根本沒發揮出它真正的實力。通過如下配置就能使 YouCompleteMe 的補全策略更貼近於常見的 IDE。 1set completeopt=longest,menu \" YCM 的提示方式，previews 會顯示具體預覽窗口，menu 不提示2\" let g:ycm_add_preview_to_completeopt = 03let g:ycm_collect_identifiers_from_tags_files=1 \" 使用 ctags 生成的 tags 文件4let g:ycm_min_num_of_chars_for_completion=2 \" 從第 2 個鍵入字符就開始羅列匹配項5let g:ycm_seed_identifiers_with_syntax=1 \" 語法關鍵字補全6let g:ycm_cache_omnifunc=1 \" 禁止緩存匹配項,每次都重新生成匹配項7let g:ycm_complete_in_comments = 1 \" 在註釋輸入中也能補全8let g:ycm_complete_in_strings = 1 \" 在字符串輸入中也能補全9let g:ycm_collect_identifiers_from_comments_and_strings = 1 \" 註釋和字符串中的文字也會被收入補全10let g:ycm_python_binary_path = '/usr/bin/python' \" set default python binary11let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py' \" set global ycm extra config path12let g:ycm_confirm_extra_conf = 0 \" confirm for config file13let g:ycm_use_ultisnips_completer=1 \" 查詢 ultisnips 提供的代碼模板補全14let g:ycm_key_invoke_completion = '&lt;c-z&gt;' \" 手動觸發補全的按鍵15\" 使 YCM 能在輸入兩個字母的時候自動基於語義補全16let g:ycm_semantic_triggers = {17 \\ 'c,cpp,python,java,go,erlang,perl': ['re!\\w{2}'],18 \\ 'cs,lua,javascript': ['re!\\w{2}'],19 \\ }20nnoremap &lt;leader&gt;d :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt; \" goto definition21autocmd InsertLeave * if pumvisible() == 0|pclose|endif \" 離開插入模式後自動關閉預覽窗口22autocmd VimEnter * EchoDocEnable ALE - 第二好的異步語法檢查工具ALE 是一款非常強大的異步語法檢查工具。在 Vim 支持異步之前，最好的語法檢查工具是 Syntastic，但由於它非異步的工作方式，導致語法檢查會阻塞主線程，使用體驗比較差。在新版 Vim 中，都會推薦 ALE 或其他支持異步的語法檢查工具。事實上 ALE 並不僅僅是一款語法檢查工具，它是包括了語法檢查、代碼風格格式化、自動補全功能的工具集。 ALE 安裝完成後，隨意打開一個代碼文件。如果語法存在錯誤，那麼在窗口的最左側會顯示一列符號，包括 ‘&gt;&gt;’ 或 ‘—‘。將光標移至有標記的行，在最下方的 statusline 中會顯示錯誤的具體信息。 1\" let g:ale_set_loclist = 0 \" show the lint as a dot on left of a line2\" let g:ale_set_quickfix = 1 \" show the lint in quickfix list3\" let g:ale_open_list = 1 \" show quickfix window to show error message4\" let g:ale_keep_list_window_open = 1 \" keep quickfix window show whether errors exist5\" let g:ale_sign_column_always = 1 \" 保持左側邊欄始終可見6nmap &lt;silent&gt; &lt;C-k&gt; &lt;Plug&gt;(ale_previous_wrap)7nmap &lt;silent&gt; &lt;C-j&gt; &lt;Plug&gt;(ale_next_wrap)8\" Check Python files with flake8 and pylint.9\" let b:ale_linters = ['flake8', 'pylint']10\" set fixers for different file types11let b:ale_fixers = {12 \\ 'python': ['isort', 'autopep8'],13 \\ 'cpp': ['clang-format'],14 \\ 'markdown': ['prettier']}15\" let g:ale_linters_explicit = 116let g:ale_completion_delay = 500 \" 補全的延遲17let g:ale_echo_delay = 20 \" 回顯的延遲18let g:ale_lint_delay = 500 \" 停止輸入後更新 lint 標記的延遲19let g:ale_echo_msg_format = '[%linter%] &lt;%code&gt; %%s' \" 自定義 lint 輸出格式20let g:ale_lint_on_text_changed = 'normal' \" 當文字在 NORMAL 模式下發生更改的時候更新 lint，防止 YCM 頻繁刷新21let g:ale_lint_on_insert_leave = 1 \" 離開 INSERT 模式時更新 lint 將錯誤信息表示在左側只是一種方式，你也可以通過反註釋前 4 行，利用 Vim 自帶的 quickfix 窗口顯示錯誤信息。雖然通過這種方式你能夠更清晰的瞭解各個錯誤的具體信息，但需要佔用一部分寶貴的屏幕空間。 11 至 14 行設置了 ALE 的默認格式化工具，ALE 本身並不對代碼進行格式化，而是針對不同文件類型調用合適的格式化工具進行處理（ALE 支持的格式化工具列表可參照官方倉庫）。其中 isort、autopep8、prettier 都是 Python 編寫的命令行工具，clang-format 是 clang 編譯器帶的 C++ 格式化工具。 20、21 行是針對 YCM 做的額外配置，據悉可以解決 YCM 補全菜單頻繁刷新的問題。","link":"/2018/08/12/Vim-%E4%B8%80%E6%AC%BE%E8%AE%A9%E6%88%91%E7%9B%B8%E8%A7%81%E6%81%A8%E6%99%9A%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"},{"title":"使用 Emacs 与 Org mode 进行 GTD 管理","text":"在接触 Emacs 以前，我的时间管理方式主要是利用清单软件建立待办事项，辅以纸笔随手 记录当前的临时任务。但这种方式最大的弊端是不能分项目进行记录，所有事项都堆在一起。 另外，完成的事项也不方便归档整理。早就听说了 Emacs 以及 Org-mode 的强大，也觊觎 网上大神用 Org-mode 做日程管理很久了，因此在此设计一个自己的 GTD 工作流。 基本想法 从空间尺度上，不同项目隶属于不同的 Org 文件，而不同的 Org 文件加入到不同的 agenda 中，实现基于项目的管理方式。 从任务类型上，任务分为一次性任务以及周期性任务（Habit）。 从时间尺度上，任务可以按照需要投入的时间（Effort estimate），可以分为年任务、 月任务、周任务、日任务、小时任务等。如果任务的 Effort 太大，我们也就无法很好 地把握任务的进度以及投入，此时我们也就需要将其拆分为更小的任务。 整体流程 参照 皮波迪 的博客 以 Emacs Org mode 为核心的任务管理方案，设计适合自己的工作流。 如以下流程图所示，可将任务分为四个阶段。 首先一旦出现一个任务，就将其加入到 收集箱 中。这些任务代表出现的灵感或者想法， 但暂时还未想好在何时完成。 当收集箱中的任务想要被完成时，就为其加上 schedule (C-c C-s) 和 deadline (C-c C-d) 时间戳，进入 跟踪任务列表 。这些任务代表已经做好计划的任务，同时也可为任务 设定预计投入时间 (C-c C-x e)。 当有跟踪列表中的任务到达计划的执行时间时，执行 clock in (C-c C-x C-i)，同时任 务进入 当前任务 状态。 当任务完成时，执行 clock out (C-c C-x C-o)，任务进入 已完成任务 状态。 任务拆分 对于耗时较长的非周期任务，需要拆分成更小的任务来进行处理。大型的任务可以作为单独 的项目放在单独的 Org 文件中，并使用如下的代码为该项目设定一个单独的 agenda。 1 (setq org-agenda-custom-commands 2 '((\"n\" \"Agenda and all TODOs\" 3 ((agenda \"\" nil) 4 (alltodo \"\" nil)) 5 nil) 6 (\"pc\" \"Learn Org\" agenda \"\" 7 ((org-agenda-files 8 '(\"~/Orgs/learn-org.org\")) 9 (org-agenda-overriding-header \"Agenda for learning org mode\")) 10 (\"~/export/learn-org.html\")))) 其中， \"pc\" 为打开该 agenda 的快捷键， \"Learn Org\" 为项目的名称， \"~/Orgs/learn-org.org\" 为绑定的 Org 文件， \"Agenda for learning org mode\" 为 agenda 上方显示的标题， \"~/export/learn-org.html\" 为导出 agenda 时的路径。设定完 成后，通过快捷键 &lt;C-c a p c&gt; 即可呼出自定义 agenda。 为任务添加更多属性 标签是一种非线性的组织方式，Org mode 中的每一个 headline 都支持标签。在 headline 使用快捷键 &lt;C-c C-c&gt; 即可管理标签。标签会根据层级结构自动继承，因此父标题的标签 会自动继承到子标题。 另外，Org mode 还支持键值对。该部分等以后研究明白再做记录。 查看任务概览 Org mode 中有一种叫做列视图的模式，可以将 headline 的属性以列视图的模式显示出来。 列视图可以在 org-mode 或 agenda-mode 中使用，快捷键为 &lt;C-c C-x C-c&gt; 。开启后每个 任务会以表格的样式显示。 将光标放置在任意一个处于列模式的行上，可用 &lt;q&gt; 退出列模式。列模式中显示的信息可 以自定义，定义方法如下，其中 Effort 后面的 {:} 是要将所有子任务的 Effort 求和。 1 (setq org-columns-default-format \"%50ITEM(Task) 2 %3PRIORITY(Priority) %5TODO(Status) %8EFFORT(Effort){:} 3 %20SCHEDULED %20DEADLINE\") 任务完成 1 (setq 2 ;; 当标签转换为 done 时自动记录 close 时间 3 ;; 当标签转换为 done 时自动 clock out 4 org-log-done '(time . org-clock-out)) 任务回顾 &lt;C-c C-x C-d&gt; 查看各个任务的耗时与总和。","link":"/2020/03/06/%E4%BD%BF%E7%94%A8-Emacs-%E4%B8%8E-Org-mode-%E8%BF%9B%E8%A1%8C-GTD-%E7%AE%A1%E7%90%86/"},{"title":"使用 Emacs 与 mu4e 管理邮件","text":"在 Linux 下面其实有很多可以使用的邮件客户端，如 KDE 项目中的 Kmail、Gnome 项目 中的 Evolution 和 Mozilla 家族的 Thunderbird。这些客户端都只是简单地试用过，正 好最近将开发编辑器和写作环境从 Neovim 迁到了 Emacs。作为一个操作系统，不能管理 邮件怎么说的过去。可以利用 Emacs 的界面进行邮件管理，可以用 Org-mode 进行邮件写 作，甚至可以用 elisp 写一些插件，岂不美哉？趁最近放假赶紧折腾一下。 邮件同步 查看其他的博客，发现同步博客最常用的协议是 IMAP。Linux 下支持 IMAP 协议并且下载 下来的目录结构是 MailDir 结构的工具主要有两个，offlineimap 和 isync。 offlineimap 配置 offlineimap 是一个由 Python 写成的 IMAP 同步工具，主要的缺点是依赖 Python2 的库， 并且同步速度不如 isync，因此仅作记录。 安装 在 Archlinux 中，可以直接从 community 仓库中安装。 1 sudo pacman -S offlineimap 配置 安装完成，要进行配置，需要创建一个 ~/.offlineimaprc 文件进行配置。详细的配置过程如下： 1 [general] 2 # 此处列出所有要同步的账户名，与下方 [Account] 节中的名字要一致 3 accounts = Netease, QQ 4 maxsyncaccounts = 3 5 6 [Account Netease] 7 # 绑定仓库，与下方的 [Repository] 节中的名字一致 8 localrepository = NeteaseLocal 9 remoterepository = NeteaseRemote 10 11 [Repository NeteaseLocal] 12 type = Maildir 13 # 指定本地保存的路径 14 localfolders = /data/cycoe/Documents/mail/myneteasemail@163.com 15 16 [Repository NeteaseRemote] 17 type = IMAP 18 # 远程 imap 主机 19 remotehost = imap.163.com 20 # 邮箱地址 21 remoteuser = myneteasemail@163.com 22 # 邮箱密码 23 remotepass = ******** 24 ssl = yes 25 # *非常重要* 否则提示确实 CA 证书 26 sslcacertfile = /etc/ssl/certs/ca-certificates.crt 27 maxconnections = 1 28 # 是否从服务器上删除邮件 29 realdelete = no 30 31 [Account QQ] 32 localrepository = QQLocal 33 remoterepository = QQRemote 34 35 [Repository QQLocal] 36 type = Maildir 37 localfolders = /data/cycoe/Documents/mail/myqqmail@qq.com 38 39 [Repository QQRemote] 40 type = IMAP 41 remotehost = imap.qq.com 42 remoteuser = myqqmail@qq.com 43 remotepass = *********** 44 ssl = yes 45 sslcacertfile = /etc/ssl/certs/ca-certificates.crt 46 maxconnections = 1 47 realdelete = no 至此，通过 offlineimap -a Netease 就可以同步指定的账户。 isync 配置 isync 是一个由 C++ 写成的 IMAP 同步工具，经测试同步速度要比 offlineimap 更快，但 是同步出来的邮件数量比 offlineimap 更多不知道是怎么回事，目前主要使用这个。 安装 在 Archlinux 中，可以直接从 community 仓库中安装。 1 sudo pacman -S isync 配置 isync 的配置方式与 offlineimap 类似，将如下配置放在 '~/.mbsyncrc' 中，并运行 `mbsync Netease` 即可更新 Netease 频道，mbsync 以频道的概念管理多个邮箱，可以通 过类似以下多个配置实现多邮箱管理。 1 IMAPAccount Netease 2 # Address to connect to 3 Host imap.163.com 4 User myneteasemail@163.com 5 Pass ********** 6 # To store the password in an encrypted file use PassCmd instead of Pass 7 # PassCmd \"gpg2 -q --for-your-eyes-only --no-tty -d ~/.mailpass.gpg\" 8 # 9 # Use SSL 10 SSLType IMAPS 11 # The following line should work. If get certificate errors, uncomment the two following lines and read the \"Troubleshooting\" section. 12 CertificateFile /etc/ssl/certs/ca-certificates.crt 13 #CertificateFile ~/.cert/imap.gmail.com.pem 14 #CertificateFile ~/.cert/Equifax_Secure_CA.pem 15 16 IMAPStore Netease-remote 17 Account Netease 18 19 MaildirStore Netease-local 20 Subfolders Verbatim 21 # The trailing \"/\" is important 22 Path /data/cycoe/Documents/mail/myneteasemail@163.com/ 23 Inbox /data/cycoe/Documents/mail/myneteasemail@163.com/INBOX 24 25 Channel Netease 26 Master :Netease-remote: 27 Slave :Netease-local: 28 # Exclude everything under the internal [Gmail] folder, except the interesting folders 29 Patterns * ![myneteasemail@163.com]* \"[myneteasemail@163.com]/INBOX\" 30 # Or include everything 31 #Patterns * 32 # Automatically create missing mailboxes, both locally and on the server 33 Create Both 34 # Save the synchronization state files in the relevant directory 35 SyncState * 36 37 38 IMAPAccount QQ 39 # Address to connect to 40 Host imap.qq.com 41 User myqqmail@qq.com 42 Pass ********** 43 # To store the password in an encrypted file use PassCmd instead of Pass 44 # PassCmd \"gpg2 -q --for-your-eyes-only --no-tty -d ~/.mailpass.gpg\" 45 # 46 # Use SSL 47 SSLType IMAPS 48 # The following line should work. If get certificate errors, uncomment the two following lines and read the \"Troubleshooting\" section. 49 CertificateFile /etc/ssl/certs/ca-certificates.crt 50 #CertificateFile ~/.cert/imap.gmail.com.pem 51 #CertificateFile ~/.cert/Equifax_Secure_CA.pem 52 53 IMAPStore QQ-remote 54 Account QQ 55 56 MaildirStore QQ-local 57 Subfolders Verbatim 58 # The trailing \"/\" is important 59 Path /data/cycoe/Documents/mail/myqqmail@qq.com/ 60 Inbox /data/cycoe/Documents/mail/myqqmail@qq.com/INBOX 61 62 Channel QQ 63 Master :QQ-remote: 64 Slave :QQ-local: 65 # Exclude everything under the internal [Gmail] folder, except the interesting folders 66 Patterns * ![myqqmail@qq.com]* \"[myqqmail@qq.com]/INBOX\" 67 # Or include everything 68 #Patterns * 69 # Automatically create missing mailboxes, both locally and on the server 70 Create Both 71 # Save the synchronization state files in the relevant directory 72 SyncState * Unsafe login 使用第三方 IMAP 服务同步 163 邮箱时，会提示 Unsafe login 错误，可以通过 网易邮箱 设置 解决。 mu 邮件管理器 安装 1 # 克隆 mu 仓库 2 git clone git://github.com/djcb/mu.git 3 # 生成配置 4 ./autogen.sh 5 # 配置编译设置 6 ./configure 7 # 编译安装 8 make -j 4 &amp;&amp; sudo make install 配置 mu 1 # 初始化 mu 监测的邮箱文件夹 2 mu init -m /data/cycoe/Documents/mail/ 3 # 建立邮件索引 4 mu index mu4e 多账户设置 mu4e (mu for emacs) 是 mu 在 emacs 中实现的一个邮件管理模块。后端调用 mu 进行邮 件的检索和管理。在 ~/.config/emacs/lisp/ 目录下建立 init-mu4e.el 文件，并加入如 下配置。mu4e 目前原生支持的功能是 context（上下文切换），因此使用上下文切换来模 拟多账户管理。每次切换账户时，自动设置对应账户的变量。其中最重要的一处为 context 中的 match-fun 设置。该设置能够保证在同时删除或者归档不同 maildir 下的邮件时，邮 件能够被移动到对应的 maildir 中。 1 (setq mu4e-contexts 2 `( ,(make-mu4e-context 3 :name \"netease\" 4 :match-func (lambda (msg) 5 (when msg 6 (string-match-p \"myneteasemail@163.com\" (mu4e-message-field msg :maildir))))))) 完整配置如下： 1 ;; the exact path may different -- check it 2 (add-to-list 'load-path \"/usr/local/share/emacs/site-lisp/mu4e\") 3 4 ;; require the mu4e main package 5 (require 'mu4e) 6 ;; use smtpmail to sent mail 7 (require 'smtpmail) 8 ;; convert org content in mu4e to html 9 (require 'org-mime) 10 ;; use org-mode in mu4e-message-mode 11 (require 'org-mu4e) 12 13 ;; set default values about mu4e 14 (setq 15 ;; auto update maildir with isync and index it 16 mu4e-update-interval 300 17 ;; don't do a full cleanup check 18 mu4e-index-cleanup nil 19 ;; don't consider up-to-date dirs 20 mu4e-index-lazy-check t 21 ;; show images in message mode 22 mu4e-view-show-images t 23 ;; set the default download dir for attachment 24 mu4e-attachment-dir \"/data/cycoe/downloads\" 25 ;; prefer html view 26 mu4e-view-prefer-html t 27 ;; don't save message to sent messages, gmail/imap takes care of this 28 ;; (see the documentation for `mu4e-sent-messages-behavior' if you have 29 ;; additional non-gmail addresses and want assign them different 30 ;; behavior.) 31 mu4e-sent-messages-behavior 'delete 32 ) 33 34 ;; set default values for sending mails 35 (setq 36 ;; user agent when send mail 37 mail-user-agent 'mu4e-user-agent 38 ;; 设置邮件发送方法为 smtpmail 39 message-send-mail-function 'smtpmail-send-it 40 ;; 根据 from 邮件头使用正确的账户上下文发送 email. 41 message-sendmail-envelope-from 'header 42 ;; 设置邮箱认证加密方式 43 smtpmail-stream-type 'ssl 44 ;; don't keep message buffers around 45 message-kill-buffer-on-exit t 46 ) 47 48 ;; some information about me 49 (setq 50 user-full-name \"Cycoe Joo\" 51 ;; set a mail address list using when reply a message 52 mu4e-user-mail-address-list '(\"myneteasemail@163.com\" 53 \"myqqmail@qq.com\") 54 mu4e-compose-signature 55 (concat 56 \"Cycoe\\n\" 57 \"BLOG https://cycoe.cc\\n\") 58 ) 59 60 ;; 该函数基于当前所在的 maildir 来判定所账户上下文。 61 ;; (defun mu4e-message-maildir-matches (msg rx) 62 ;; (when rx 63 ;; (if (listp rx) 64 ;; ;; If rx is a list, try each one for a match 65 ;; (or (mu4e-message-maildir-matches msg (car rx)) 66 ;; (mu4e-message-maildir-matches msg (cdr rx))) 67 ;; ;; Not a list, check rx 68 ;; (string-match rx (mu4e-message-field msg :maildir))))) 69 70 ;; 设置 mu4e 上下文 71 (setq mu4e-contexts 72 `( ,(make-mu4e-context 73 :name \"Netease\" 74 :enter-func (lambda () 75 (mu4e-message \"Entering Netease context\") 76 ;; update index after switch context, otherwise the 77 ;; counting is not updated 78 (mu4e-update-index)) 79 :leave-func (lambda () (mu4e-message \"Leaving Netease context\")) 80 ;; we match based on the contact-fields of the message 81 :match-func (lambda (msg) 82 (when msg 83 (string-match-p \"myneteasemail@163.com\" (mu4e-message-field msg :maildir)))) 84 85 :vars '((user-mail-address . \"myneteasemail@163.com\") 86 (mu4e-sent-folder . \"/myneteasemail@163.com/Sent\") 87 (mu4e-drafts-folder . \"/myneteasemail@163.com/Drafts\") 88 (mu4e-trash-folder . \"/myneteasemail@163.com/Trash\") 89 (mu4e-refile-folder . \"/myneteasemail@163.com/Refile\") 90 (smtpmail-smtp-user . \"myneteasemail@163.com\") 91 (smtpmail-default-smtp-server . \"smtp.163.com\") 92 (smtpmail-smtp-server . \"smtp.163.com\") 93 (smtpmail-smtp-service . 994) 94 (mu4e-get-mail-command . \"mbsync Netease\") 95 (mu4e-maildir-shortcuts . ((\"/myneteasemail@163.com/INBOX\" . ?i) 96 (\"/myneteasemail@163.com/Sent\" . ?s) 97 (\"/myneteasemail@163.com/Refile\" . ?r) 98 (\"/myneteasemail@163.com/Trash\" . ?t) 99 (\"/myneteasemail@163.com/Drafts\" . ?d))) 100 (mu4e-bookmarks . ( (\"maildir:/myneteasemail@163.com/INBOX AND flag:unread AND NOT flag:trashed\" \"Unread messages\" ?u) 101 (\"maildir:/myneteasemail@163.com/INBOX AND date:today..now\" \"Today's messages\" ?t) 102 (\"maildir:/myneteasemail@163.com/INBOX AND date:7d..now\" \"Last 7 days\" ?w) 103 (\"maildir:/myneteasemail@163.com/INBOX AND date:1d..now\" \"Last 1 days\" ?o) 104 (\"maildir:/myneteasemail@163.com/INBOX\" \"Inbox\" ?i) 105 (\"maildir:/myneteasemail@163.com/Sent\" \"Sent\" ?s) 106 (\"maildir:/myneteasemail@163.com/Refile\" \"Refile\" ?r) 107 (\"maildir:/myneteasemail@163.com/Trash\" \"Trash\" ?t) 108 (\"maildir:/myneteasemail@163.com/Drafts\" \"Drafts\" ?d) 109 (\"maildir:/myneteasemail@163.com/INBOX AND mime:image/*\" \"Messages with images\" ?p))) 110 )) 111 112 ,(make-mu4e-context 113 :name \"QQ\" 114 :enter-func (lambda () 115 (mu4e-message \"Switch to the QQ context\") 116 (mu4e-update-index)) 117 :match-func (lambda (msg) 118 (when msg 119 (string-match-p \"myqqmail@qq.com\" (mu4e-message-field msg :maildir)))) 120 121 :vars '((user-mail-address . \"myqqmail@qq.com\") 122 (mu4e-sent-folder . \"/myqqmail@qq.com/Sent\") 123 (mu4e-drafts-folder . \"/myqqmail@qq.com/Drafts\") 124 (mu4e-trash-folder . \"/myqqmail@qq.com/Trash\") 125 (mu4e-refile-folder . \"/myqqmail@qq.com/Refile\") 126 (smtpmail-smtp-user . \"myqqmail@qq.com\") 127 (smtpmail-default-smtp-server . \"smtp.qq.com\") 128 (smtpmail-smtp-server . \"smtp.qq.com\") 129 (smtpmail-smtp-service . 465) 130 (mu4e-get-mail-command . \"mbsync QQ\") 131 (mu4e-maildir-shortcuts . ((\"/myqqmail@qq.com/INBOX\" . ?i) 132 (\"/myqqmail@qq.com/Sent\" . ?s) 133 (\"/myqqmail@qq.com/Refile\" . ?r) 134 (\"/myqqmail@qq.com/Trash\" . ?t) 135 (\"/myqqmail@qq.com/Drafts\" . ?d))) 136 (mu4e-bookmarks . ( (\"maildir:/myqqmail@qq.com/INBOX AND flag:unread AND NOT flag:trashed\" \"Unread messages\" ?u) 137 (\"maildir:/myqqmail@qq.com/INBOX AND date:today..now\" \"Today's messages\" ?t) 138 (\"maildir:/myqqmail@qq.com/INBOX AND date:7d..now\" \"Last 7 days\" ?w) 139 (\"maildir:/myqqmail@qq.com/INBOX AND date:1d..now\" \"Last 1 days\" ?o) 140 (\"maildir:/myqqmail@qq.com/INBOX\" \"Inbox\" ?i) 141 (\"maildir:/myqqmail@qq.com/Sent\" \"Sent\" ?s) 142 (\"maildir:/myqqmail@qq.com/Refile\" \"Refile\" ?r) 143 (\"maildir:/myqqmail@qq.com/Trash\" \"Trash\" ?t) 144 (\"maildir:/myqqmail@qq.com/Drafts\" \"Drafts\" ?d) 145 (\"maildir:/myqqmail@qq.com/INBOX AND mime:image/*\" \"Messages with images\" ?p))) 146 )))) 147 148 ;; start with the first (default) context; 149 ;; default is to ask-if-none (ask when there's no context yet, and none match) 150 (setq mu4e-context-policy 'pick-first) 151 152 (provide 'init-mu4e) 配置 smtp 发送邮件 emcas 可以使用 smtpmail 发送邮件，会自动读取 ~/.authinfo 文件中的账户和密码，因 此需要在该文件中配置 smtp 相关信息。 1 machine smtp.163.com login myneteasemail@163.com password xxxxxxxxxx 2 machine smtp.qq.com login myqqmail@qq.com password xxxxxxxxxx 使用 Org mode 编辑新邮件 使用 Emacs 管理邮件的一大优势就是可以借助强大的 Org-mode 来写邮件，并自动导出为 HTML 邮件。生成的邮件为 multipart 的邮件，也就是说同时有 plain 部分和 HTML 部分 可选。但在实际使用中，=(org-mime-htmlize)= 确实能够将邮件转化为 multipart 邮件， 但是不知道为什么最后发送出去的邮件只有一个部分。要实现该功能需要在 ~/.config/emacs/lisp/init-mu4e.el 中加入如下配置。 1 ;; convert org content in mu4e to html and send 2 (require 'org-mime) 3 ;; convert org content in mu4e to html and send 4 (require 'org-mu4e) 5 6 ;; auto enable the org-mu4e-compose-org-mode when enter the mu4e-compose-mode 7 (add-hook 'mu4e-compose-mode-hook 8 (defun do-compose-stuff () 9 (org-mu4e-compose-org-mode))) 10 11 (defun htmlize-and-send () 12 \"When in an org-mu4e-compose-org-mode message, htmlize and send it.\" 13 (interactive) 14 (when (member 'org~mu4e-mime-switch-headers-or-body post-command-hook) 15 (org-mime-htmlize) 16 (message-send-and-exit))) 17 18 (add-hook 'org-ctrl-c-ctrl-c-hook 'htmlize-and-send t) 将邮件加入 TODO 列表中 如果想要将某封邮件加入代办事项用于记录，可以将如下代码加入 init-mu4e.el 中 1 ;; store link to message if in header view, not to header query 2 (setq org-mu4e-link-query-in-headers-mode nil) 3 ;; use org-capture to add a new todo 4 (setq org-capture-templates 5 '((\"t\" \"todo\" entry (file+headline \"/data/cycoe/Documents/Orgs/TODO.org\" \"Tasks\") 6 \"* TODO [#A] %?\\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \\\"+0d\\\"))\\n%a\\n\"))) 至此，在 mu4e 的 header view 或者是 message view 中，输入 org-capture 即可自动将 邮件作为代办事项加入到 /data/cycoe/Documents/Orgs/TODO.org 中。","link":"/2020/02/28/%E4%BD%BF%E7%94%A8-Emacs-%E4%B8%8E-mu4e-%E7%AE%A1%E7%90%86%E9%82%AE%E4%BB%B6/"},{"title":"利用 Python 完成自动化群发邮件","text":"最近我们 Campus TMC 要过九周年生日，因此要给以前的老会员发邮件邀请函。本来打算一 个一个手动发，后来一看有将近 100 个。本着 Coding for everything 的准则，尝试用 Python 来解决。 Python 中已经实现了 stmp 的相关接口在 smtplib 模块中，邮件结构相关的接口在 email 模块中。 生成通讯录 在批量发送邮件之前，一定要有一份结构化的通讯录，不管是用 list 也好，用 dict 存储也好。此处，我是使用 xlrd 模块从 Excel 表格中读取数据，并将其存储在 dict 中。对于邮件来说，收件人的名字可能会出现重名，但邮件地址应该是唯一的，因此选用邮件地址作为字典的键。 1 def read_contacts(contact_file): 2 \"\"\" 讀取聯繫人 3 \"\"\" 4 contacts = {} 5 6 data = xlrd.open_workbook(contact_file) 7 sheet = data.sheet_by_index(0) 8 9 for row in range(sheet.nrows): 10 email = sheet.cell(row, 6).value.strip() 11 if email == '': 12 continue 13 14 if email.find('/'): 15 emails = email.split('/') 16 for email in emails: 17 contacts[email] = {} 18 contacts[email][ZH] = sheet.cell(row, 3).value.strip() 19 contacts[email][EN] = sheet.cell(row, 1).value.strip() 20 else: 21 contacts[email] = {} 22 contacts[email][ZH] = sheet.cell(row, 3).value.strip() 23 contacts[email][EN] = sheet.cell(row, 1).value.strip() 24 25 del sheet 26 del data 27 return contacts 生成的字典结构为 {key_address: {'zh': value_zh_name, 'en': value_en_name}, ...}。 定义邮件内容 第一步是生成邮件对象，代码示例如下： 1 from email.header import Header 2 from email.mime.multipart import MIMEMultipart 3 from email.mime.image import MIMEImage 4 from email.utils import formataddr 5 6 # 定义邮件的主题与内容 7 SUBJECT = 'My best friend {:name}, I sincerely invite you to participate our anniversary activity' 8 # 邮件内容支持 HTML 9 CONTENT = \"\"\" 10 My best friend {:name}, 11 &lt;p&gt;I sincerely invite you to participate our anniversary activity.&lt;/p&gt; 12 &lt;p&gt;Here is our post.&lt;/p&gt; 13 &lt;div&gt; 14 &lt;div align=\"center\"&gt;&lt;img src=\"cid:post\"&gt;&lt;/div&gt; 15 \"\"\" 16 17 # 发件人的信息 18 SENDER_NAME = 'Cycoe' 19 SENDER_ADDR = 'cycoe@163.com' 20 21 contacts = read_contacts(PATH_OF_CONTACTS) 22 23 for email in contacts.keys(): 24 name = contacts[email][EN] 25 # 生成邮件对象 26 message = MIMEMultipart() 27 # 设置主题、发信人、收信人 28 message['Subject'] = Header(SUBJECT.format(name)) 29 message['From'] = formataddr((SENDER_NAME, SENDER_ADDR)) 30 message['To'] = formataddr((name, email)) 31 # 内容有点特殊，对于 MIMEMultipart 类型的邮件， 32 # 内容是作为 attachment 添加到 message 中 33 content = MIMEText(CONTENT.format(name), _subtype='html', _charset='utf-8') 34 message.attach(content) 35 36 # 加载附件，POST_PATH 是附件在本机上的路径 37 with open(POST_PATH, 'rb') as fp: 38 # 此处的 filename 参数是附件在邮件中显示的名字 39 post = MIMEImage(fp.read(), _subtype='png', filename='post.png') 40 post.add_header('Content-Disposition', 'attachment', filename='post.png') 41 # 该文件头非常重要，Content-ID 一定要对应上面内容中的 cid 42 # 这样图片就会被引用到正文中 43 post.add_header('Content-ID', '&lt;post&gt;') 44 message.attach(post) 发送邮件 Python 中使用 smtplib 来处理 smtp 协议，示例代码如下： 1 import smtplib 2 3 HOST = 'smtp.163.com' 4 PORT = 25 5 SENDER_ADDR = 'cycoe@163.com' 6 PASSWORD = '*********' 7 8 9 def send_mail(message, email): 10 server = smtplib.SMTP() 11 # 连接服务器 12 try: 13 server.connect(HOST, PORT) 14 except smtplib.SMTPConnectError as e: 15 print(e) 16 return False 17 18 # 登陆 19 try: 20 server.login(SENDER, PASSWORD) 21 except smtplib.SMTPAuthenticationError as e: 22 print(e) 23 return False 24 25 success = False 26 # 发送邮件 27 try: 28 server.sendmail(SENDER_ADDR, [email], msg.as_string()) 29 print('郵件發送成功！') 30 success = True 31 except smtplib.SMTPException as e: 32 print('郵件發送失敗！') 33 finally: 34 del message 35 server.quit() 36 37 return success 此处有一点需要注意，不要 connect 一次服务器循环发多封邮件，而是每次 connect 发送一封邮件就 quit 重新 connect。否则会被网易服务器当作垃圾邮件而连接错误。","link":"/2020/03/30/%E5%88%A9%E7%94%A8-Python-%E5%AE%8C%E6%88%90%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BE%A4%E5%8F%91%E9%82%AE%E4%BB%B6/"},{"title":"利用 python 實現自動搶報告","text":"上了研究生才知道北化的研究生每年需要聽 15 個報告，而且最重要的是這些報告都是算分數的，而且更重要的是你的分數是和最後的獎學金評定掛鉤的。這也就決定了大家爲了那麼點報告分數擠教務網都擠破了頭（北化的服務器大家都懂），雖然場面不如開學搶課那麼火爆，卻需要長時間掛着教務網瘋狂刷新，爲了交換個講座也需要大半夜起來，生怕被別人截胡。爲了解放生產力，同時熟悉爬蟲技術、神經網絡技術、裝飾器等進階內容，寫了這個爬蟲來練練手。 聲明該爬蟲是本人(cycoe)練習 python 編程技巧和神經網絡所編寫，使用造成的任何責任與本人無關 項目地址 問題分解想要順利的拿到搶講座的 session，需要如下的步驟： 處理登陸問題，包括處理驗證碼、頁面表單和 cookies 獲取報告列表 獲取搶報告的地址 提交表單數據 框架設計好的框架應具有良好的可維護性和擴展性，目前正朝着這個方向努力 採用交互式的命令行設計，分離 login, robSpeech 等方法 將 login, robSpeech, robClass 等方法封裝成 Robber 對象 將底層的 requests 封裝成 Spider 對象 逐步解決 通過 firefox 或 chrome 的 debug 模式可以查看在訪問網頁時的 request 和 response。仿照瀏覽器在訪問教務網時提交的 headers 構造如下字典 1class Spider(object):2 @staticmethod3 def formatHeaders(referer=None, contentLength=None, originHost=None):4 \"\"\"5 封裝請求的 headers67 :param referer: 跳轉標記，告訴 web 服務器自己是從哪個頁面跳轉過來的8 :param contentLength: 作用未知9 :param originHost: 原始主機地址10 :returns: headers 字典11 \"\"\"12 headers = {13 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',14 'Accept-Encoding': 'gzip, deflate',15 'Accept-Language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7',16 'Cache-Control': 'max-age=0',17 'Connection': 'keep-alive',18 'Content-Type': 'application/x-www-form-urlencoded',19 'DNT': '1',20 'Host': 'graduate.buct.edu.cn:8080',21 'Upgrade-Insecure-Requests': '1',22 'User-Agent': 'Mozilla/5.0 (X11;Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36',23 'Referer': referer,24 'Content-Length': contentLength,25 'Origin': originHost,26 } 封裝 request 請求需要的 prepareBody 對象，response = session.send(prepareBody)，response 就是我們拿到的服務器的響應對象，可通過 response.text 得到網頁內容，response.status_code 得到狀態碼，response.url 得到響應的地址。 1def prepare(self,2 referer=None,3 originHost=None,4 method='GET',5 url=None,6 data=None,7 params=None):8 \"\"\"9 生成用於請求的 prepare1011 :param referer: 跳轉標記，告訴 web 服務器自己是從哪個頁面跳轉過來的12 :param originHost: 原始主機地址13 :param method: 請求方法 in ['GET', 'POST']14 :param url: 請求的 url 地址15 :param data: 封裝的 post 數據16 :param params: post 參數17 :return: prepare 對象18 \"\"\"19 headers = self.formatHeaders(referer=referer, originHost=originHost)20 req = Request(method, url, headers=headers, data=data, params=params)21 return self.session.prepare_request(req)2223prepareBody = prepare(referer=None,24 originHost=None,25 method='GET',26 url=UrlBean.jwglLoginUrl,27 data=None,28 params=None)29response = session.send(prepareBody) 請求登錄網址，提交表單數據。根據 response 返回的響應體內容判斷是否登陸成功 1def getVIEWSTATE(self):2 \"\"\"3 正則獲取頁面的 __VIEWSTATE45 :returns: 頁面的 __VIEWSTATE6 \"\"\"7 VIEWSTATE = re.findall('&lt;.*name=\"__VIEWSTATE\".*value=\"(.*)?\".*/&gt;', self.response.text)8 if len(VIEWSTATE) &gt; 0:9 return VIEWSTATE10 else:11 return None1213def getEVENTVALIDATION(self):14 \"\"\"15 正則獲取頁面的 __EVENTVALIDATION1617 :returns: 頁面的 __EVENTVALIDATION18 \"\"\"19 EVENTVALIDATION = re.findall('&lt;.*name=\"__EVENTVALIDATION\".*value=\"(.*)?\".*/&gt;', self.response.text)20 if len(EVENTVALIDATION) &gt; 0:21 return EVENTVALIDATION22 else:23 return None2425def login(self):26 \"\"\"27 登錄教務網28 \"\"\"2930 # 在登錄前請求一次登錄頁面，獲取網頁的隱藏表單數據31 prepareBody = self.prepare(referer=None,32 originHost=None,33 method='GET',34 url=UrlBean.jwglLoginUrl,35 data=None,36 params=None)3738 # 登陸主循環39 while True:40 self.response = self.session.send(prepareBody)41 self.VIEWSTATE = self.getVIEWSTATE()42 self.EVENTVALIDATION = self.getEVENTVALIDATION()43 if self.VIEWSTATE is not None and self.EVENTVALIDATION is not None:44 break45 Logger.log(\"Retrying fetching login page viewState...\", level=Logger.warning)4647 reInput = True # 是否需要重新輸入用戶名和密碼48 while True:49 # 輸入用戶名和密碼50 if reInput:51 if Config.checkUserFile():52 Config.readUserInfo()53 else:54 Config.userName = input(\"&gt; UserName: \")55 Config.password = input(\"&gt; Password: \")56 reInput = False5758 prepareBody = self.prepare(referer=UrlBean.jwglLoginUrl,59 originHost=None,60 method='GET',61 url=UrlBean.verifyCodeUrl,62 data=None,63 params=None)6465 while True:66 codeImg = self.session.send(prepareBody) # 獲取驗證碼圖片67 if codeImg.status_code == 200:68 break69 else:70 Logger.log(\"retrying fetching vertify code...\", level=Logger.warning)7172 with open('check.gif', 'wb') as fr: # 保存驗證碼圖片73 for chunk in codeImg:74 fr.write(chunk)7576 print_vertify_code()77 verCode = input(\"input verify code:\")78 # verCode = self.classifier.recognizer(\"check.gif\") # 識別驗證碼7980 # 構造登陸表單81 postData = {82 '__VIEWSTATE': self.VIEWSTATE,83 '__EVENTVALIDATION': self.EVENTVALIDATION,84 '_ctl0:txtusername': Config.userName,85 '_ctl0:txtpassword': Config.password,86 '_ctl0:txtyzm': verCode,87 '_ctl0:ImageButton1.x': '43',88 '_ctl0:ImageButton1.y': '21',89 }90 prepareBody = self.prepare(referer=UrlBean.jwglLoginUrl,91 originHost=UrlBean.jwglOriginUrl,92 method='POST',93 url=UrlBean.jwglLoginUrl,94 data=postData,95 params=None)9697 # 獲取登陸 response98 while True:99 self.response = self.session.send(prepareBody)100 if self.response.status_code == 200:101 break102103 # 根據返回的 html 判斷是否登錄成功104 if re.search('用戶名不存在', self.response.text):105 Logger.log('No such a user!', ['Cleaning password file'], level=Logger.error)106 print(OutputFormater.table([['No such a user!'], ['Cleaning password file']], padding=2))107 Config.cleanUserInfo()108 reInput = True109110 elif re.search('密碼錯誤', self.response.text):111 Logger.log('Wrong password!', ['Cleaning password file'], level=Logger.error)112 print(OutputFormater.table([['Wrong password!'], ['Cleaning password file']], padding=2))113 Config.cleanUserInfo()114 reInput = True115116 elif re.search('請輸入驗證碼', self.response.text):117 Logger.log('Please input vertify code!', ['Retrying...'], level=Logger.error)118 print(OutputFormater.table([['Please input vertify code!'], ['Retrying...']], padding=2))119120 elif re.search('驗證碼錯誤', self.response.text):121 Logger.log('Wrong vertify code!', ['Retrying...'], level=Logger.error)122 print(OutputFormater.table([['Wrong vertify code!'], ['Retrying...']], padding=2))123124 else:125 Logger.log('Login successfully!', ['UserName: ' + Config.userName, 'Password: ' + Config.password], level=Logger.warning)126 print(OutputFormater.table([['Login successfully!']], padding=2))127 Config.dumpUserInfo()128 break 拿到已登陸的 session 後，搶課和搶報告都是非常方便的，只要按照瀏覽器提交的數據構造 headers 和表單數據後就可以獲得正常的 response 暗坑總結 剛開始抓到的網頁內容中文都是亂碼，後來 google 解決，發現是 python 的編碼和 asp 框架的編碼問題造成的，python 中的編碼問題真的是讓人頭大 由於網站的防爬蟲設計，會在 html 源碼中插入很多隱藏的表單數據，如此處的 __VIEWSTATE 和 __EVENTVALIDATION，這兩個是非常重要的參數。否則無法成功登陸 兩次訪問之間要有一定的時間間隔，如此處用了一個隨機函數的閉包來獲得隨機時間的間隔 使用裝飾器解決了在訪問搶課網頁前判斷登錄的問題 接下來將循環封裝成函數，加入最大循環次數和超時 完善邊界檢查和異常處理","link":"/2017/10/28/%E5%88%A9%E7%94%A8python%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8A%A2%E6%8A%A5%E5%91%8A/"},{"title":"基於Jekyll引擎的博客服務器搭建","text":"Transform your plain text into static websites and blogs. 爲什麼要搭建自己的博客服務器之前我們已經利用 GitHub Pages 和 Jekyll 搭建了靜態博客並且託管在了 github.io 上，並且擁有了不錯的頁面效果以及可用性。那我們爲什麼還要搭建自己的博客服務器呢？因爲 GitHub 的服務器在美國，訪問體驗並不順暢；並且在我們 Push 了項目之後，往往要等待一定時間頁面內容纔會刷新。爲了更好的體驗效果，我們將基於樹莓派搭建自己的博客服務器。樹莓派爲 3B+，系統爲 Archlinuxarm-rpi-2 環境搭建安裝 Ruby依次運行下面的命令安裝最新的 Ruby 運行環境：1$ sudo pacman -S ruby2$ ruby --version3ruby 2.4.0p0 (2016-12-24 revision 57164) [armv7l-linux-eabihf]4$ gem --version52.6.8出現上面的提示說明 Ruby 安裝成功，gem 可以看做是 Ruby 插件的安裝器，一般安裝 Ruby 後自帶。 注意：Archlinux 用普通用戶安裝 Ruby 後會遇到運行 Gem 插件提示找不到命令的情況，原因是 Ruby 未自動設置環境變量。解決方法： bash打開 ~/.bashrc 文件，加入以下命令：1export PATH=$PATH:~/.gem/ruby/2.4.0/bin/ fish打開 ~/.config/fish/config.fish 文件（沒有則新建），加入以下命令：1set -x PATH {$PATH} ~/.gem/ruby/2.4.0/bin 安裝 Jekyll Jekyll is a simple, blog-aware, static site generator for personal, project, or organization sites.Written in Ruby by Tom Preston-Werner, GitHub’s co-founder, it is distributed under an open source license. 安裝 Jekyll 之前需要先安裝 bundle 管理器1gem install bundle 編輯 Gemfile，在文件中輸入以下內容1gem 'github-pages', group: :jekyll_plugins 利用 bundle 安裝 Jekyll 渲染需要的所有包1bundle install 到此需要的依賴安裝完畢，若 fork 的其他人的 Jekyll 模板，則直接進入模板目錄下執行 bundle install。 運行 Jekll 若要在 _site 目錄下生成網站目錄，則運行 bundle exec jekyll build 若要運行可本機訪問的服務則運行 bundle exec jekyll server -w，默認本機地址 127.0.0.1:4000 若要局域網可訪問則需要加上 bundle exec jekyll server -w --host=0.0.0.0","link":"/2017/04/01/%E5%9F%BA%E4%BA%8EJekyll%E5%BC%95%E6%93%8E%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"title":"在SSD上使用Btrfs文件系統的相關優化","text":"優化掛載參數在 Linux 中掛載 SSD 上的 btrfs，可以採用各種參數進行優化：1#&lt;file system&gt;&lt;mount point&gt;&lt;type&gt;&lt;options&gt;&lt;dump&gt;&lt;pass&gt;2UUID=&lt;略&gt;/ btrfs defaults,ssd,discard,noatime,compress=lzo,subvol=@ ssdbtrfs 文件系統有對 SSD 進行優化，在掛載參數中加入 ssd 即可。該參數不會自動啓用 TRIM/discard。 discard可以通過以下命令確認 SSD 是否支持 TRIM：1sudo hdparm -I /dev/sdX | grep TRIM2*Data Set Management TRIM supported (limit 8 blocks)若 SSD 支持 TRIM 命令，可以在 /etc/fstab 中啓用 discard 參數。建議將 discard 掛載參數作爲首選。據 debian wiki 所述，包括三星、鎂光、英睿達在內的一些 SSD 在 discard/TRIM 上有問題，不能合適地處理 TRIM 命令。該參數不是必需的，也可以自定義週期性運行 fstrim 命令來取代該參數，使用該命令前要確認 SSD 支持 TRIM，否則可能造成數據丟失。當 SSD 有足夠的空餘空間或（未分配的）可用空間時不需要該參數。 noatime掛載參數可以加入 noatime，通過禁止更新訪問記錄來減少不必要的寫操作以提高性能。該選項對 HDD 同樣有性能提升。btrfs 的默認配置爲 relatime。 compress打開壓縮功能在通常情況下有利於提高傳輸性能（並非絕對），也可以節省存儲空間。加入以下掛載參數： compress=lzo compress=zlib lzo 速度更快，zlib 壓縮率更高。注意確認 SSD 主控是否是非壓縮主控，若爲壓縮主控不建議加入該參數。 寫緩存若 SSD 帶有緩存，啓用 Write Cache 可以提高性能：Disks -&gt; Drive Setting -&gt; Enable Write Cache，但在突然斷電的情況下可能造成數據丟失。 I/O 調度SSD 結構不同於傳統硬盤，尋址時間短，I/O 調度算法可選擇 noop 以降低延遲。以下命令可查看與修改調度器：1cat/sys/block/sdX/queue/scheduler # sdX 指你的設備2sudotee/sys/block/sdX/queue/scheduler &lt;&lt;&lt; noop注意以上方法並不持久，重啓後會重置。如果 SSD 是系統唯一的存儲設備，可考慮通過 elevator=noop 內核參數設置 I/O 調度器。也可使用 udev 規則來修改調度器，對多存儲設備同樣有效：1sudo touch /etc/udev/rules.d/60-ssd-scheduler.rules #創建該文件文件內容如下：1# set deadline scheduler for non-rotating disks2ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, ATTR{queue/rotational}==&quot;0&quot;, ATTR{queue/scheduler}=&quot;noop&quot;","link":"/2017/03/25/%E5%9C%A8SSD%E4%B8%8A%E4%BD%BF%E7%94%A8Btrfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/"},{"title":"如何同步GitHub上游更新","text":"在 GitHub 上進行項目的團隊協作，一般都是 fork 組織倉庫到自己的賬號下，提交補丁後再提交 Pull Request。上游倉庫一直保持更新。由於最近在做 LCTT 項目，經常需要同步上游其他人的翻譯，下面就以 LCTT 項目爲例，記錄一下 GitHub 上 fork 倉庫同步上游更新的操作。 使用 git remote -v 查看當前的遠程倉庫別名，輸出如下： 1LCTT https://github.com/LCTT/TranslateProject.git (fetch)2LCTT https://github.com/LCTT/TranslateProject.git (push)3origin git@github.com:cycoe/TranslateProject.git (fetch)4origin git@github.com:cycoe/TranslateProject.git (push) 其中 origin 是自己賬號下的對應遠端倉庫地址別名， LCTT 是設定好的上游倉庫地址的別名。此處 LCTT 項目已經幫我們設置好了就不需要另外設置。 如果沒有設置上游倉庫地址，可通過 git remote add 上游倉庫別名 上游倉庫地址 命令來設置上游倉庫的別名。 同步上游倉庫更新到本地，併合並更新到本地倉庫 master 分支 1git fetch LCTT #從上游倉庫抓取更新2git checkout master #切換到 master 分支3git merge LCTT/master #合併上游更新到 master 分支 git push 命令推送本地倉庫到 fork 倉庫","link":"/2017/03/11/%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5GitHub%E4%B8%8A%E6%B8%B8%E6%9B%B4%E6%96%B0/"},{"title":"常用粤语语气词发音与含义","text":"最近发现粤语的语气词使用的非常多，这一点与温州话比较相似，因此特地总结了如下一些常用的粤语语气词的发音与用法。 的、地、得在普通话中，的、地、得都发音为 de，而在粤语中三个“的” 的发音都不相同。 字 发音 含义 用法 嘅 ge3 类似于普通话的“的” 小明嘅書包 咁 gam3 这样，这么，如此，可替换普通话的“地” 佢狼吞虎咽咁食 得 dak1 类似于普通话的“得” 佢写得一手好文章 到 dou3 类似于“得”，可表示程度 食得（到）一干二净 语气词 字 发音 含义 用法 哋 dei2 用於人稱代詞後，相當於“們” 我哋；佢哋 呃 ak1 騙 你成日呃我！ 咁 gam3 这样，这么，如此 件衫咁貴 噉 gam2 這樣，那樣 噉都得？ 咩 me1 表疑问，什么 做咩啊？ 唔 m4 不 唔好 咗 zo2 了 我食咗飯了 唧 zik1 用水射击 唧水 喎 wo5 语气词，常用在表达别人的吩咐 佢叫你今日去開會喎 啲 di1 表數量，若幹；少許；一點（大致有個確定數量） 畀啲錢佢；落啲胡椒粉 啩 gwaa5 語氣詞，相當於“吧” 你唔走啩 啱 ngaam1 合；合適；對；行；可以 呢種款式～心水；你講得～ 喺 hai2 在 你喺邊度等我 嚟 lai4 來，起來 過嚟 嘢 je5 東西 有嘢食 嘥 saai1 浪費；糟蹋 返一次工就嘥好多錢 嗮 saai3 完全 啲飯倒嗮 嗌 aai3 咽喉窒塞；叫 嗌救命 嗰 go3 指示代詞，那 嗰個；嗰啲（那些） 叻 lek1 能幹 叻仔 喇 laa1 了 走得喇","link":"/2019/05/09/%E5%B8%B8%E7%94%A8%E7%B2%A4%E8%AF%AD%E8%AF%AD%E6%B0%94%E8%AF%8D%E5%8F%91%E9%9F%B3%E4%B8%8E%E5%90%AB%E4%B9%89/"},{"title":"反向SSH实现内网穿透","text":"最近实验室又配置了一台新的计算平台，噪声堪比飞机起飞，再加上本校区不允许实验过夜，只能将其安置在学校外面。但从学校到计算平台车程 40Km，每次都过去做计算显然不现实，如果能从学校直接远程连接是最好的。 通过相关资料的查询及对专业人士的请教，找到如下几种解决方法: 联系网络运营商将动态 IP 转为静态的公网 IP，这样就可以直接从学校的内网连接到计算平台，是最完美的解决方案。但是查询资费后发现，价钱不那么完美，一个月 6000 块大洋怎么负担得起啊！ 主机 A 使用 TeamViewer 连接至计算平台局域网下的另一台主机 B，再控制 B 使用 SSH 连接至计算平台。这种方法包含几个明显的弊端： 操作麻烦，需要经过两层的文件传输及控制； 虽然 TeamViewer 有个人的免费使用许可，但最近审查日益严格，经常使用几分钟就被强制下线； TeamViewer 基于 GUI 远程控制，对网络要求很高； 最重要的一点，一个好的解决方案应该形成一个“黑箱”，而不应该把内部细节暴露给用户； 从计算平台使用反向 SSH 连接到云服务器，从而建立起从云服务器到计算平台的隧道连接。这种方法传输的速度上限在于云服务器的带宽，最大的优点在于实现了一个“鸭子类型”，使用 SSH 连接计算平台与连接局域网内的主机无异。 SSH 协议与应用 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 最初是 UNIX 系统上的一个程序，后来又迅速扩展到其他操作平台。SSH 在正确使用时可弥补网络中的漏洞。SSH 客户端适用于多种平台。几乎所有 UNIX 平台—包括 HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行 SSH。 以上对 SSH 的解释来自百度百科，别问我为什么不用 Wikipedia。从中我们看到，SSH 是建立在应用层基础上的一种安全协议，可以用来进行远程控制，或在计算机之间传送文件，比传统的 telnet 或 ftp 协议要更安全。Linux 下最常使用的就是 OpenSSH。OpenSSH 是 SSH 协议的免费开源实现，提供了服务端后台程序（SSH Daemon）和客户端工具(SSH Client)。主机可以通过 SSH 客户端连接运行了 SSH 服务端的主机。 网络拓扑分析互联网是一张巨大的网，其中所有的主机都由有线或无线的方式相连，但并不代表任意两台主机都能互相可见。网络是有方向的，与其说是网我觉得更像一棵树。网络在向下进行传输时，会经过 NAT（Network Address Translation 网络地址转换），因此外网的主机无法直接访问内网的主机。 在我们本次遇到的问题中，网络连接可表示为如下的拓扑结构。 各个主机的 IP 地址如下表所示 主机名 IP 用户名 备注 计算平台 A 10.0.0.100 cal 目标主机，处于内网 控制端 B 192.168.1.100 client 控制主机，处于内网 云服务器 O 123.123.123.123 server 公网服务器，起桥梁作用 其中 A、B 能够访问 O，但 O 不能访问 A、B，并且 A、B 之间不能直接互相访问。我们最后要实现的目标就是使用 B 访问 A。 解决方法通俗地说：就是在主机 A 上做到 O 的反向代理；然后在 O 上做正向的代理实现本地端口的转发。 准备工作A、B、O 上都要安装 SSH Client，A、O 上需要安装 SSH Daemon。 需要用到的 ssh 参数1反向代理2ssh -fCNR1正向代理2ssh -fCNL1-f 后台执行 ssh 指令2-C 允许压缩数据3-N 不执行远程指令4-R 将远程主机（服务器）的某个端口转发到本地端指定主机的指定端口5-L 将本地机（客户机）的某个端口转发到远端指定主机的指定端口6-p 指定远程主机的端口 反向代理首先在 A 主机上操作，建立 A 到 O 的反向代理，具体命令为1ssh -fCNR [O 主机 IP 或省略]:[O 主机端口]:[A 主机 IP ]:[A 主机端口] [O 主机的用户名@O 主机 IP]在这里我使用了 O 主机的 3333 端口，以及 A 主机的 22 端口，按照以上命令即为1ssh -fCNR 3333:localhost:22 server@123.123.123.123此时我们就将 O 的 3333 端口映射到了 A 的 22 端口，也就是说访问 O 的 3333 端口与访问 A 的 22 端口效果相同。 使用 ps aux | grep 3333 命令来查看反向代理是否运行成功。 正向代理接下来在 O 主机上操作。完成上一步的反向代理后，在主机 O 上运行如下命令应该就可以登陆 A 主机。1ssh -p 3333 cal@localhost 该命令的含义为，使用 cal 用户登陆本机的 3333 端口。上面已经说过，访问 O 的 3333 端口与访问 A 的 22 端口效果相同，那么我们就成功从 O 主机登陆了 A 主机。 但此时我们仍只能从 O 主机本机上登陆 A 主机，无法从其他主机登陆，因此需要再对 3333 端口进行一次端口转发，使其他主机可以访问。具体命令为1ssh -fCNL [O 主机 IP 或省略]:[转发端口]:[O 主机 IP]:[被转发端口] [登陆 O 主机的用户名@O 主机的 IP]此处我们想要将 3333 端口转发到 2222 端口，因此转发端口为 2222，被转发端口为 3333。1ssh -fCNL *:2222:localhost:3333 localhost此处 * 表示允许任意其他主机访问，本机的用户名可省略。使用 ps aux | grep 2222 命令来查看正向代理是否运行成功。此处 2222 端口为本地转发端口，负责与外网进行通信，并将数据转发到 3333 端口，实现了可以从其他主机访问的功能。 展现奇迹的时候到了到次为至，我们已经配置好了 AO 主机，那么我们可以从任意可联网的设备登录到计算平台中去啦。指令为1ssh -p 2222 cal@123.123.123.123我们实现了从任意地方连入内网计算平台的连接！ 这种反向代理是不稳定的不幸的是这种 ssh 连接会因为超时和网络堵塞等原因而关闭，那么从的外网连通内网的通道就无法维持了，为此我们需要维持稳定 ssh 反向代理隧道的方法。 配置 ssh key 实现免密登陆在使用 ssh 进行连接时，每次都需要输入密码，一方面不安全，另一方面也为我们接下来使用的自动化工具带来了阻碍。 首先登陆 A 主机，并运行如下命令生成公钥私钥对。中间的配置过程一路回车即可。1ssh-keygen -t rsa -C \"youremail@example.com\" 此时就在 A 主机的 ~/.ssh/ 目录下生成了公钥与私钥对，接下来我们需要将公钥传到 O 主机上作为我们登陆的一个比对凭证1ssh-copy-id server@123.123.123.123此时，我们再使用 ssh server@123.123.123.123 登陆路 O 主机就不再需要密码了。 用 autossh 建立稳定隧道从 A 主机到 O 主机的反向代理连接是不稳定的，也就是说，我们需要一个工具来时刻监听着这个连接。一但断开，再次自动重新建立连接即可。幸运的是，已经有人写出了这个工具，那就是 autossh！感谢开源！ CentOS 的官方仓库中并没有这个软件包，我们需要从源码编译安装1sudo yum install wget gcc make2wget http://www.harding.motd.ca/autossh/autossh-1.4e.tgz3tar -xf autossh-1.4e.tgz4cd autossh-1.4e5./configure6make7sudo make install至此我们已经安装好了 autossh，利用下面的命令来启动守护进程。1autossh -M 7200 -fCNR 3333:localhost:22 server@123.123.123.123autossh 命令的参数与 ssh 一致，不同的是我们需要指出的 -M`` 参数，这个参数指定一个端口，这个端口是外网的 O 主机用来接收内网 A 主机的信息，如果隧道不正常而返回给 A 主机让它实现重新连接。 配置自动启动我们需要将 autossh 命令配置在开机自动启动脚本中，免去了每次开机都需要重新运行脚本的麻烦。 我们需要在 A 主机的 /etc/rc.d/rc.local 文件中添加如下内容1/bin/su -c '/usr/local/bin/autossh -M 7200 -fCNR 3333:localhost:22 server@123.123.123.123' - cal此命令表示，以 cal 用户运行 autossh 命令，这样我们就能够使用 cal 用户反向连接到 A 主机。 为了保险起见，我们需要为自启动脚本添加执行权限1sudo chmod +x /etc/rc.d/rc.local 至此我们就建立好了稳定的连接隧道。 进一步优化保持活连接在测试中发现，如果一个连接长时间空置，那么就会冻结。反向代理连接也是一样，此时便只能通过重启 A 主机使连接重置。为保持一个活连接（Keep alive），需要服务端或客户端定时发送心跳包来确保连接活跃，此处我们选择配置服务端的心跳。 在 A 和 O 的 /etc/ssh/sshd_config 文件中添加如下内容1# server 每隔 60 秒发送一次请求给 client，然后 client 响应，从而保持连接2ClientAliveInterval 603# server 发出请求后，客户端没有响应得次数达到 3，就自动断开连接，正常情况下，client 不会不响应4ClientAliveCountMax 3 Windows SSH Client 连接提示错误使用 Windows 的 SSH Client 连接 Linux 运行的 SSH 服务端时，会提示“ssh algorithm negotiation failed”错误，导致此问题的原因是 ssh 升级后，为了安全，默认不再采用原来一些加密算法，我们手工添加进去即可。 在 O 主机的 /etc/ssh/sshd_config 文件中添加如下内容1# add crypt format for window ssh client2Ciphers aes128-cbc,aes192-cbc,aes256-cbc,aes128-ctr,aes192-ctr,aes256-ctr,3des-cbc,arcfour128,arcfour256,arcfour,blowfish-cbc,cast128-cbc3MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160,hmac-sha1-96,hmac-md5-964KexAlgorithms diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1,diffie-hellman-group-exchange-sha256,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group1-sha1,curve25519-sha256@libssh.org 参考文献 Windows SSH Client 报 Algorithm negotiation failed 的解决方法之一 使用SSH反向隧道进行内网穿透","link":"/2019/04/30/%E5%8F%8D%E5%90%91SSH%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"title":"教務網現驚天大 bug？！談談弱密碼如何暴露你的信息","text":"漏洞發現最近在爲之前寫的爬蟲做批註的時候發現了一段有趣的代碼，代碼如下 1MisUtils.initAttempt()2while MisUtils.descAttempt():3 self.response = self.session.send(prepareBody)4 if self.response.status_code == 200:5 break6if not MisUtils.descAttempt():7 Logger.log('Up to max attempts!', ['Maybe remote server unreachable'], level=Logger.error)8 return False910if re.search('用戶名不存在', self.response.text):11 print(Logger.log('No such a user!', ['Cleaning password file'], level=Logger.error))12 reInput = True1314elif re.search('密碼錯誤', self.response.text):15 print(Logger.log('Wrong password!', ['Cleaning password file'], level=Logger.error))16 reInput = True1718elif re.search('請輸入驗證碼', self.response.text):19 print(Logger.log('Please input vertify code!', ['Retrying...'], level=Logger.error))2021elif re.search('驗證碼錯誤', self.response.text):22 print(Logger.log('Wrong vertify code!', ['Retrying...'], level=Logger.error))2324else:25 print(Logger.log('Login successfully!', ['UserName: ' + MisUtils.confDict['userName']], level=Logger.error))26 MisUtils.dumpConfFile()27 break 當時寫的時候沒注意，現在回過頭來看看，驚奇地發現教務網對於用戶名和密碼的驗證順序是如下的優先級： 首先驗證用戶名是否存在 再驗證密碼是否正確 然後驗證碼是否爲空 最後纔是驗證碼是否正確 這。。。我只想說，誰寫的驗證邏輯。。。我要這驗證碼有何用？！！！ 漏洞驗證接下來去教務網上驗證一下整個驗證邏輯是否如所想的那樣 首先在用戶名輸入框中隨意輸入一串數字，並保持密碼和驗證碼都爲空，嘗試登錄發現彈出“用戶名不存在”的 JS 腳本 再輸入我正確的學號，仍保持密碼和驗證碼都爲空，嘗試登錄彈出“密碼錯誤”的 JS 腳本 輸入正確的學號和密碼，並保持驗證碼爲空，嘗試登錄彈出“請輸入驗證碼”的 JS 腳本 輸入正確的學號和密碼，但是輸入錯誤的驗證碼，嘗試登錄彈出“驗證碼錯誤”的 JS 腳本 通過以上流程，可以總結得以下兩條有價值的信息： 當你輸入的用戶名不存在時，不管密碼和驗證碼輸的啥，總是會提示“用戶名不存在”；當你輸入的用戶名存在，並且密碼爲空時，會提示“密碼錯誤”。 當你輸入的用戶名存在，但是密碼錯誤時，不管驗證碼輸的啥，總會提示“密碼錯誤”；當輸入的密碼正確並且驗證碼爲空時，會提示“請輸入驗證碼”。 漏洞利用通過上面的兩條信息可以至少做到兩件事情 枚舉用戶名目前所有在讀研究生的入學時間大部分爲 2013-2017 年，學號的前四位爲入學年份，中間三位與所在的專業有關，最後三位爲流水號。對所有形如 2013XXXXXX 的學號進行嘗試登錄，根據信息 1，能夠枚舉出所有 13 年入學的學生學號。 暴破利用上一步得到的用戶名列表，再配合字典就可以進行在線的密碼暴破，這種破解方法一般來說是非常低效的，嚴重依賴於網絡狀況和服務器的機能。嘗試發現在單線程的情況下，每秒只能對服務器進行 1k 次左右的訪問。也就是說如果使用 16 位的數字加字母作爲密碼，最多需要 2.5 百萬億年的時間才能成功破解。看起來是非常安全吧。然而實際情況又是什麼樣呢？教務網的初始密碼爲身份證號中的生日，一般來說我們在第一次登錄時都會改密碼，但還總會有人抱着僥倖的心理用初始密碼，這就爲暴破帶來了捷徑。以生日作爲密碼具有非常明顯的結構，如 2017 年入學學生的生日大多在 1994-1996 之間，利用下面簡單的字典生成器可得到 1994-1996 年所有的日期列表：1big_month_ = [1, 3, 5, 7, 8, 10, 12]2small_month_ = [4, 6, 9, 11]345def gen_(begin, end):6 password_ = []7 for year in range(begin, end + 1):8 for month in range(1, 13):9 if month in big_month_:10 month_len = 3111 elif month in small_month_:12 month_len = 3013 elif month == 2:14 if year % 4 != 0 or (year % 100 == 0 and year % 400 != 0):15 month_len = 2816 else:17 month_len = 2918 else:19 month_len = 312021 for day in range(1, month_len + 1):22 password_.append(str(year) + str(month).zfill(2) + str(day).zfill(2))2324 with open('password.dict', 'w') as fr:25 for password in password_:26 fr.write(password)27 fr.write('\\n')282930def main():31 gen_(1994, 1996)利用得到的用戶名列表和密碼字典就可以對所有未修改的用戶密碼進行暴破。 總結最後結果怎麼樣？使用 100 個線程，並設置單個線程的訪問頻率爲 1 次/秒進行暴破，10 分鐘破解出了接近 40 個用戶密碼！並且平均每四個人裏就有一個人沒有修改密碼！可能很多人會覺得教務網密碼不涉及錢財也就不那麼在意。但其實教務網上有詳細的個人資料，包括你的姓名、照片和家庭住址。另外還有你的課表，你某時某刻會在哪個教室出現都會被人知道啊！所以，弱密碼的危害顯而易見，很多的信息泄漏也都是由弱密碼引起的。給自己換個複雜點的密碼吧，畢竟密碼這種東西一寸長一寸強。現在也快到年底了，騙子也要賺錢備年貨了，希望大家能夠保護好自己的信息，不要給騙子可乘之機。最後討伐一下這個軟件提供商，一個商業化的系統裏面竟然有如此明顯的邏輯漏洞，只希望快點被修復吧。","link":"/2017/12/07/%E6%95%99%E5%8A%A1%E7%BD%91%E7%8E%B0%E6%83%8A%E5%A4%A9%E5%A4%A7bug/"},{"title":"正交試驗設計","text":"正交試驗設計是利用正交表來安排與分析多因素試驗的一種設計方法。它是由試驗因素的全部水平組合中，挑選部分有代表性的水平組合進行試驗的，通過對這部分試驗結果的分析瞭解全面試驗的情況，找出最優的水平組合。可以通過代表性很強的少數次試驗，摸清各個因素對試驗指標的影響情況，確定出因素的主次順序，找出較好的生產條件或最佳參數組合。 正交表的性質正交性 均勻分散性：任一列中，不同數字出現的次數相等； 整齊可比性：任兩列中，同一橫行所組成的數字對出現的次數相等； 可置換性： 正交表各列的地位是平等的，表中各列之間可以相互置換，稱爲列間置換； 正交表各行之間也可相互置換，稱列間置換； 正交表中同一列的水平數字也可以相互置換，稱水平置換。 分散均勻性 任一列的各水平都出現，使得部分試驗中包含所有因素的所有水平； 任意兩列間的所有組合全部出現，使任意兩因素間都是全面試驗。 綜合可比性 任一列各水平出現的次數都相等； 任兩列間所有可能的組合出現的次數都相等，因此使任一因素各水平的試驗條件相同。 拉丁方陣拉丁方陣（Latin square）是一種 $n\\times n$ 的方陣，在這種 $n\\times n$ 的方陣裏，恰有 $n$ 種不同的元素，每一種不同的元素在同一行或同一列裏只出現一次。如下面的三階拉丁方。 \\begin{bmatrix} 1 & 2 & 3\\\\ 2 & 3 & 1\\\\ 3 & 1 & 2\\\\ \\end{bmatrix}標準型當一個拉丁方陣的第一行與第一列的元素按順序排列時，此爲這個拉丁方陣的標準型，英語稱爲 “reduced Latin square, normalized Latin square, or Latin square in standard form”。 構造拉丁方同階的拉丁方有多個，構造其中的一個有一種通用的方法。 若 $n$ 爲偶數，則構造第一行爲 $1, 2, n, 3, n-1, 4, n-2, \\dots$，之後的每一行都在上一行對應列元素上加一併對 $n$ 取模，即可表示爲如下矩陣。 \\begin{bmatrix} 1 & 2 & n & 3 & n-1 & 4 & n-2 & \\cdots\\\\ 2 & 3 & n+1 & 4 & n & 5 & n-1 & \\cdots\\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\ i & i+1 & i+n-1 & i+2 & i+n-2 & i+3 & i+n-3 & \\cdots\\\\ \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots\\\\ n & 1 & n-1 & 2 & n-2 & 3 & n-3 & \\cdots\\\\ \\end{bmatrix} \\mathrm{mod}\\ n若 $n$ 爲奇數，則先按偶數法則構造一個拉丁方，然後將上述模式左右對調。 正交拉丁方設有兩個階數相同且爲 $n$ 的拉丁方陣$A_1=(a^{(1)}_{i,j})_{n\\times n}, A_2=(a^{(2)}_{i,j})_{n\\times n}$，其中將所有放置位置相同的元素組合成一個元組，組合成一個新的矩陣 $((a^{(1)}_{i,j}, a^{(2)}_{i,j}))_{n\\times n}$。當這個新的矩陣 $((a^{(1)}_{i,j}, a^{(2)}_{i,j}))_{n\\times n}$ 中每一個元素互不相同時，拉丁方陣 $A_1$ 和 $A_2$ 是互相正交的。此時，$A_1$ 和 $A_2$ 即爲一對正交拉丁方。 而在階數固定的情況下，所有兩兩正交的拉丁方所成的集合稱爲正交拉丁方族。如下面的兩個 3 階拉丁方。 \\begin{matrix} A = \\begin{bmatrix} 1 & 2 & 3\\\\ 2 & 3 & 1\\\\ 3 & 1 & 2\\\\ \\end{bmatrix} & B = \\begin{bmatrix} 1 & 2 & 3\\\\ 3 & 1 & 2\\\\ 2 & 3 & 1\\\\ \\end{bmatrix} \\end{matrix}素數階拉丁方若 $n$ 階拉丁方存在 $r$ 個兩兩正交的拉丁方，那麼 $r\\leq n-1$。素數階拉丁方（以 $3, 5, 7, \\dots$ 爲階）是完全的，即 $n$ 階正交拉丁方族中有 $n-1$ 個拉丁方。 構造正交表因爲素數階拉丁方都可構造完全的正交拉丁方族，則可繼續構造正交表。若把素數 $n$ 作爲水平數，則以 $n$ 階拉丁方構造的正交拉丁方有 $n-1$ 個。以 $n-1$ 作爲因素數構造正交表。 以 3 階拉丁方爲例，3 階正交拉丁方族包含 2 個正交拉丁方，並將對應位置元素合併成二元有序數對。 \\begin{matrix} \\begin{bmatrix} 1 & 2 & 3\\\\ 2 & 3 & 1\\\\ 3 & 1 & 2\\\\ \\end{bmatrix} & \\begin{bmatrix} 1 & 2 & 3\\\\ 3 & 1 & 2\\\\ 2 & 3 & 1\\\\ \\end{bmatrix} & = & \\begin{bmatrix} 11 & 22 & 33\\\\ 23 & 31 & 12\\\\ 32 & 13 & 21\\\\ \\end{bmatrix} & \\end{matrix}以第一個元素作爲因素 A，第二個元素作爲因素 B，然後與因素 C、D 均勻搭配，構造 4 因素 3 水平正交表。 C, A, B, D 1 2 3 1 11 22 33 2 23 31 12 3 32 13 21 展開後爲 試驗號 A B C D 1 1 1 1 1 2 1 2 2 2 3 1 3 3 3 4 2 2 3 1 5 2 3 1 2 6 2 1 2 3 7 3 3 2 1 8 3 1 3 2 9 3 2 1 3 若只與一個因素 C 搭配，則可構造 3 因素 3 水平正交表。 C, A, B 1 11 22 33 2 23 31 12 3 32 13 21 展開後爲 試驗號 A B C 1 1 1 1 2 1 2 2 3 1 3 3 4 2 2 3 5 2 3 1 6 2 1 2 7 3 3 2 8 3 1 3 9 3 2 1 由此可見，以素數 $n$ 爲水平數設計正交試驗，可滿足 $[n-1, n+1]$ 個因素的設計，並且總共需要 $n^2$ 次試驗。即對於 3 因素 3 水平與 4 因素 3 水平正交試驗具有相同的試驗組數，同爲 9 組。可類似地構造出 $L_9(3^3)$，$L_9(3^4)$，$L_{25}(5^5)$，$L_{25}(5^6)$，$L_{49}(7^7)$，$L_{49}(7^8)$ 等。 參考資料 百度百科-拉丁方 百度百科-正交拉丁方 百度百科-拉丁方設計 正交表與正交設計","link":"/2018/11/13/%E6%AD%A3%E4%BA%A4%E8%AF%95%E9%AA%8C%E8%AE%BE%E8%AE%A1/"},{"title":"用GitHub-Pages和jekyll搭建個人主頁","text":"閒來無事，打算搭建個人主頁。查閱了各種資料，發現目前最省錢省力的方法就是在 GitHub Pages 上利用 jekyll 靜態網頁生成器搭建。對於 Web 開發小白來說，自己寫網頁代碼不太現實。 好在GitHub 上有許多其他大神製作好的 jekyll 模板，直接 fork 過來修改一下就可以使用，其餘的精力都可以用在文章內容本身上。 搭建步驟 在 GitHub 上找到自己喜歡的 jekyll 模板， fork 到自己的倉庫下，然後點擊 Setting 修改倉庫名稱爲 username.github.io 將 fork 後的項目 clone 至本地 打開 _config.yml 文件修改其中的信息，包括網站名稱、用戶信息等 將 html 或 MarkDown 格式的文章和博客添加到 _posts 文件夾 使用以下命令即可提交更新並推送更新至遠端倉庫 1git add .2git commit -am \"post update\"3git push 完成以上步驟後，你就應該可以通過 username.github.io 訪問你的主頁了 :clap: ！ 注意事項comments_provider: duoshuo duoshuo_username: cycoe disqus_username: cycoe lazy_load_duoshuo: true 此處的usrname一定要填自己申請的賬號名 進階配置 申請域名 本博客使用的主題爲 mzlogin 的 碼志 主題","link":"/2017/03/09/%E7%94%A8GitHub-Pages%E5%92%8Cjekyll%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"},{"title":"路由器配置教程","text":"初次使用拿到新的路由器之后，首先检查外包装是否有破损、路由器是否有划痕、插头是否有使用痕迹、插上电源后指示灯是否正常亮起，以此初步判断路由器是否是全新的，在某东平台上买电子产品要尤其注意。。。 好吧扯远了。。。路由器其实可以算作是一台独立的微型计算机，运行着定制的操作系统（针对路由器我们叫固件）。但路由器又与我们平常见到的电脑不同，因为它没有标准输入输出设备，也就是键盘鼠标和显示器。那我们要怎么对路由器进行控制呢，其实有很多种方式，但无论的使用哪种方式，我们都需要首先连接上路由器。 为路由器插上电 连接路由器的方式有两种——有线和无线连接。任选其一即可。 有线连接：使用网线一头连接路由器的 LAN（Local Area Network）口，一头连接电脑的网线口 无线连接：打开 Wi-Fi 并连接路由器，一般初始名字为 “TP-LINK_XXX” 在浏览器中输入 192.168.1.1 打开路由器管理界面（也可能是其他 IP 地址，一般在路由器底部的标签上可以看到） 这个时候，根据配置向导对路由器进行配置即可。需要注意的是对于校园网，在 WAN 口连接方式中，选择“动态IP”选项。其他的 SSID 名（也就是平常说的 Wi-Fi 名）及密码等根据需要进行配置即可 高级配置在路由器管理页面中，我们可以看到非常多的配置选项。虽然平常在家庭使用中我们只会用到其中的几个选项，但对于实验室这样一个需要对几十台设备进行管理的场景，里面的一些选项就会非常有用了。 静态 IP 地址绑定这是我最常用到的一个功能，通俗的讲就是将一个设备的 IP 的地址固定下来。一个设备在通过路由器连入互联网时，路由器会通过 DHCP（Dynamic Host Configuration Protocol 动态主机设置协议）服务为每个设备随机分配 IP 地址，并且每过一段时间就会改变。那么我们想在局域网中找到另一台设备就需要通过 IP 地址，而静态 IP 地址绑定就是要告诉路由器，我想为一台特定设备分配一个固定的 IP 地址，那么我以后就可以通过这个固定的 IP 地址来找到这台设备。 现在的路由器几乎都有这个功能，一般是在基本设置-LAN 设置-静态地址分配中进行设置。其中“MAC 地址”是设备的硬件地址，是一串唯一的 12 位的十六进制数，在设备出厂时就确定好了。可通过我写的小程序获得。“IP 地址”是你希望该设备使用的 IP 地址。 路由器桥接","link":"/2019/04/30/%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"},{"title":"靜態編譯安裝 Qt","text":"由於 pyqt 寫的程序打包過程中依賴庫的問題，打算用 c++ 版的 Qt 重寫程序。但若用系統自帶的共享鏈接庫進行編譯，程序同樣無法在其他機器上運行。因此，此時需要自己手動靜態編譯 Qt，使用靜態鏈接庫編譯的程序會自動將依賴的庫加到最終編譯出的機器碼中。 安裝依賴項 Qt 的界面顯示依賴 freetype 和 fontconfig，這兩個一定要裝上，否則編譯不成功。 安裝完畢後創建 freetype 的軟鏈接到標準的安裝位置：ln -s /usr/include/freetype2/freetype /usr/include/freetype 編譯 下載最新的 Qt everywhere 壓縮包 解壓壓縮包，cd 進壓縮包目錄 運行以下命令對 makefile 進行配置 1./configure -confirm-license -opensource -static -fontconfig -release -no-qml-debug -qt-xcb -nomake tests -nomake examples -skip qtwebkit -prefix /usr/include/Qt-5.8.0-static -static -&gt; 選擇靜態編譯模式 -fontconfig -&gt; 此項一定要加，否則會導致找不到字體 -prefix -&gt; 指定安裝位置 運行 make -j 3 採用 3 線程編譯 最後 sudo make install 安裝 Qt 配置 Qt Creator 安裝 Qt Creator 打開 Qt Creator -&gt; tools -&gt; options -&gt; build，根據安裝路徑配置 Qt version 和 Kit","link":"/2017/04/11/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Qt/"},{"title":"如何提高搶到報告的概率？","text":"#right-panel { background-color: #fff; } #right-panel .cover-top { background: linear-gradient(to bottom, #fff 50%, transparent); } #cover-bottom #cover-bottom-background-right { background: #fff; } @font-face { font-family: octicons-link; src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff'); } #container { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; color: #373737; font-family: \"Roboto\", \"Noto Sans\", \"Ubuntu\", \"Helvetica Neue\", Helvetica, \"Segoe UI\", Arial, sans-serif, \"Noto Sans CJK SC\", \"Source Han Sans SC\", \"Microsoft Yahei\"; font-size: 14px; line-height: 2; word-wrap: break-word; background-color: #fff; } #container a { background-color: transparent; -webkit-text-decoration-skip: objects; } #container a:active, #container a:hover { outline-width: 0; } #container strong { font-weight: inherit; } #container strong { font-weight: bolder; } #container h1 { font-size: 2em; margin: 0.67em 0; } #container img { border-style: none; } #container svg:not(:root) { overflow: hidden; } #container code, #container kbd, #container pre { font-family: \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; font-size: 1em; } #container hr { box-sizing: content-box; height: 0; overflow: visible; } #container input { font: inherit; margin: 0; } #container input { overflow: visible; } #container button:-moz-focusring, #container [type=\"button\"]:-moz-focusring, #container [type=\"reset\"]:-moz-focusring, #container [type=\"submit\"]:-moz-focusring { outline: 1px dotted ButtonText; } #container [type=\"checkbox\"] { box-sizing: border-box; padding: 0; } #container table { border-spacing: 0; border-collapse: collapse; } #container td, #container th { padding: 0; } #container * { box-sizing: border-box; } #container input { font: 13px/1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; } #container a { color: #4078c0; text-decoration: none; } #container a:hover, #container a:active { text-decoration: underline; } #container hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #ddd; } #container hr::before { display: table; content: \"\"; } #container hr::after { display: table; clear: both; content: \"\"; } #container h1, #container h2, #container h3, #container h4, #container h5, #container h6 { margin-top: 0; margin-bottom: 0; line-height: 1.5; } #container h1 { font-size: 30px; } #container h2 { font-size: 21px; } #container h3 { font-size: 16px; } #container h4 { font-size: 14px; } #container h5 { font-size: 12px; } #container h6 { font-size: 11px; } #container p { margin-top: 0; margin-bottom: 10px; } #container blockquote { margin: 0; } #container ul, #container ol { padding-left: 0; margin-top: 0; margin-bottom: 0; } #container ol ol, #container ul ol { list-style-type: lower-roman; } #container ul ul ol, #container ul ol ol, #container ol ul ol, #container ol ol ol { list-style-type: lower-alpha; } #container dd { margin-left: 0; } #container code { font-family: \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; font-size: 12px; } #container pre { margin-top: 0; margin-bottom: 0; font: 12px \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; } #container .pl-0 { padding-left: 0 !important; } #container .pl-1 { padding-left: 3px !important; } #container .pl-2 { padding-left: 6px !important; } #container .pl-3 { padding-left: 12px !important; } #container .pl-4 { padding-left: 24px !important; } #container .pl-5 { padding-left: 36px !important; } #container .pl-6 { padding-left: 48px !important; } #container .form-select::-ms-expand { opacity: 0; } #container:before { display: table; content: \"\"; } #container:after { display: table; clear: both; content: \"\"; } #container>*:first-child { margin-top: 0 !important; } #container>*:last-child { margin-bottom: 0 !important; } #container a:not([href]) { color: inherit; text-decoration: none; } #container .anchor { display: inline-block; padding-right: 2px; margin-left: -18px; } #container .anchor:focus { outline: none; } #container h1, #container h2, #container h3, #container h4, #container h5, #container h6 { margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; } #container h1 .octicon-link, #container h2 .octicon-link, #container h3 .octicon-link, #container h4 .octicon-link, #container h5 .octicon-link, #container h6 .octicon-link { color: #000; vertical-align: middle; visibility: hidden; } #container h1:hover .anchor, #container h2:hover .anchor, #container h3:hover .anchor, #container h4:hover .anchor, #container h5:hover .anchor, #container h6:hover .anchor { text-decoration: none; } #container h1:hover .anchor .octicon-link, #container h2:hover .anchor .octicon-link, #container h3:hover .anchor .octicon-link, #container h4:hover .anchor .octicon-link, #container h5:hover .anchor .octicon-link, #container h6:hover .anchor .octicon-link { visibility: visible; } #container h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } #container h1 .anchor { line-height: 1; } #container h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } #container h2 .anchor { line-height: 1; } #container h3 { font-size: 1.5em; line-height: 1.43; } #container h3 .anchor { line-height: 1.2; } #container h4 { font-size: 1.25em; } #container h4 .anchor { line-height: 1.2; } #container h5 { font-size: 1em; } #container h5 .anchor { line-height: 1.1; } #container h6 { font-size: 1em; color: #777; } #container h6 .anchor { line-height: 1.1; } #container p, #container blockquote, #container ul, #container ol, #container dl, #container table, #container pre { margin-top: 0; margin-bottom: 16px; } #container hr { height: 4px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; } #container ul, #container ol { padding-left: 2em; } #container ul ul, #container ul ol, #container ol ol, #container ol ul { margin-top: 0; margin-bottom: 0; } #container li>p { margin-top: 16px; } #container dl { padding: 0; } #container dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold; } #container dl dd { padding: 0 16px; margin-bottom: 16px; } #container blockquote { padding: 0 15px; color: #777; border-left: 4px solid #ddd; } #container blockquote>:first-child { margin-top: 0; } #container blockquote>:last-child { margin-bottom: 0; } #container table { display: block; width: 100%; overflow: auto; word-break: normal; word-break: keep-all; } #container table th { font-weight: bold; } #container table th, #container table td { padding: 6px 13px; border: 1px solid #ddd; } #container table tr { background-color: #fff; border-top: 1px solid #ccc; } #container table tr:nth-child(2n) { background-color: #f8f8f8; } #container img { max-width: 100%; box-sizing: content-box; background-color: #fff; } #container code { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(0,0,0,0.04); border-radius: 3px; } #container code:before, #container code:after { letter-spacing: -0.2em; content: \"\\00a0\"; } #container pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } #container .highlight { margin-bottom: 16px; } #container .highlight pre, #container pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border-radius: 3px; } #container .highlight pre { margin-bottom: 0; word-break: normal; } #container pre { word-wrap: normal; } #container pre code { display: inline; max-width: initial; padding: 0; margin: 0; overflow: initial; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } #container pre code:before, #container pre code:after { content: normal; } #container kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: #555; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #ccc; border-bottom-color: #bbb; border-radius: 3px; box-shadow: inset 0 -1px 0 #bbb; } #container .pl-c { color: #969896; } #container .pl-c1, #container .pl-s .pl-v { color: #0086b3; } #container .pl-e, #container .pl-en { color: #795da3; } #container .pl-s .pl-s1, #container .pl-smi { color: #333; } #container .pl-ent { color: #63a35c; } #container .pl-k { color: #a71d5d; } #container .pl-pds, #container .pl-s, #container .pl-s .pl-pse .pl-s1, #container .pl-sr, #container .pl-sr .pl-cce, #container .pl-sr .pl-sra, #container .pl-sr .pl-sre { color: #183691; } #container .pl-v { color: #ed6a43; } #container .pl-id { color: #b52a1d; } #container .pl-ii { background-color: #b52a1d; color: #f8f8f8; } #container .pl-sr .pl-cce { color: #63a35c; font-weight: bold; } #container .pl-ml { color: #693a17; } #container .pl-mh, #container .pl-mh .pl-en, #container .pl-ms { color: #1d3e81; font-weight: bold; } #container .pl-mq { color: #008080; } #container .pl-mi { color: #333; font-style: italic; } #container .pl-mb { color: #333; font-weight: bold; } #container .pl-md { background-color: #ffecec; color: #bd2c00; } #container .pl-mi1 { background-color: #eaffea; color: #55a532; } #container .pl-mdr { color: #795da3; font-weight: bold; } #container .pl-mo { color: #1d3e81; } #container kbd { display: inline-block; padding: 3px 5px; font: 11px \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; line-height: 10px; color: #555; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #ccc; border-bottom-color: #bbb; border-radius: 3px; box-shadow: inset 0 -1px 0 #bbb; } #container .full-commit .btn-outline:not(:disabled):hover { color: #4078c0; border: 1px solid #4078c0; } #container :checked+.radio-label { position: relative; z-index: 1; border-color: #4078c0; } #container .octicon { display: inline-block; vertical-align: text-top; fill: currentColor; } #container .task-list-item { list-style-type: none; } #container .task-list-item+.task-list-item { margin-top: 3px; } #container .task-list-item input { margin: 0 0.2em 0.25em -1.6em; vertical-align: middle; } #container hr { border-bottom-color: #eee; } 在之前寫搶報告軟件的過程中，遇到一個非常有趣的問題——如何提高搶到報告的概率？當然，無腦減小兩次請求之間的間隔時間可以保證一定能搶到報告，但是也會加大服務器的負擔，作爲北京化工大學的優秀學子:smirk:，這麼做是不可行的。腦中突然靈光一現，以固定 5 秒的時間間隔搶報告與以 0 到 10 之間的隨機時間間隔搶報告，搶到報告的概率是一樣的嗎？剛好最近要考數理統計，那就用概率論的知識來解決這個問題吧（其實是不務正業:grin:）。 問題分析 從直觀上來看，固定 5 秒的時間間隔與 0 到 10 之前的隨機時間間隔的期望是相等的，實際情況計算後才知道。 間隔時間固定的情況 爲了簡化問題，首先將搶到報告的事件記爲 ，將報告的存活時間（報告從可搶狀態開始到被搶走的時間）的期望值記爲 E ，提交搶報告請求的時間間隔爲 ，則搶到報告的概率即爲 。針對 的情況， 。即在報告平均存活時間爲 3 秒，搶報告間隔固定爲 5 秒的情況下，搶到報告的概率爲 。 間隔時間爲均勻分佈的情況 在該種情況下，我們構造搶報告的時間間隔的分佈爲 ，其概率密度函數爲： 則對於任意的時間間隔 ，根據上一節中的結果，搶到報告的概率 的可表示爲分段函數： 得到搶到報告的期望爲 針對搶報告時間滿足 分佈，報告平均存活時間爲 3 秒的情況，將 代入上式，得到 。也就是說不改變 期望的情況下，通過改變 的分佈竟然提高了搶到報告的概率！！！我要趕快把這個修改合併到搶報告程序中！！！ 總結 爲什麼兩種方法搶到報告的概率不同呢？個人分析是由於在 滿足均勻分佈時，其中較小的 帶來了較大的成功概率，而較大的 對整體概率的影響不大。正如有句話說的好，搶報告搶的早不如搶的巧。搶報告是玄學，需要天時地利人和。至於計算過程是否正確，就要看最後我的數理統計成績了:joy:","link":"/2017/11/03/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%8A%A2%E5%88%B0%E6%8A%A5%E5%91%8A%E7%9A%84%E6%A6%82%E7%8E%87/"}],"tags":[{"name":"DwarfFortress","slug":"DwarfFortress","link":"/tags/DwarfFortress/"},{"name":"Archlinux","slug":"Archlinux","link":"/tags/Archlinux/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"planche","slug":"planche","link":"/tags/planche/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"Cantonese","slug":"Cantonese","link":"/tags/Cantonese/"},{"name":"Spider","slug":"Spider","link":"/tags/Spider/"},{"name":"Sploit","slug":"Sploit","link":"/tags/Sploit/"},{"name":"Statistics","slug":"Statistics","link":"/tags/Statistics/"},{"name":"Emacs","slug":"Emacs","link":"/tags/Emacs/"},{"name":"Graphviz","slug":"Graphviz","link":"/tags/Graphviz/"},{"name":"Org","slug":"Org","link":"/tags/Org/"},{"name":"GTD","slug":"GTD","link":"/tags/GTD/"},{"name":"Agenda","slug":"Agenda","link":"/tags/Agenda/"},{"name":"mu4e","slug":"mu4e","link":"/tags/mu4e/"},{"name":"mail","slug":"mail","link":"/tags/mail/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"},{"name":"Games","slug":"Games","link":"/categories/Games/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"personal","slug":"personal","link":"/categories/personal/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"Math","slug":"Math","link":"/categories/Math/"},{"name":"GitHub","slug":"GitHub","link":"/categories/GitHub/"},{"name":"Statistics","slug":"Statistics","link":"/categories/Statistics/"},{"name":"spider","slug":"Python/spider","link":"/categories/Python/spider/"},{"name":"Spider","slug":"Python/Spider","link":"/categories/Python/Spider/"},{"name":"Sploit","slug":"Python/Spider/Sploit","link":"/categories/Python/Spider/Sploit/"},{"name":"Emacs","slug":"Linux/Emacs","link":"/categories/Linux/Emacs/"}]}