{"meta":{"title":"Cycoe's Home Page","subtitle":"Simple is better than complex. Complex is better than complicated.","description":"Cycoe's Personal Blog","author":"Cycoe","url":"http://cycoe.cc"},"pages":[],"posts":[{"title":"一种通过最小二乘法求转变点的方法","slug":"一种通过最小二乘法求转变点的方法","date":"2018-10-23T13:52:47.000Z","updated":"2018-10-24T15:09:51.711Z","comments":true,"path":"2018/10/23/一种通过最小二乘法求转变点的方法/","link":"","permalink":"http://cycoe.cc/2018/10/23/一种通过最小二乘法求转变点的方法/","excerpt":"","text":"最小二乘法假设存在 k 个样本点 \\(X_1, X_2, \\ldots, X_k\\)，定义向量\\(X_i = (x_{i1}, x_{i2}, \\ldots, x_{in})^T\\)，为方便计算在 \\(X_i\\) 前插入常量 1。则需要求 \\(W = (w_0, w_1, w_2, \\ldots, w_n)\\) 使 \\(\\hat{Y} = XW\\)。 定义均方误差 \\(E = \\dfrac{1}{n}\\sum(y_i-\\hat{y}_i)^2 = \\dfrac{1}{n}||Y-\\hat{Y}||_2^2\\)，则可转变为寻找 W 使得 E 最小，即寻找 \\(W = \\mathrm{argmin}\\dfrac{1}{n}||Y-XW||_2^2\\)。 对于 E(W) = \\dfrac{1}{n}则可推导 \\begin{align} E(W+\\Delta W) - E(W) &= \\dfrac{1}{n}||Y-X(W+\\Delta W)||_2^2-\\dfrac{1}{n}||Y-XW||_2^2\\\\ &= \\dfrac1n||Y-XW||_2^2-\\dfrac2n(Y-XW)(X\\Delta W)+\\dfrac1n||X\\Delta W||_2^2-\\dfrac1n||Y-XW||_2^2\\\\ &= \\dfrac2n(XW-Y)X\\Delta W+\\mathcal{O}(||\\Delta X||)\\\\ \\end{align}令 L(W) = \\dfrac2n(XW-Y)X\\Delta W为 \\(E(W)\\) 在 \\(W\\) 处的导数，同时 \\begin{align} L(\\Delta W) &= \\\\ &= \\\\ &= \\dfrac2n(XW-Y)X\\Delta W\\\\ \\end{align}则 \\begin{align} \\nabla E(W) = \\dfrac2nX^T(XW-Y) &= 0\\\\ X^TXW &= X^TY\\\\ W &= (X^TX)^{-1}X^TY \\end{align}最终得 E=\\dfrac1n||Y-\\hat{Y}||_2^2=\\dfrac1n||X(X^TX)^{-1}X^TY-Y||_2^2","categories":[],"tags":[{"name":"算法 线性代数 粒子群优化","slug":"算法-线性代数-粒子群优化","permalink":"http://cycoe.cc/tags/算法-线性代数-粒子群优化/"}]},{"title":"Nocturnal使用说明","slug":"Nocturnal使用说明","date":"2018-09-05T16:00:00.000Z","updated":"2018-10-24T14:57:48.631Z","comments":true,"path":"2018/09/06/Nocturnal使用说明/","link":"","permalink":"http://cycoe.cc/2018/09/06/Nocturnal使用说明/","excerpt":"","text":"Nocturnal by CycoeGitHub 地址如果在使用过程中发现 bug，可到此处进行反馈，或者直接提交修复 PR，感谢支持！ 声明Nocturnal 是我课余时间练习 python 代码编写的程序，针对使用引起的一切后果本人概不负责。 关于捐赠Nocturnal 不并强制要求捐赠，但为了防止软件被滥用而出现的一系列问题，因此需要提供解密密钥才能使用，具体操作如下： 打开软件，此时会自动弹出一个命令提示符窗口和一个二维码 微信扫描二维码添加我为好友 你能在命令提示符窗口上看到类似这样一段话 12你的 id 为 2160。请将 id 发给开发者获取解锁密钥请输入解密密钥: 将其中的 id 发给我，我会生成解密密钥 输入密钥后即可使用 （可选）如果你觉得这个软件给你带来了便利，你可以给开发者包个红包，建议 5 元 使用说明命令帮助 命令全称 缩写 描述 help h 打印帮助信息 emailLogin el 绑定通知邮箱 grade g 成绩抓取模式 report r 选报告模式 class c 选课模式 add a 添加待选课程名称 delete de 删除待选课程名称 list l 列出待选课程名称 donate d 捐赠 quit q 退出 以上表格第一列为命令的全称，第二列为命令的缩写，输入全称与缩写拥有同样的效果。 软件符号说明Nocturnal 使用字符界面（TUI）进行交互，双击 Nocturnal.exe 打开软件后可看到一个黑底白字的字符界面，这不是因为软件运行出错，而是 Nocturnal 本来就是这样的。现在你应该能在界面上看到一些表格，最上面的表格为 Nocturnal 的基本信息，中间的表格为使用帮助。在最下方你可以看到类似这样的提示符 [0] &gt;&gt;&gt;，该提示符表明此时你可以输入命令运行相关功能，[0] 中的数字表示后台正在运行的任务数量。 成绩抓取模式在 [0] &gt;&gt;&gt; 后输入 grade 或 g 回车即可运行成绩抓取功能。第一次使用时会自动提示你输入用户名和密码，也就是你的教务网学号和密码。运行成功后不会有提示，但 Nocturnal 就会在后台自动抓取成绩，并在出新成绩时自动通知。 选报告模式在 [0] &gt;&gt;&gt; 后输入 report 或 r 回车即可运行选报告模式，运行成功后 Nocturnal 会在后台自动抓取报告列表，并在有新报告放出时自动选报告，并通过邮件通知你。 选课模式选课模式与成绩抓取模式和选报告模式不同，选课模式需要在前台运行。选课模式通过匹配关键字实现，针对每门课程可以添加多个关键字。比如你想要选 ‘高分子研究方法’ 这门课，则可以在一级关键字后输入 ‘高分子研究方法’ 并回车。但一般课程会有多个时间开课，如果想要指定特定时间或特定老师的课程，则可在二级关键字后输入 ‘周一’ 或 ‘某某某老师’ 即可。Nocturnal 会首先检查一级关键字，如果一级关键字对应多个候选，那么会继续以二级关键字进行过滤，优先选择符合二级关键字的候选。但如果二级关键字过滤后没有可选课程，那么会返回一级关键字的候选列表，并随机选取一个候选作为最终选择。总而言之，Nocturnal 中的关键字列表并不是选课的唯一列表，而是一个优先列表，Nocturnal 会按关键字列表所给的优先顺序依照选取所有可选课程。 注意：选课模式还未经过测试，选课完成后务必登录教务网检查已选课程。 具体流程如下： 输入 a 回车添加需要选的课程名称，输入 a 后提示如下：123[0] &gt;&gt;&gt; aplease input 1th key&gt; &gt; 表示此时你可输入一级关键字，一般我们会将课程名称作为一级关键字，如此时你可输入 ‘高分子研究方法’ 回车添加一个关键字，完成后程序会提示你输入二级关键字如下：12345[0] &gt;&gt;&gt; aplease input 1th key&gt; 高分子研究方法please input 2th key&gt; 此时你可直接输入回车来结束关键字的输入（在输入任一关键字时，你都可通过直接回车来结束输入），或者输入 ‘周六’ 回车作为想要上课的时间。 重复以上步骤直至你输入了所有想要选的课程。 输入 l 查看已经输入的课程列表 输入 d 删除不想选的课程 邮件通知Nocturnal 目前只有通过邮箱一种方式对你进行通知，你可通过输入 el 来绑定邮箱，Nocturnal 会提示你一步一步进行操作。&lt;接收邮箱&gt;为你要接收通知的邮箱，建议使用 qq 邮箱，这样使用微信绑定 qq 邮箱后就可以的即时地收到邮件通知消息。&lt;发送邮箱&gt;可以使用任意邮箱，但发送邮箱需要输入密码。 为发送邮箱的主机地址，qq 邮箱对应的是 ‘smtp.qq.com’，163 邮箱对应 ‘smtp.163.com’，其他邮箱请自行百度。&lt;端口&gt; 默认值为 ‘25’（注意：使用端口 25 意味着不使用 SSL 加密，希望邮件加密的同学请自行百度）。每步输入过程中，提示符后括号中为原始值，如果你不希望更改原始值，直接回车即可。 更新日志Date: 2017-1-3Version: V4.0 Date: 2017-12-15Version: V3.1 [bug fix] 修复掉线后不能重新登录的问题 修复达到最大重试次数后不会自动停止的问题 [optimization] 重新登录时清理内存 简化代码结构 新增等待时的动画效果 完善自定义邮箱登录 Date: 2017-12-14Version: V3.0 [bug fix] 修复选报告时的崩溃问题 [optimization] 重磅更新！新增验证码自动识别，花了大力气才写出来，现在无需手动输入验证码登录 更新了选报告的入口，优化了休眠逻辑 命令行提示已汉化 优化邮件提醒，现在只会发送最新选到的报告列表 新增报告黑名单，选到的报告自动加入黑名单列表中，防止手动退了后又重复选上 新增捐赠入口，希望大家多多支持！ 打包成安装文件，不用再手动解压","categories":[{"name":"python","slug":"python","permalink":"http://cycoe.cc/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://cycoe.cc/tags/python/"}]},{"title":"Vim- 一款让我相见恨晚的编辑器","slug":"Vim-一款让我相见恨晚的编辑器","date":"2018-08-12T14:34:49.000Z","updated":"2018-08-19T14:51:46.790Z","comments":true,"path":"2018/08/12/Vim-一款让我相见恨晚的编辑器/","link":"","permalink":"http://cycoe.cc/2018/08/12/Vim-一款让我相见恨晚的编辑器/","excerpt":"","text":"Vim 简介 Vim is a greatly improved version of the good old UNIX editor Vi. Many new features have been added: multi-level undo, syntax highlighting, command line history, on-line help, spell checking, filename completion, block operations, script language, etc. There is also a Graphical User Interface (GUI) available. 以上关于 Vim 的描述来自 Vim 的官方 GitHub 仓库。Vim 是一款古老且强大的编辑器，从其诞生之日起到现在已经有二十多年的历史（比我的年龄都要大 orz）。很多人听说它的大名一般是因为它与 Emacs 并称编辑器之神与神之编辑器。为什么会有这样的名号？除了它们的功能极其强大之外，还因为它们极其难以上手。以下图片为网友戏称的常用编辑器的学习曲线。 即便如此，Vim 和 Emacs 仍流行到了现在，以至于后来经常能在各处看到的 Vimer（Vim 党）和 Emacser（Emacs 党）的编辑器之争，虽然有的时候可能只是类似于“php 是世界上最好的语言”之类的梗，但足以看出 Vim 确实非常强大，并且用上了就再也回不去了。 安装 VimVim 在所有的 Linux 发行版上都易于获得，只需要使用对应的包管理器进行安装即可，Windows 上也有编译好的二进制包，但实际在安装过程中仍会面临几个选择。 以 Archlinux 为例，Archlinux 的官方仓库中包含的 Vim 在编译过程中并没有编译进 python、lua 等支持，导致很多插件无法使用，因此为了能使用上 Vim 的完全体，可以选择 Gvim。Gvim 是基于 Vim 的一个带有图形界面的版本，并在编译过程中包含进了所有可用组件。如果选择 Vim 分支，强烈建议使用 Gvim，并且使用 8.0 之后的版本。下载链接在此处。 另一个可供选择的版本是 Neovim，Neovim 是 Vim 的一个 fork 版本，比 Vim 具有更多的特性（Neovim 先首先支持的异步架构和内置 terminal，随后 Vim 也提供了支持），目前开发活跃，推荐进行尝试。下载链接在此处。 以上的所有版本在下文中都将统一称为 ‘Vim’（虽然事实上 Vim 与 Neovim 并不是同一个项目，但在配置和使用方法上是类似的）。无论安装哪个版本，安装完成后从应用启动菜单或命令行应该就能成功启动。恭喜你！此时已经完成了安装 Vim 的第一步，现在你看到的是一个黑底白字的字符界面。不过别着急，接下来我们会一步一步将 Vim 配置成称手的编辑器。 退出 Vim - 使用 Vim 的第一大难题？虽然客观上讲，退出 Vim 相较于 Vim 其他功能要容易的多，但是确实是第一次使用 Vim 会遇到的一个问题。相对于其他的编辑器，Vim 没有直观的退出方式，以至于在 Stack Overflow 上有个专门的问题（见此处）解答如何退出 Vim。甚至有了如下的梗： 看来确实有必要对 Vim 的退出方式做个总结，之列出平常最常用的几种退出方式 :q 正常退出 :q! 强制退出不保存 :wq 保存并退出 :x 保存并退出，与 :wq 不同之处在于如果文件未做修改则不更新时间戳 强制关机 使用 Vim 前先看帮助文档安装好 Vim 后，你可能想要马上尝试输入。但我强烈建议先阅读软件自带的帮助文档，一款优秀的软件都会带有一个详细的用户手册以及一个简要的使用说明，这有助于降低你在接触新软件时的痛苦感。你可以在 Vim 中随时通过输入 :help&lt;CR&gt;（ 代表回车）来呼出帮助文档。 配置 Vim - 从 .vimrc 开始由于 Vim 的流行，GitHub 上有各种各样现成的 ‘vimrc’（Vim 的配置文件）可供使用。对于不想自己折腾配置的用户来说，从 GitHub 上下载安装其他用户已经编辑好的 ‘vimrc’ 是最好的选择。甚至还有像 SpaceVim 这样的模块化 Vim 配置可以一键安装使用，能大大减少配置所需的时间。 另一些用户可能想要继续对 Vim 进行自定义配置，那么就需要对 ‘vimrc’ 进行修改。在 Linux 系统中，Gvim 与 Vim 的配置文件默认存放在 ‘$HOME/.vimrc’（Neovim 存放在 ‘$HOME/.config/nvim/init.vim’），Windows 下存放在 ‘$VIM/vimrc’。 你可以选择自己新建一个文件从头开始。不过还是建议拷贝官方自带的配置示例，一方面可以省去一部分对常规配置的修改时间，另一方面，官方示例中对各配置语句对应有详细的注释。或者也可以选择从 GitHub 上寻找一个适合你的 ‘vimrc’，或者参考我的配置。 常规配置在使用 Vim 之前，我们需要对其进行一些常规配置，来使它看起来更像一般的编辑器（以下步骤默认了你已经学会 Vim 的基本操作，包括移动光标、输入、模式切换等）。 首先，通过输入 :e $HOME/.vimrc&lt;CR&gt; 打开配置文件（’$HOME/.vimrc’ 替换为你平台对应的配置文件路径）。这时，如果此前你已经拷贝了 Vim 的示例配置文件，或者是从网上下载安装了其他人的配置，那么你打开的文件里应该就有那些内容，如果此前还未做过配置，那么打开的就是一个空文件。 接下来可以选择下面的配置中你需要的部分拷贝进你的 ‘vimrc’ 123456789101112131415161718192021222324252627282930\" about vim setupset nocompatible \" disable compatible for viset shell=/bin/bash \" setup default shellset shortmess=at \" 启动时隐去援助提示set mouse=a \" active mouse controlset clipboard+=unnamed \" support system clipboardlet mapleader=';' \" remap &lt;leader&gt;\" display setupset relativenumber \" display relative row numberset ruler \" 显示标尺，就是在右下角显示光标位置set spell spelllang=en_us,cjk \" Spell checking for English, escape Chineseset langmenu=zh_CN.UTF-8set helplang=cn \" 设置帮助文档为中文，需要 'yianwillis/vimcdoc'syntax enable \" syntax highlight enablesyntax on \" syntax highlight onset background=dark \" setup background colorcolorscheme gruvbox \" setup color schemeset wildmenu \" select the candidates in interactive wayset backspace=indent,eol,start \" more powerful backspacingset cursorcolumn \" 浅色高亮当前列set cursorline \" 浅色高亮当前行set novisualbell \" 关闭视觉响铃set laststatus=2 \" 启动显示状态行set showcmd \" show the command executed by shortcutsset noshowmode \" don't show the mode status, avoid override argvs hintset hlsearch \" highlight for searched resultsset incsearch \" highlight for searching resultsset showmatch \" show the match of brackets and Quotation markset ignorecase \" ignore case when searching and command completionset gdefault \" default substitute in the whole line 其中，最重要的一条设置就是 set nocompatible，它的作用是关闭对 Vi 的兼容性。Vi 是一款更加古老的编辑器，可视作是 Vim 的前身。如果保留对 Vi 的兼容性也就意味着你放弃了很多 Vim 独有的特性。set shell=/bin/bash 显式地声明了 Vim 在运行脚本时调用的解释器，如果是 Windows 用户则需要去掉这行。 此时保存配置文件并通过 :so \\$HOME/.vimrc&lt;CR&gt; 重载配置后应该就能看到改变了。但此时你可能会注意到几条错误信息，不要紧张，这是因为我们在配置中引用了一些插件功能，但事实上我们现在还未安装插件，安装插件后你会看到错误就消失了。 安装插件管理器 - 管理插件的插件Vim 有非常多的插件管理器可以使用，除去功能上的细微差异，我们可以将所有插件管理器分为异步型和同步型。可以简单地理解为异步型可以同时下载安装多个插件，而同步型一次只能处理一个。在 Vim 7.4 版本出来之前，插件管理器都是同步型的，包括大名鼎鼎的 Vundle。 在我刚开始使用 Vim 的时候，Vim 和 Neovim 都已经支持异步架构，但由于当时查的是中文资料，很多都是非常老的文章。基本上所有文章都推荐使用 Vundle 作为插件管理器，事实上在你用过 vim-plug 之类的异步插件管理器后，你会无法再忍受 Vundle 的速度。这告诉我们技术型的文章还是要去 Google… 不会有人再去使用 Vim 7.4 之前的版本了，所以这里我推荐使用 vim-plug 作为插件管理器。vim-plug 的优点是异步下载安装、插件更新方便、支持插件按需加载，并且只包含一个文件。它的 GitHub 仓库上有详细的安装教程。 安装插件 - 本体不够再打 mod虽然 Vim 并不是扩展性最好的编辑器，但它仍支持成千上万个插件。寻找插件最好的途径是 GitHub 和 Vim Scripts。以下是我使用的插件列表： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960let g:python3_host_prog = \"/usr/bin/python3\"call plug#begin('~/.vim/plugged')Plug 'tomasr/molokai' \" molokai color schemePlug 'morhetz/gruvbox' \" gruvbox colorscheme themePlug 'mhinz/vim-startify' \" an awesome startup screenPlug 'vim-scripts/fcitx.vim' \" auto switch fcitx statusPlug 'manu-mannattil/vim-sdcv' \" a simple dictionary for vimPlug 'vim-airline/vim-airline' \" add status linePlug 'scrooloose/nerdtree', &#123; 'on': 'NERDTreeToggle' &#125; \" directory treePlug 'majutsushi/tagbar', &#123; 'on': 'TagbarToggle' &#125; \" Class structure viewer, need ctags installedPlug 'mbbill/undotree', &#123; 'on': 'UndotreeToggle' &#125; \" undo tree managerPlug 'tpope/vim-fugitive' \" git supportPlug 'junegunn/gv.vim' \" view git commits in VimPlug 'junegunn/fzf', &#123; 'dir': '~/.fzf', 'do': './install --all' &#125; \" fuzzy file searcherPlug 'junegunn/fzf.vim' \" provide many other search functionsPlug 'tpope/vim-commentary' \" a better comment toolPlug 'vim-scripts/EasyMotion' \" enhance default motionsPlug 'Yggdroot/indentLine' \" indent line indicatorPlug 'jiangmiao/auto-pairs' \" auto add pairsPlug 'junegunn/rainbow_parentheses.vim' \" a much simpler-using fork of abovePlug 'junegunn/limelight.vim' \" dim othersPlug 'junegunn/goyo.vim' \" provide a dim writing environmentPlug 'w0rp/ale' \" syntax error checkPlug 'Valloric/YouCompleteMe', \" auto complete \\&#123; 'do': './install.py --clang-completer' &#125;Plug 'SirVer/ultisnips' \" auto complete stringPlug 'honza/vim-snippets' \" complete rules for ultisnipsPlug 'junegunn/vim-easy-align' \" align toolPlug 'godlygeek/tabular' \" advanced align toolPlug 'gabrielelana/vim-markdown', &#123; 'for': 'markdown' &#125; \" markdown pluginPlug 'joker1007/vim-markdown-quote-syntax', &#123; 'for': 'markdown' &#125; \" syntax highlight for quoted codePlug 'iamcco/mathjax-support-for-mkdp', &#123; 'for': 'markdown' &#125; \" mathjax support for markdown previewPlug 'iamcco/markdown-preview.vim', &#123; 'for': 'markdown' &#125; \" markdown preview supportPlug 'vim-scripts/indentpython.vim', &#123; 'for': 'python' &#125; \" auto indent for pythonPlug 'nvie/vim-flake8', &#123; 'for': 'python' &#125; \" flake8 style code check, need install flake8\" 这两个插件被 neoformat 替代了\" Plug 'tell-k/vim-autopep8', &#123; 'for': 'python' &#125; \" a python code format tool wrapper for autopep8\" Plug 'fisadev/vim-isort', &#123; 'for': 'python' &#125; \" imports sorter for pythonPlug 'vim-latex/vim-latex', &#123; 'for': 'tex' &#125; \" latex edit environmentPlug 'skywind3000/asyncrun.vim' \" AsyncRun pluginPlug 'hotoo/pangu.vim' \" Chinese text formatPlug 'vimwiki/vimwiki' \" write wiki in vimPlug 'yianwillis/vimcdoc' \" a Chinese help handbook for VimPlug 'sbdchd/neoformat' \" a collection of format toolsPlug 'ludovicchabant/vim-gutentags' \" generate tags for projectPlug 'mhinz/vim-signify' \" show file modifying status for gitPlug 'Shougo/echodoc.vim' \" show argvs hint on the command line\"======================\"\" text object 全家桶 \"\"======================\"Plug 'kana/vim-textobj-user' \" 用户自定义 text objectPlug 'kana/vim-textobj-indent' \" 缩进对象，关键字 &lt;i&gt;Plug 'kana/vim-textobj-syntax' \" 语法对象Plug 'kana/vim-textobj-function', &#123; 'for':['c', 'cpp', 'vim', 'java'] &#125; \" 函数对象，关键字 &lt;f&gt;Plug 'sgur/vim-textobj-parameter' \" 参数对象，关键字 &lt;,&gt;Plug 'coderifous/textobj-word-column.vim' \" 列对象，关键字 &lt;c&gt;Plug 'bps/vim-textobj-python' \" python 对象合集，&lt;c&gt; 类，&lt;f&gt; 函数Plug 'tpope/vim-surround' \" deal with surround for text objectcall plug#end()filetype plugin indent on 由于 vim-plug 的强大，我们只需要将上述配置粘贴进 vimrc 中，重载配置文件后运行 :PlugInstall&lt;CR&gt; 就会自动安装所有插件，甚至 vim-plug 会帮我们做好安装后的处理。 必装插件配置 - 大大提高生产力通过 vim-plug 安装的插件大部分都是即装即用的，但也包括小部分需要在安装完成后进行一定的配置才能舒适地使用。 YouCompleteMe - 最强补全神器YouCompleteMe 是谷歌程序员 Valloric 开发的一款智能补全插件。在 YouCompleteMe 出来之前，大部分补全插件都是基于 tag 分析，也就是从当前文件以及其他 buffer 中的文件文本中匹配类似字符串进行补全，说白了就是靠猜。而 YouCompleteMe 是真正支持程序语义分析的补全，能够理解程序语言进行补全，准确率大大提高，并且体验也提升了很多。 盗用 YouCompleteMe 官方仓库上的一张效果图 虽然 YouCompleteMe 效果看起来很炫酷，但它也被称为“最难安装的插件”。它的底层是用 C++ 写成的，为了能作为 Vim 的插件，外层又用 Python 做了封装，因此它也是最复杂的插件。Plug &#39;Valloric/YouCompleteMe&#39;, { &#39;do&#39;: &#39;./install.py --clang-completer&#39; } 命令要求 vim-plug 将 YouCompleteMe 插件下载下来后自动编译，但如果你的终端上缺少编译的依赖会导致编译失败，此时我们需要手动进行编译。 在 Linux 下进行安装会相对比较容易，在编译之前你需要但不限于以下工具： cmake automake python3-dev（python2 或 python3） 之后运行 cd ~/.vim/plugged/YouCompleteMe/ 进入 YouCompleteMe 的安装目录，运行 ./install.py --clang-completer 进行安装，如果不需要 C 语言补全支持的话无需 --clang-completer 选项。安装程序会自动下载 libclang 依赖，等待安装完成即可。Windows 的安装过程大部分相似，可参考 YouCompleteMe 的官方仓库文档。 再次使用 Vim 打开一个 Python 或 cpp 文件应该就能自动补全了。但接下来你会发现 YouCompleteMe 弹出的补全菜单里只会包括前面你输入过的关键字，并没有进行语义识别，那不是和自带的 omni 补全没区别！还浪费我这么长时间安装！其实之前我也是这么想的，直到有一天我看到这篇文章，我才发现原来我一直用的是半残的 YouCompleteMe，根本没发挥出它真正的实力。通过如下配置就能使 YouCompleteMe 的补全策略更贴近于常见的 IDE。 12345678910111213141516171819202122set completeopt=longest,menu \" YCM 的提示方式，previews 会显示具体预览窗口，menu 不提示\" let g:ycm_add_preview_to_completeopt = 0let g:ycm_collect_identifiers_from_tags_files=1 \" 使用 ctags 生成的 tags 文件let g:ycm_min_num_of_chars_for_completion=2 \" 从第 2 个键入字符就开始罗列匹配项let g:ycm_seed_identifiers_with_syntax=1 \" 语法关键字补全let g:ycm_cache_omnifunc=1 \" 禁止缓存匹配项,每次都重新生成匹配项let g:ycm_complete_in_comments = 1 \" 在注释输入中也能补全let g:ycm_complete_in_strings = 1 \" 在字符串输入中也能补全let g:ycm_collect_identifiers_from_comments_and_strings = 1 \" 注释和字符串中的文字也会被收入补全let g:ycm_python_binary_path = '/usr/bin/python' \" set default python binarylet g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py' \" set global ycm extra config pathlet g:ycm_confirm_extra_conf = 0 \" confirm for config filelet g:ycm_use_ultisnips_completer=1 \" 查询 ultisnips 提供的代码模板补全let g:ycm_key_invoke_completion = '&lt;c-z&gt;' \" 手动触发补全的按键\" 使 YCM 能在输入两个字母的时候自动基于语义补全let g:ycm_semantic_triggers = &#123; \\ 'c,cpp,python,java,go,erlang,perl': ['re!\\w&#123;2&#125;'], \\ 'cs,lua,javascript': ['re!\\w&#123;2&#125;'], \\ &#125;nnoremap &lt;leader&gt;d :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt; \" goto definitionautocmd InsertLeave * if pumvisible() == 0|pclose|endif \" 离开插入模式后自动关闭预览窗口autocmd VimEnter * EchoDocEnable ALE - 第二好的异步语法检查工具ALE 是一款非常强大的异步语法检查工具。在 Vim 支持异步之前，最好的语法检查工具是 Syntastic，但由于它非异步的工作方式，导致语法检查会阻塞主线程，使用体验比较差。在新版 Vim 中，都会推荐 ALE 或其他支持异步的语法检查工具。事实上 ALE 并不仅仅是一款语法检查工具，它是包括了语法检查、代码风格格式化、自动补全功能的工具集。 ALE 安装完成后，随意打开一个代码文件。如果语法存在错误，那么在窗口的最左侧会显示一列符号，包括 ‘&gt;&gt;’ 或 ‘—‘。将光标移至有标记的行，在最下方的 statusline 中会显示错误的具体信息。 123456789101112131415161718192021\" let g:ale_set_loclist = 0 \" show the lint as a dot on left of a line\" let g:ale_set_quickfix = 1 \" show the lint in quickfix list\" let g:ale_open_list = 1 \" show quickfix window to show error message\" let g:ale_keep_list_window_open = 1 \" keep quickfix window show whether errors exist\" let g:ale_sign_column_always = 1 \" 保持左侧边栏始终可见nmap &lt;silent&gt; &lt;C-k&gt; &lt;Plug&gt;(ale_previous_wrap)nmap &lt;silent&gt; &lt;C-j&gt; &lt;Plug&gt;(ale_next_wrap)\" Check Python files with flake8 and pylint.\" let b:ale_linters = ['flake8', 'pylint']\" set fixers for different file typeslet b:ale_fixers = &#123; \\ 'python': ['isort', 'autopep8'], \\ 'cpp': ['clang-format'], \\ 'markdown': ['prettier']&#125;\" let g:ale_linters_explicit = 1let g:ale_completion_delay = 500 \" 补全的延迟let g:ale_echo_delay = 20 \" 回显的延迟let g:ale_lint_delay = 500 \" 停止输入后更新 lint 标记的延迟let g:ale_echo_msg_format = '[%linter%] &lt;%code&gt; %%s' \" 自定义 lint 输出格式let g:ale_lint_on_text_changed = 'normal' \" 当文字在 NORMAL 模式下发生更改的时候更新 lint，防止 YCM 频繁刷新let g:ale_lint_on_insert_leave = 1 \" 离开 INSERT 模式时更新 lint 将错误信息表示在左侧只是一种方式，你也可以通过反注释前 4 行，利用 Vim 自带的 quickfix 窗口显示错误信息。虽然通过这种方式你能够更清晰的了解各个错误的具体信息，但需要占用一部分宝贵的屏幕空间。 11 至 14 行设置了 ALE 的默认格式化工具，ALE 本身并不对代码进行格式化，而是针对不同文件类型调用合适的格式化工具进行处理（ALE 支持的格式化工具列表可参照官方仓库）。其中 isort、autopep8、prettier 都是 Python 编写的命令行工具，clang-format 是 clang 编译器带的 C++ 格式化工具。 20、21 行是针对 YCM 做的额外配置，据悉可以解决 YCM 补全菜单频繁刷新的问题。","categories":[],"tags":[{"name":"Vim, Linux","slug":"Vim-Linux","permalink":"http://cycoe.cc/tags/Vim-Linux/"}]},{"title":"convert format of documents with pandoc","slug":"convert-format-of-documents-with-pandoc","date":"2018-06-29T06:33:48.000Z","updated":"2018-06-29T06:37:01.943Z","comments":true,"path":"2018/06/29/convert-format-of-documents-with-pandoc/","link":"","permalink":"http://cycoe.cc/2018/06/29/convert-format-of-documents-with-pandoc/","excerpt":"","text":"Pandoc 是一个强大的文档格式转换软件，可以对 html、markdown、ppt、doc、pdf 等多种格式进行相互转换，但在将 markdown 文件转换为 pdf 文件的过程中，发现会出现中文编码的问题，因此需要使用如下命令指定渲染的引擎 pandoc -f markdown_github my.md -o my.pdf --pdf-engine=xelatex -V mainfont=&quot;Your Font&quot;","categories":[],"tags":[]},{"title":"Spawn your blog site with hexo","slug":"Spawn-your-blog-site-with-hexo","date":"2018-04-14T05:50:18.000Z","updated":"2018-10-24T15:26:54.218Z","comments":true,"path":"2018/04/14/Spawn-your-blog-site-with-hexo/","link":"","permalink":"http://cycoe.cc/2018/04/14/Spawn-your-blog-site-with-hexo/","excerpt":"","text":"最近，由於 GitHub 在國內的訪問越來越不穩定，我決定將博客遷移至 Coding（一個國內的代碼託管平臺）。Coding 與 GitHub 類似的可以直接展示靜態的個人主頁，整個配置流程與 GitHub 類似。但是之前使用的是 Jekyll 博客生成器進行構建，Jekyll 的優點是可以直接將代碼 Push 上去，GitHub 可以直接根據 Jekyll 格式的目錄進行部署，無需本地的部署環境，但是由於 Ruby 的性能問題，整個部署過程需要至少幾分鐘，因此尋求其他的生成器解決辦法。後來瞭解到 Hexo，一個由 NodeJS 驅動的博客生成器，於是決定趁遷移嘗試一下。 環境安裝安裝 NodeJSHexo 既然是由 NodeJS 驅動的，那必然 NodeJS 環境是必不可少，另外爲了更方便地管理第三方庫，還需要安裝 npm 管理器。對於我使用的 ArchLinux 爲例，只需要運行以下命令即可完成安裝。 $ sudo pacman -S nodejs npm 安裝 hexo 先創建一個文件夾用於存放博客的資源文件，然後 cd 到該目錄下 安裝 hexo：sudo npm install hexo -g 安裝完成後通過 hexo -v 查看版本 通過 hexo init 將本目錄初始化爲博客的根目錄，可以看到目錄下自動生成了一些文件 各文件解釋如下： node_modules：依賴包 public：存放構建生成的頁面 scaffolds：命令生成文章等的模板 source：用命令創建的各種文章 themes：主題目錄 _config.yml：整個博客的配置 db.json：source 解析得到的信息 package.json：項目所需模塊的配置信息 開始寫博客可以选择 typora 或者其他的 Markdown 编辑器进行编辑，此处我选择了 vim 进行文件编辑。要想要 vim 支持 Markdown 的语法高亮需要以下几个插件 Plugin ‘godlygeek/tabular’ Plugin ‘gabrielelana/vim-markdown’ 部署博客hexo 可以用 $ hexo d -g 命令方便的对博客系统进行部署，但首先需要在博客配置文件 _config.yml 的 Deployment 节中做配置1234deploy: type: git # 此处是部署的方式 repo: # 此处是所有需要部署的仓库，仓库的设置与 Jekyll 类似 coding: git@git.coding.net:cycoe/cycoe.git 然后在 Coding 上新建一个名为 cycoe 的空仓库（由于 Coding 本身的限制，该仓库应与用户名同名），在本机的博客根目录运行 hexo d -g 即可将博客部署至 Coding。然后打开仓库设置，将此仓库设置为 Coding Pages 即可。 2018-06-05 更新最近 Coding 不知是怎么了，我的博客总是打不开。凑巧最近刚租了个包月的服务器，于是决定将整个博客迁移到自己的服务器上。 Hexo 和 Jekyll 博客系统的部署原理不太一样，$ hexo g 是 $ hexo generate 的缩写，其原理是在本地使用 Hexo 引擎将 _posts 目录的 Markdown 文件生成网页结构，结果保存在 public 目录下，可直接由 Apache 或 Nginx 驱动。 而 $ hexo deploy 正是将 public 目录下的网页部署到 Git 仓库中。因此如果能将仓库克隆到服务器上进行部署，那么问题就能解决。 在服务器上建立 Git 仓库初始化 Git 仓库$ sudo git init --bare sample.git Git 就会创建一个裸仓库，即会在当前路径下创建一个名为 sample.git 的仓库。裸仓库没有工作区，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的 Git 仓库通常都以 .git 结尾。然后，把 owner 改为服务器的用户名，不然没有权限将修改写入该仓库。 $ sudo chown -R ubuntu:ubuntu sample.git 将仓库加到 Hexo 的配置文件12345deploy: type: git repo: #coding: git@git.coding.net:cycoe/cycoe.git my_server: ubuntu@139.199.95.151:/home/ubuntu/git/blog.git 此处 @ 前的用户名一定要与服务器仓库的权限对应，: 后面是仓库的绝对路径。 部署此时运行 $ hexo d- g 即可将博客网页目录部署到仓库，但此时查看仓库会发现目录下并不是网页的结构，因为这个仓库是裸仓库，下面并没有工作区，所以看到的并不是我们 Push 上来的内容。 Git Hook 事件事实上，如果我们此时将该仓库克隆到另一个目录下就可以看到工作区了。首先 cd 到需要保存网页的路径下 $ cd /home/ubuntu/www/，然后运行 $ git clone /home/ubuntu/git/blog.git 将仓库克隆至当前路径。 但是如果每次都要登上服务器手动克隆就违背我们自动化部署的初衷了。因此此处需要用到 Git 自带的 Hook 功能，简单来将讲就是在仓库发生变化前/后所要执行的操作。 Hook 的事件放在裸仓库目录的 hooks 文件夹下，这里我们新建一个名为 post-receive 的事件，该事件是在仓库更新合并完成后自动运行，文件中加入如下内容 12345#!/bin/bashcd /home/ubuntu/www/blog # cd 到网页的展示仓库unset GIT_DIR # 非常重要！如果不解绑 GIT_DIR 环境变量无法切换路径git config --listgit pull origin master 运行 $ chmod +x post-receive 赋予执行权限 此时再在本机运行 $ hexo d -g 发现网页目录也自动更新了 2018-08-18 更新今天写了一篇博客，运行 $ hexo d -g 想要更新博客，结果发现网页并没有变化。登上服务器一看 /home/ubuntu/git/blog.git 仓库已经更新了，怀疑是更新后没有成功运行 post-receive。但是自从上次设置好 post-receive 后就没有改过，按理说应该能够运行。运行 $ ls -l 命令后发现，/home/ubuntu/git/blog.git 目录的归属者是 ubuntu，而 /home/ubuntu/www/blog 目录的归属者是 nginx，应该是上次我在设置 nginx 的时候不小心把 /home/ubuntu/www 目录递归修改成归属 nginx 了。而 post-receive 所做的工作实际上是在我把更新 push 到 /home/ubuntu/git/blog.git 仓库后，cd 到了 /home/ubuntu/www/blog 目录并拉取更新。因此我是以 ubuntu 用户的身份做的 push，又是以 ubuntu 用户的身份运行的 post-receive，因此在 /home/ubuntu/www/blog 目录中是没有权限拉取更新的。 既然已经发现了问题出在用户权限上。那就可以通过运行 $ sudo chown -R ubuntu:users /home/ubuntu/www 将整个目录都改为 ubuntu 所属，也就不关 nginx 用户什么事了，这样确实非常方便的解决了这个问题。另外 post-receive 在更改用户归属后执行权限丢失了，记得运行 $ chmod +x post-receive 重新赋予执行权限。事实上当初建立 nginx 用户也是因为安装了 nginx 服务，想要弄得更规范些。但因为懒一直没给 nginx 建立自己的 Home 目录，按理说把跟 nginx 相关的目录都扔到 nginx 用户对应的 Home 下是最好的。 2018-10-24 更新最近写的新博客中需要开启 LaTeX 公式支持，但 hexo 本身对数学公式的支持有些问题，Hexo 默认使用 “hexo-renderer-marked” 引擎渲染网页，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签，比如在 markdown 语法中，下划线 ‘_’ 代表斜体，会被渲染引擎处理为 标签。 解决方法更换 Hexo 的 markdown 渲染引擎，使用 ‘hexo-renderer-kramed’ 引擎替代 ‘hexo-renderer-marked’ 引擎，前者在后者的基础上修复了一些 bug。执行以下命令卸载原引擎并安装新引擎。12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 此时行间公式应该就可以正常渲染了，但行内公式还是有问题。接下来在博客根目录中，找到 node_modules\\kramed\\lib\\rules\\inline.js，修改 11 行的 escape 变量的值。12// escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/,escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, 这一步是在原基础上取消了对 ‘\\, {, }’ 的转义(escape)。同时把第 20 行的 em 变量也要做相应的修改。12// em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 然后运行 hexo clean 清除构建，再 generate 即可解决问题。 在主题中开启 mathjax 开关打开 themes/next/_config.yml，将 math 的 enable 设为 true，将 per_page 设为 true，表示针对每页单独决定是否开启 mathjax 支持。1234567math: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has &apos;mathjax: true&apos; in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: true 因为 per_page 设为 true，因此需要在文章的 Front-matter 里打开 mathjax 开关。1234567---title: Spawn your blog site with hexodate: 2018-04-14 13:50:18categories: linuxtag: hexomathjax: true---","categories":[{"name":"linux","slug":"linux","permalink":"http://cycoe.cc/categories/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://cycoe.cc/tags/hexo/"}]},{"title":"Planche training calendar","slug":"Planche-training-calendar","date":"2018-04-12T16:00:00.000Z","updated":"2018-07-25T08:12:09.665Z","comments":true,"path":"2018/04/13/Planche-training-calendar/","link":"","permalink":"http://cycoe.cc/2018/04/13/Planche-training-calendar/","excerpt":"","text":"A planche is a skill in gymnastics in which the body is held parallel to the ground, giving the illusion of floating. It is a move that requires significant strength and balance. 刚进大学的时候 ，无意间在 B 站看到一个关于俄挺的视频，能够完成俄挺成了我的一个梦想。本科的时候陆陆续续地练过一段时间，练练俯卧撑和团身，团身也就是刚刚高团 2-3 秒的程度。后来因为实在没什么进展也就渐渐放弃了。前几天回家的路上吹了点小风就感冒了，意识到自己的小身板太弱，再加上最近想要增重，决定重新开始练习俄挺。 2018-04-05从今天开始练习，因为也好久没有做俯卧撑了，目前的水平实在太烂。 标准俯卧撑 10 个 冲肩维持 5 秒 2018-04-13练了一个星期的冲肩，每天都在坚持。 冲肩维持 10 秒 窄距俯卧撑 10 个 2018-06-10最近右手小臂疼的厉害，应该是跟前几天每天用鼠标做视频有关，看来要好好休息几天了，最近下调训练强度，少用鼠标。。不过值得激动的是，目前已经可以比较轻松地做团身了，高阶团身应该也能 10 来秒了，接下来准备练团身举腿。 冲肩维持 30 秒 窄距俯卧撑 25 个 冲肩俯卧撑 15 个 团身维持 10 秒 引体向上 7 个 2018-07-25最近一个月因为手腕一直还是有点疼，尤其搬重物的时候，也就没怎么敢继续练团身，转而练习引体和前水平。打算先通过前水平锻炼背部力量，通过双力臂锻炼手腕力量，等基础打好后再练习俄挺。引体的话其实应该一组能做个 10 个左右，但是后面几组做的时候因为可能是翻腕了的原因，导致手腕还是会疼，发现在云梯上练习就没事了，可能是手的朝向的问题。 双力臂其实还是没有太大进展，前水平的话一条腿伸直是能保持了，接下来就是要延长持续的时间，然后慢慢向双腿进步。在宿舍也可以每天都练前水平。 另外利用操场上的杠铃可以做很多其他的训练，比如正手抬、反手拉、单手拉、卧推。利用器材可以取得更好的训练效果。 最后有个非常重要的想法：在家的这几天发现，想要找个健身器材齐全的公园实在不是很容易，因此希望能做个 App，街健爱好者可以在上面共享健身器材所在的位置，另外可以认识附近的街健爱好者。 冲肩俯卧撑 20 个 前水平团身 10 秒 单杠硬拉 4 个 引体 10 个","categories":[{"name":"personal","slug":"personal","permalink":"http://cycoe.cc/categories/personal/"}],"tags":[{"name":"planche","slug":"planche","permalink":"http://cycoe.cc/tags/planche/"}]},{"title":"教务网现惊天大 bug？！谈谈弱密码如何暴露你的信息","slug":"教务网现惊天大bug","date":"2017-12-06T16:00:00.000Z","updated":"2018-04-13T03:38:23.955Z","comments":true,"path":"2017/12/07/教务网现惊天大bug/","link":"","permalink":"http://cycoe.cc/2017/12/07/教务网现惊天大bug/","excerpt":"","text":"漏洞发现最近在为之前写的爬虫做批注的时候发现了一段有趣的代码，代码如下123456789101112131415161718192021222324252627MisUtils.initAttempt()while MisUtils.descAttempt(): self.response = self.session.send(prepareBody) if self.response.status_code == 200: breakif not MisUtils.descAttempt(): Logger.log('Up to max attempts!', ['Maybe remote server unreachable'], level=Logger.error) return Falseif re.search('用户名不存在', self.response.text): print(Logger.log('No such a user!', ['Cleaning password file'], level=Logger.error)) reInput = Trueelif re.search('密码错误', self.response.text): print(Logger.log('Wrong password!', ['Cleaning password file'], level=Logger.error)) reInput = Trueelif re.search('请输入验证码', self.response.text): print(Logger.log('Please input vertify code!', ['Retrying...'], level=Logger.error))elif re.search('验证码错误', self.response.text): print(Logger.log('Wrong vertify code!', ['Retrying...'], level=Logger.error))else: print(Logger.log('Login successfully!', ['UserName: ' + MisUtils.confDict['userName']], level=Logger.error)) MisUtils.dumpConfFile() break 当时写的时候没注意，现在回过头来看看，惊奇地发现教务网对于用户名和密码的验证顺序是如下的优先级： 首先验证用户名是否存在 再验证密码是否正确 然后验证码是否为空 最后才是验证码是否正确 这。。。我只想说，谁写的验证逻辑。。。我要这验证码有何用？！！！ 漏洞验证接下来去教务网上验证一下整个验证逻辑是否如所想的那样 首先在用户名输入框中随意输入一串数字，并保持密码和验证码都为空，尝试登录发现弹出“用户名不存在”的 JS 脚本 再输入我正确的学号，仍保持密码和验证码都为空，尝试登录弹出“密码错误”的 JS 脚本 输入正确的学号和密码，并保持验证码为空，尝试登录弹出“请输入验证码”的 JS 脚本 输入正确的学号和密码，但是输入错误的验证码，尝试登录弹出“验证码错误”的 JS 脚本 通过以上流程，可以总结得以下两条有价值的信息： 当你输入的用户名不存在时，不管密码和验证码输的啥，总是会提示“用户名不存在”；当你输入的用户名存在，并且密码为空时，会提示“密码错误”。 当你输入的用户名存在，但是密码错误时，不管验证码输的啥，总会提示“密码错误”；当输入的密码正确并且验证码为空时，会提示“请输入验证码”。 漏洞利用通过上面的两条信息可以至少做到两件事情 枚举用户名目前所有在读研究生的入学时间大部分为 2013-2017 年，学号的前四位为入学年份，中间三位与所在的专业有关，最后三位为流水号。对所有形如 2013XXXXXX 的学号进行尝试登录，根据信息 1，能够枚举出所有 13 年入学的学生学号。 暴破利用上一步得到的用户名列表，再配合字典就可以进行在线的密码暴破，这种破解方法一般来说是非常低效的，严重依赖于网络状况和服务器的机能。尝试发现在单线程的情况下，每秒只能对服务器进行 1k 次左右的访问。也就是说如果使用 16 位的数字加字母作为密码，最多需要 2.5 百万亿年的时间才能成功破解。看起来是非常安全吧。然而实际情况又是什么样呢？教务网的初始密码为身份证号中的生日，一般来说我们在第一次登录时都会改密码，但还总会有人抱着侥幸的心理用初始密码，这就为暴破带来了捷径。以生日作为密码具有非常明显的结构，如 2017 年入学学生的生日大多在 1994-1996 之间，利用下面简单的字典生成器可得到 1994-1996 年所有的日期列表：12345678910111213141516171819202122232425262728293031big_month_ = [1, 3, 5, 7, 8, 10, 12]small_month_ = [4, 6, 9, 11]def gen_(begin, end): password_ = [] for year in range(begin, end + 1): for month in range(1, 13): if month in big_month_: month_len = 31 elif month in small_month_: month_len = 30 elif month == 2: if year % 4 != 0 or (year % 100 == 0 and year % 400 != 0): month_len = 28 else: month_len = 29 else: month_len = 31 for day in range(1, month_len + 1): password_.append(str(year) + str(month).zfill(2) + str(day).zfill(2)) with open('password.dict', 'w') as fr: for password in password_: fr.write(password) fr.write('\\n')def main(): gen_(1994, 1996) 利用得到的用户名列表和密码字典就可以对所有未修改的用户密码进行暴破。 总结最后结果怎么样？使用 100 个线程，并设置单个线程的访问频率为 1 次/秒进行暴破，10 分钟破解出了接近 40 个用户密码！并且平均每四个人里就有一个人没有修改密码！可能很多人会觉得教务网密码不涉及钱财也就不那么在意。但其实教务网上有详细的个人资料，包括你的姓名、照片和家庭住址。另外还有你的课表，你某时某刻会在哪个教室出现都会被人知道啊！所以，弱密码的危害显而易见，很多的信息泄漏也都是由弱密码引起的。给自己换个复杂点的密码吧，毕竟密码这种东西一寸长一寸强。现在也快到年底了，骗子也要赚钱备年货了，希望大家能够保护好自己的信息，不要给骗子可乘之机。最后讨伐一下这个软件提供商，一个商业化的系统里面竟然有如此明显的逻辑漏洞，只希望快点被修复吧。","categories":[{"name":"python","slug":"python","permalink":"http://cycoe.cc/categories/python/"},{"name":"spider","slug":"python/spider","permalink":"http://cycoe.cc/categories/python/spider/"},{"name":"sploit","slug":"python/spider/sploit","permalink":"http://cycoe.cc/categories/python/spider/sploit/"}],"tags":[]},{"title":"如何提高抢到报告的概率？","slug":"如何提高抢到报告的概率","date":"2017-11-02T16:00:00.000Z","updated":"2018-04-13T03:38:07.109Z","comments":true,"path":"2017/11/03/如何提高抢到报告的概率/","link":"","permalink":"http://cycoe.cc/2017/11/03/如何提高抢到报告的概率/","excerpt":"","text":"#right-panel { background-color: #fff; } #right-panel .cover-top { background: linear-gradient(to bottom, #fff 50%, transparent); } #cover-bottom #cover-bottom-background-right { background: #fff; } @font-face { font-family: octicons-link; src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff'); } #container { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; color: #373737; font-family: \"Roboto\", \"Noto Sans\", \"Ubuntu\", \"Helvetica Neue\", Helvetica, \"Segoe UI\", Arial, sans-serif, \"Noto Sans CJK SC\", \"Source Han Sans SC\", \"Microsoft Yahei\"; font-size: 14px; line-height: 2; word-wrap: break-word; background-color: #fff; } #container a { background-color: transparent; -webkit-text-decoration-skip: objects; } #container a:active, #container a:hover { outline-width: 0; } #container strong { font-weight: inherit; } #container strong { font-weight: bolder; } #container h1 { font-size: 2em; margin: 0.67em 0; } #container img { border-style: none; } #container svg:not(:root) { overflow: hidden; } #container code, #container kbd, #container pre { font-family: \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; font-size: 1em; } #container hr { box-sizing: content-box; height: 0; overflow: visible; } #container input { font: inherit; margin: 0; } #container input { overflow: visible; } #container button:-moz-focusring, #container [type=\"button\"]:-moz-focusring, #container [type=\"reset\"]:-moz-focusring, #container [type=\"submit\"]:-moz-focusring { outline: 1px dotted ButtonText; } #container [type=\"checkbox\"] { box-sizing: border-box; padding: 0; } #container table { border-spacing: 0; border-collapse: collapse; } #container td, #container th { padding: 0; } #container * { box-sizing: border-box; } #container input { font: 13px/1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; } #container a { color: #4078c0; text-decoration: none; } #container a:hover, #container a:active { text-decoration: underline; } #container hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #ddd; } #container hr::before { display: table; content: \"\"; } #container hr::after { display: table; clear: both; content: \"\"; } #container h1, #container h2, #container h3, #container h4, #container h5, #container h6 { margin-top: 0; margin-bottom: 0; line-height: 1.5; } #container h1 { font-size: 30px; } #container h2 { font-size: 21px; } #container h3 { font-size: 16px; } #container h4 { font-size: 14px; } #container h5 { font-size: 12px; } #container h6 { font-size: 11px; } #container p { margin-top: 0; margin-bottom: 10px; } #container blockquote { margin: 0; } #container ul, #container ol { padding-left: 0; margin-top: 0; margin-bottom: 0; } #container ol ol, #container ul ol { list-style-type: lower-roman; } #container ul ul ol, #container ul ol ol, #container ol ul ol, #container ol ol ol { list-style-type: lower-alpha; } #container dd { margin-left: 0; } #container code { font-family: \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; font-size: 12px; } #container pre { margin-top: 0; margin-bottom: 0; font: 12px \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; } #container .pl-0 { padding-left: 0 !important; } #container .pl-1 { padding-left: 3px !important; } #container .pl-2 { padding-left: 6px !important; } #container .pl-3 { padding-left: 12px !important; } #container .pl-4 { padding-left: 24px !important; } #container .pl-5 { padding-left: 36px !important; } #container .pl-6 { padding-left: 48px !important; } #container .form-select::-ms-expand { opacity: 0; } #container:before { display: table; content: \"\"; } #container:after { display: table; clear: both; content: \"\"; } #container>*:first-child { margin-top: 0 !important; } #container>*:last-child { margin-bottom: 0 !important; } #container a:not([href]) { color: inherit; text-decoration: none; } #container .anchor { display: inline-block; padding-right: 2px; margin-left: -18px; } #container .anchor:focus { outline: none; } #container h1, #container h2, #container h3, #container h4, #container h5, #container h6 { margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; } #container h1 .octicon-link, #container h2 .octicon-link, #container h3 .octicon-link, #container h4 .octicon-link, #container h5 .octicon-link, #container h6 .octicon-link { color: #000; vertical-align: middle; visibility: hidden; } #container h1:hover .anchor, #container h2:hover .anchor, #container h3:hover .anchor, #container h4:hover .anchor, #container h5:hover .anchor, #container h6:hover .anchor { text-decoration: none; } #container h1:hover .anchor .octicon-link, #container h2:hover .anchor .octicon-link, #container h3:hover .anchor .octicon-link, #container h4:hover .anchor .octicon-link, #container h5:hover .anchor .octicon-link, #container h6:hover .anchor .octicon-link { visibility: visible; } #container h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid #eee; } #container h1 .anchor { line-height: 1; } #container h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid #eee; } #container h2 .anchor { line-height: 1; } #container h3 { font-size: 1.5em; line-height: 1.43; } #container h3 .anchor { line-height: 1.2; } #container h4 { font-size: 1.25em; } #container h4 .anchor { line-height: 1.2; } #container h5 { font-size: 1em; } #container h5 .anchor { line-height: 1.1; } #container h6 { font-size: 1em; color: #777; } #container h6 .anchor { line-height: 1.1; } #container p, #container blockquote, #container ul, #container ol, #container dl, #container table, #container pre { margin-top: 0; margin-bottom: 16px; } #container hr { height: 4px; padding: 0; margin: 16px 0; background-color: #e7e7e7; border: 0 none; } #container ul, #container ol { padding-left: 2em; } #container ul ul, #container ul ol, #container ol ol, #container ol ul { margin-top: 0; margin-bottom: 0; } #container li>p { margin-top: 16px; } #container dl { padding: 0; } #container dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold; } #container dl dd { padding: 0 16px; margin-bottom: 16px; } #container blockquote { padding: 0 15px; color: #777; border-left: 4px solid #ddd; } #container blockquote>:first-child { margin-top: 0; } #container blockquote>:last-child { margin-bottom: 0; } #container table { display: block; width: 100%; overflow: auto; word-break: normal; word-break: keep-all; } #container table th { font-weight: bold; } #container table th, #container table td { padding: 6px 13px; border: 1px solid #ddd; } #container table tr { background-color: #fff; border-top: 1px solid #ccc; } #container table tr:nth-child(2n) { background-color: #f8f8f8; } #container img { max-width: 100%; box-sizing: content-box; background-color: #fff; } #container code { padding: 0; padding-top: 0.2em; padding-bottom: 0.2em; margin: 0; font-size: 85%; background-color: rgba(0,0,0,0.04); border-radius: 3px; } #container code:before, #container code:after { letter-spacing: -0.2em; content: \"\\00a0\"; } #container pre>code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } #container .highlight { margin-bottom: 16px; } #container .highlight pre, #container pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; background-color: #f7f7f7; border-radius: 3px; } #container .highlight pre { margin-bottom: 0; word-break: normal; } #container pre { word-wrap: normal; } #container pre code { display: inline; max-width: initial; padding: 0; margin: 0; overflow: initial; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; } #container pre code:before, #container pre code:after { content: normal; } #container kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: #555; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #ccc; border-bottom-color: #bbb; border-radius: 3px; box-shadow: inset 0 -1px 0 #bbb; } #container .pl-c { color: #969896; } #container .pl-c1, #container .pl-s .pl-v { color: #0086b3; } #container .pl-e, #container .pl-en { color: #795da3; } #container .pl-s .pl-s1, #container .pl-smi { color: #333; } #container .pl-ent { color: #63a35c; } #container .pl-k { color: #a71d5d; } #container .pl-pds, #container .pl-s, #container .pl-s .pl-pse .pl-s1, #container .pl-sr, #container .pl-sr .pl-cce, #container .pl-sr .pl-sra, #container .pl-sr .pl-sre { color: #183691; } #container .pl-v { color: #ed6a43; } #container .pl-id { color: #b52a1d; } #container .pl-ii { background-color: #b52a1d; color: #f8f8f8; } #container .pl-sr .pl-cce { color: #63a35c; font-weight: bold; } #container .pl-ml { color: #693a17; } #container .pl-mh, #container .pl-mh .pl-en, #container .pl-ms { color: #1d3e81; font-weight: bold; } #container .pl-mq { color: #008080; } #container .pl-mi { color: #333; font-style: italic; } #container .pl-mb { color: #333; font-weight: bold; } #container .pl-md { background-color: #ffecec; color: #bd2c00; } #container .pl-mi1 { background-color: #eaffea; color: #55a532; } #container .pl-mdr { color: #795da3; font-weight: bold; } #container .pl-mo { color: #1d3e81; } #container kbd { display: inline-block; padding: 3px 5px; font: 11px \"Roboto Mono\", \"Ubuntu Mono\", \"Menlo\", \"Consolas\", monospace; line-height: 10px; color: #555; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #ccc; border-bottom-color: #bbb; border-radius: 3px; box-shadow: inset 0 -1px 0 #bbb; } #container .full-commit .btn-outline:not(:disabled):hover { color: #4078c0; border: 1px solid #4078c0; } #container :checked+.radio-label { position: relative; z-index: 1; border-color: #4078c0; } #container .octicon { display: inline-block; vertical-align: text-top; fill: currentColor; } #container .task-list-item { list-style-type: none; } #container .task-list-item+.task-list-item { margin-top: 3px; } #container .task-list-item input { margin: 0 0.2em 0.25em -1.6em; vertical-align: middle; } #container hr { border-bottom-color: #eee; } 在之前写抢报告软件的过程中，遇到一个非常有趣的问题——如何提高抢到报告的概率？当然，无脑减小两次请求之间的间隔时间可以保证一定能抢到报告，但是也会加大服务器的负担，作为北京化工大学的优秀学子:smirk:，这么做是不可行的。脑中突然灵光一现，以固定 5 秒的时间间隔抢报告与以 0 到 10 之间的随机时间间隔抢报告，抢到报告的概率是一样的吗？刚好最近要考数理统计，那就用概率论的知识来解决这个问题吧（其实是不务正业:grin:）。 问题分析 从直观上来看，固定 5 秒的时间间隔与 0 到 10 之前的随机时间间隔的期望是相等的，实际情况计算后才知道。 间隔时间固定的情况 为了简化问题，首先将抢到报告的事件记为 ，将报告的存活时间（报告从可抢状态开始到被抢走的时间）的期望值记为 E ，提交抢报告请求的时间间隔为 ，则抢到报告的概率即为 。针对 的情况， 。即在报告平均存活时间为 3 秒，抢报告间隔固定为 5 秒的情况下，抢到报告的概率为 。 间隔时间为均匀分布的情况 在该种情况下，我们构造抢报告的时间间隔的分布为 ，其概率密度函数为： 则对于任意的时间间隔 ，根据上一节中的结果，抢到报告的概率 的可表示为分段函数： 得到抢到报告的期望为 针对抢报告时间满足 分布，报告平均存活时间为 3 秒的情况，将 代入上式，得到 。也就是说不改变 期望的情况下，通过改变 的分布竟然提高了抢到报告的概率！！！我要赶快把这个修改合并到抢报告程序中！！！ 总结 为什么两种方法抢到报告的概率不同呢？个人分析是由于在 满足均匀分布时，其中较小的 带来了较大的成功概率，而较大的 对整体概率的影响不大。正如有句话说的好，抢报告抢的早不如抢的巧。抢报告是玄学，需要天时地利人和。至于计算过程是否正确，就要看最后我的数理统计成绩了:joy:","categories":[{"name":"python","slug":"python","permalink":"http://cycoe.cc/categories/python/"},{"name":"spider","slug":"python/spider","permalink":"http://cycoe.cc/categories/python/spider/"}],"tags":[]},{"title":"利用 python 实现自动抢报告","slug":"利用python实现自动抢报告","date":"2017-10-27T16:00:00.000Z","updated":"2018-04-13T03:37:54.636Z","comments":true,"path":"2017/10/28/利用python实现自动抢报告/","link":"","permalink":"http://cycoe.cc/2017/10/28/利用python实现自动抢报告/","excerpt":"","text":"上了研究生才知道北化的研究生每年需要听 15 个报告，而且最重要的是这些报告都是算分数的，而且更重要的是你的分数是和最后的奖学金评定挂钩的。这也就决定了大家为了那么点报告分数挤教务网都挤破了头（北化的服务器大家都懂），虽然场面不如开学抢课那么火爆，却需要长时间挂着教务网疯狂刷新，为了交换个讲座也需要大半夜起来，生怕被别人截胡。为了解放生产力，同时熟悉爬虫技术、神经网络技术、装饰器等进阶内容，写了这个爬虫来练练手。 声明该爬虫是本人(cycoe)练习 python 编程技巧和神经网络所编写，使用造成的任何责任与本人无关 项目地址 问题分解想要顺利的拿到抢讲座的 session，需要如下的步骤： 处理登陆问题，包括处理验证码、页面表单和 cookies 获取报告列表 获取抢报告的地址 提交表单数据 框架设计好的框架应具有良好的可维护性和扩展性，目前正朝着这个方向努力 采用交互式的命令行设计，分离 login, robSpeech 等方法 将 login, robSpeech, robClass 等方法封装成 Robber 对象 将底层的 requests 封装成 Spider 对象 逐步解决 通过 firefox 或 chrome 的 debug 模式可以查看在访问网页时的 request 和 response。仿照浏览器在访问教务网时提交的 headers 构造如下字典 1234567891011121314151617181920212223242526class Spider(object): @staticmethod def formatHeaders(referer=None, contentLength=None, originHost=None): \"\"\" 封装请求的 headers :param referer: 跳转标记，告诉 web 服务器自己是从哪个页面跳转过来的 :param contentLength: 作用未知 :param originHost: 原始主机地址 :returns: headers 字典 \"\"\" headers = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7', 'Cache-Control': 'max-age=0', 'Connection': 'keep-alive', 'Content-Type': 'application/x-www-form-urlencoded', 'DNT': '1', 'Host': 'graduate.buct.edu.cn:8080', 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (X11;Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36', 'Referer': referer, 'Content-Length': contentLength, 'Origin': originHost, &#125; 封装 request 请求需要的 prepareBody 对象，response = session.send(prepareBody)，response 就是我们拿到的服务器的响应对象，可通过 response.text 得到网页内容，response.status_code 得到状态码，response.url 得到响应的地址。 1234567891011121314151617181920212223242526272829def prepare(self, referer=None, originHost=None, method='GET', url=None, data=None, params=None): \"\"\" 生成用于请求的 prepare :param referer: 跳转标记，告诉 web 服务器自己是从哪个页面跳转过来的 :param originHost: 原始主机地址 :param method: 请求方法 in ['GET', 'POST'] :param url: 请求的 url 地址 :param data: 封装的 post 数据 :param params: post 参数 :return: prepare 对象 \"\"\" headers = self.formatHeaders(referer=referer, originHost=originHost) req = Request(method, url, headers=headers, data=data, params=params) return self.session.prepare_request(req)prepareBody = prepare(referer=None, originHost=None, method='GET', url=UrlBean.jwglLoginUrl, data=None, params=None)response = session.send(prepareBody) 请求登录网址，提交表单数据。根据 response 返回的响应体内容判断是否登陆成功 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128def getVIEWSTATE(self): \"\"\" 正则获取页面的 __VIEWSTATE :returns: 页面的 __VIEWSTATE \"\"\" VIEWSTATE = re.findall('&lt;.*name=\"__VIEWSTATE\".*value=\"(.*)?\".*/&gt;', self.response.text) if len(VIEWSTATE) &gt; 0: return VIEWSTATE else: return Nonedef getEVENTVALIDATION(self): \"\"\" 正则获取页面的 __EVENTVALIDATION :returns: 页面的 __EVENTVALIDATION \"\"\" EVENTVALIDATION = re.findall('&lt;.*name=\"__EVENTVALIDATION\".*value=\"(.*)?\".*/&gt;', self.response.text) if len(EVENTVALIDATION) &gt; 0: return EVENTVALIDATION else: return Nonedef login(self): \"\"\" 登录教务网 \"\"\" # 在登录前请求一次登录页面，获取网页的隐藏表单数据 prepareBody = self.prepare(referer=None, originHost=None, method='GET', url=UrlBean.jwglLoginUrl, data=None, params=None) # 登陆主循环 while True: self.response = self.session.send(prepareBody) self.VIEWSTATE = self.getVIEWSTATE() self.EVENTVALIDATION = self.getEVENTVALIDATION() if self.VIEWSTATE is not None and self.EVENTVALIDATION is not None: break Logger.log(\"Retrying fetching login page viewState...\", level=Logger.warning) reInput = True # 是否需要重新输入用户名和密码 while True: # 输入用户名和密码 if reInput: if Config.checkUserFile(): Config.readUserInfo() else: Config.userName = input(\"&gt; UserName: \") Config.password = input(\"&gt; Password: \") reInput = False prepareBody = self.prepare(referer=UrlBean.jwglLoginUrl, originHost=None, method='GET', url=UrlBean.verifyCodeUrl, data=None, params=None) while True: codeImg = self.session.send(prepareBody) # 获取验证码图片 if codeImg.status_code == 200: break else: Logger.log(\"retrying fetching vertify code...\", level=Logger.warning) with open('check.gif', 'wb') as fr: # 保存验证码图片 for chunk in codeImg: fr.write(chunk) print_vertify_code() verCode = input(\"input verify code:\") # verCode = self.classifier.recognizer(\"check.gif\") # 识别验证码 # 构造登陆表单 postData = &#123; '__VIEWSTATE': self.VIEWSTATE, '__EVENTVALIDATION': self.EVENTVALIDATION, '_ctl0:txtusername': Config.userName, '_ctl0:txtpassword': Config.password, '_ctl0:txtyzm': verCode, '_ctl0:ImageButton1.x': '43', '_ctl0:ImageButton1.y': '21', &#125; prepareBody = self.prepare(referer=UrlBean.jwglLoginUrl, originHost=UrlBean.jwglOriginUrl, method='POST', url=UrlBean.jwglLoginUrl, data=postData, params=None) # 获取登陆 response while True: self.response = self.session.send(prepareBody) if self.response.status_code == 200: break # 根据返回的 html 判断是否登录成功 if re.search('用户名不存在', self.response.text): Logger.log('No such a user!', ['Cleaning password file'], level=Logger.error) print(OutputFormater.table([['No such a user!'], ['Cleaning password file']], padding=2)) Config.cleanUserInfo() reInput = True elif re.search('密码错误', self.response.text): Logger.log('Wrong password!', ['Cleaning password file'], level=Logger.error) print(OutputFormater.table([['Wrong password!'], ['Cleaning password file']], padding=2)) Config.cleanUserInfo() reInput = True elif re.search('请输入验证码', self.response.text): Logger.log('Please input vertify code!', ['Retrying...'], level=Logger.error) print(OutputFormater.table([['Please input vertify code!'], ['Retrying...']], padding=2)) elif re.search('验证码错误', self.response.text): Logger.log('Wrong vertify code!', ['Retrying...'], level=Logger.error) print(OutputFormater.table([['Wrong vertify code!'], ['Retrying...']], padding=2)) else: Logger.log('Login successfully!', ['UserName: ' + Config.userName, 'Password: ' + Config.password], level=Logger.warning) print(OutputFormater.table([['Login successfully!']], padding=2)) Config.dumpUserInfo() break 拿到已登陆的 session 后，抢课和抢报告都是非常方便的，只要按照浏览器提交的数据构造 headers 和表单数据后就可以获得正常的 response 暗坑总结 刚开始抓到的网页内容中文都是乱码，后来 google 解决，发现是 python 的编码和 asp 框架的编码问题造成的，python 中的编码问题真的是让人头大 由于网站的防爬虫设计，会在 html 源码中插入很多隐藏的表单数据，如此处的 __VIEWSTATE 和 __EVENTVALIDATION，这两个是非常重要的参数。否则无法成功登陆 两次访问之间要有一定的时间间隔，如此处用了一个随机函数的闭包来获得随机时间的间隔 使用装饰器解决了在访问抢课网页前判断登录的问题 接下来将循环封装成函数，加入最大循环次数和超时 完善边界检查和异常处理","categories":[{"name":"python","slug":"python","permalink":"http://cycoe.cc/categories/python/"},{"name":"spider","slug":"python/spider","permalink":"http://cycoe.cc/categories/python/spider/"}],"tags":[]},{"title":"Archlinux 安装小记","slug":"Archlinux安装小记","date":"2017-07-08T16:00:00.000Z","updated":"2018-04-13T03:37:41.260Z","comments":true,"path":"2017/07/09/Archlinux安装小记/","link":"","permalink":"http://cycoe.cc/2017/07/09/Archlinux安装小记/","excerpt":"","text":"准备工作 ethernet 用户无需对网络连接做过多设置，wifi 用户可使用 wifi-menu 工具进行无线网连接 对 /etc/pacman.d/mirrorlist 文件中的源进行排序 分区 利用 cfdisk 或 fdisk 工具进行分区 使用 mkfs.ext4 /dev/sdxY 进行分区的格式化，btrfs 分区运行 mkfs.btrfs -f /dev/sdxY 挂载按顺序执行如下命令12345678910mount /dev/sdxY /mnt # 挂载根分区mkdir /mnt/homemkdir /mnt/bootmkdir /mnt/boot/grubmkdir /mnt/boot/efimount /dev/sdxY /mnt/homemount /dev/sdxY /mnt/boot/efimount /dev/sdxY /mnt/boot/grub 若根分区为 btrfs 格式，则需要先使用如下命令挂载根分区123456mount /dev/sdxY /mnt #挂载根分区cd /mntbtrfs subvolume create @ #创建名为 @ 的子卷cd ~umount /mntmount /dev/sdxY /mnt -o subvol=@,compress=lzo 分区挂载完毕后可运行 lsblk 查看挂载信息 安装运行自动化安装工具 pacstrap -i /mnt base 需要 gcc 等开发工具的用户需要装上 base-devel 包 btrfs 分区需要 btrfs-progs 包 wifi 用户需要同时安装 dialog wpa_supplicant 来使用 wifi-menu 引导管理器可选择 grub，efi 主板用户需加上 efibootmgr，多系统检测需要 os-prober示例：pacstrap -i /mnt base base-devel btrfs-progs dialog wpa_supplicant grub efibootmgr os-prober 运行 genfstab -U /mnt 查看挂载信息是否正确，检查无误后运行 genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 将挂载信息写入 fstab 配置 使用 archlinux 自带的 arch-chroot /mnt 接管新系统 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 设置时区 1234# nano /etc/locale.genen_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_TW.UTF-8 UTF-8","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cycoe.cc/categories/Linux/"}],"tags":[]},{"title":"静态编译安装 Qt","slug":"静态编译安装Qt","date":"2017-04-10T16:00:00.000Z","updated":"2018-04-13T03:37:26.444Z","comments":true,"path":"2017/04/11/静态编译安装Qt/","link":"","permalink":"http://cycoe.cc/2017/04/11/静态编译安装Qt/","excerpt":"","text":"由于 pyqt 写的程序打包过程中依赖库的问题，打算用 c++ 版的 Qt 重写程序。但若用系统自带的共享链接库进行编译，程序同样无法在其他机器上运行。因此，此时需要自己手动静态编译 Qt，使用静态链接库编译的程序会自动将依赖的库加到最终编译出的机器码中。 安装依赖项 Qt 的界面显示依赖 freetype 和 fontconfig，这两个一定要装上，否则编译不成功。 安装完毕后创建 freetype 的软链接到标准的安装位置：ln -s /usr/include/freetype2/freetype /usr/include/freetype 编译 下载最新的 Qt everywhere 压缩包 解压压缩包，cd 进压缩包目录 运行以下命令对 makefile 进行配置 1./configure -confirm-license -opensource -static -fontconfig -release -no-qml-debug -qt-xcb -nomake tests -nomake examples -skip qtwebkit -prefix /usr/include/Qt-5.8.0-static -static -&gt; 选择静态编译模式 -fontconfig -&gt; 此项一定要加，否则会导致找不到字体 -prefix -&gt; 指定安装位置 运行 make -j 3 采用 3 线程编译 最后 sudo make install 安装 Qt 配置 Qt Creator 安装 Qt Creator 打开 Qt Creator -&gt; tools -&gt; options -&gt; build，根据安装路径配置 Qt version 和 Kit","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cycoe.cc/categories/Linux/"}],"tags":[]},{"title":"基于Jekyll引擎的博客服务器搭建","slug":"基于Jekyll引擎的博客服务器搭建","date":"2017-03-31T16:00:00.000Z","updated":"2018-04-13T03:37:12.964Z","comments":true,"path":"2017/04/01/基于Jekyll引擎的博客服务器搭建/","link":"","permalink":"http://cycoe.cc/2017/04/01/基于Jekyll引擎的博客服务器搭建/","excerpt":"","text":"Transform your plain text into static websites and blogs. 为什么要搭建自己的博客服务器之前我们已经利用 GitHub Pages 和 Jekyll 搭建了静态博客并且托管在了 github.io 上，并且拥有了不错的页面效果以及可用性。那我们为什么还要搭建自己的博客服务器呢？因为 GitHub 的服务器在美国，访问体验并不顺畅；并且在我们 Push 了项目之后，往往要等待一定时间页面内容才会刷新。为了更好的体验效果，我们将基于树莓派搭建自己的博客服务器。树莓派为 3B+，系统为 Archlinuxarm-rpi-2 环境搭建安装 Ruby依次运行下面的命令安装最新的 Ruby 运行环境：12345$ sudo pacman -S ruby$ ruby --versionruby 2.4.0p0 (2016-12-24 revision 57164) [armv7l-linux-eabihf]$ gem --version2.6.8 出现上面的提示说明 Ruby 安装成功，gem 可以看做是 Ruby 插件的安装器，一般安装 Ruby 后自带。 注意：Archlinux 用普通用户安装 Ruby 后会遇到运行 Gem 插件提示找不到命令的情况，原因是 Ruby 未自动设置环境变量。解决方法： bash打开 ~/.bashrc 文件，加入以下命令： 1export PATH=$PATH:~/.gem/ruby/2.4.0/bin/ fish打开 ~/.config/fish/config.fish 文件（没有则新建），加入以下命令： 1set -x PATH &#123;$PATH&#125; ~/.gem/ruby/2.4.0/bin 安装 Jekyll Jekyll is a simple, blog-aware, static site generator for personal, project, or organization sites.Written in Ruby by Tom Preston-Werner, GitHub’s co-founder, it is distributed under an open source license. 安装 Jekyll 之前需要先安装 bundle 管理器 1gem install bundle 编辑 Gemfile，在文件中输入以下内容 1gem &apos;github-pages&apos;, group: :jekyll_plugins 利用 bundle 安装 Jekyll 渲染需要的所有包 1bundle install 到此需要的依赖安装完毕，若 fork 的其他人的 Jekyll 模板，则直接进入模板目录下执行 bundle install。 运行 Jekll 若要在 _site 目录下生成网站目录，则运行 bundle exec jekyll build 若要运行可本机访问的服务则运行 bundle exec jekyll server -w，默认本机地址 127.0.0.1:4000 若要局域网可访问则需要加上 bundle exec jekyll server -w --host=0.0.0.0","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cycoe.cc/categories/Linux/"}],"tags":[]},{"title":"研究生复试英语面试稿子","slug":"English_Interview","date":"2017-03-24T16:00:00.000Z","updated":"2018-04-13T15:28:25.722Z","comments":true,"path":"2017/03/25/English_Interview/","link":"","permalink":"http://cycoe.cc/2017/03/25/English_Interview/","excerpt":"","text":"English InterviewGood morning, professors! I am very glad to be here for this interview. My name is Zhu Haonan, 22 years old. I am from Wenzhou, the city on the Shore`/ʃɔ:(r)/` of Zhejiang Province. My undergraduate education will be accomplished in Beijing University of Chemical Technology in this July, majoring in polymer material and engineering. From high school, I was captivated`/ˈkæptɪveɪt/` by chemistry, logic and programming. In 2015, I won the second prize in the Mathematical`/ˌmæθəˈmætɪkl/` Contest in Modeling, where I learned how to work in a team and solve problems with math and computer. During my undergraduate study, I recognized`/ˈrekəgnaɪz/` that polymer science is a very prospective`/prəˈspektɪv/` subject, and polymer materials are widely used among numerous`/ˈnjuːmərəs/` fields. I enjoy my major very much. I am long to do further research in this field and make contributions to the development of polymer material with my efforts. Therefore, I wish I could keep pursuing`/pəˈsju/` advanced studies. It is a urgent`/ˈɜːdʒənt/` requirement to seize any chance for self-development, especially facing the fierce`/fɪəs/` social competition. I think the postgraduate study can enrich my knowledge and make me competent`/ˈkɒmpɪtənt/` in my future career`/kəˈrɪə(r)/`. That’s all. Thank you for giving me this opportunity!","categories":[{"name":"blog","slug":"blog","permalink":"http://cycoe.cc/categories/blog/"}],"tags":[]},{"title":"在SSD上使用Btrfs文件系统的相关优化","slug":"在SSD上使用Btrfs文件系统的相关优化","date":"2017-03-24T16:00:00.000Z","updated":"2018-04-13T03:36:51.722Z","comments":true,"path":"2017/03/25/在SSD上使用Btrfs文件系统的相关优化/","link":"","permalink":"http://cycoe.cc/2017/03/25/在SSD上使用Btrfs文件系统的相关优化/","excerpt":"","text":"优化挂载参数在 Linux 中挂载 SSD 上的 btrfs，可以采用各种参数进行优化：12#&lt;file system&gt;&lt;mount point&gt;&lt;type&gt;&lt;options&gt;&lt;dump&gt;&lt;pass&gt;UUID=&lt;略&gt;/ btrfs defaults,ssd,discard,noatime,compress=lzo,subvol=@ ssdbtrfs 文件系统有对 SSD 进行优化，在挂载参数中加入 ssd 即可。该参数不会自动启用 TRIM/discard。 discard可以通过以下命令确认 SSD 是否支持 TRIM：12sudo hdparm -I /dev/sdX | grep TRIM*Data Set Management TRIM supported (limit 8 blocks) 若 SSD 支持 TRIM 命令，可以在 /etc/fstab 中启用 discard 参数。建议将 discard 挂载参数作为首选。据 debian wiki 所述，包括三星、镁光、英睿达在内的一些 SSD 在 discard/TRIM 上有问题，不能合适地处理 TRIM 命令。该参数不是必需的，也可以自定义周期性运行 fstrim 命令来取代该参数，使用该命令前要确认 SSD 支持 TRIM，否则可能造成数据丢失。当 SSD 有足够的空余空间或（未分配的）可用空间时不需要该参数。 noatime挂载参数可以加入 noatime，通过禁止更新访问记录来减少不必要的写操作以提高性能。该选项对 HDD 同样有性能提升。btrfs 的默认配置为 relatime。 compress打开压缩功能在通常情况下有利于提高传输性能（并非绝对），也可以节省存储空间。加入以下挂载参数： compress=lzo compress=zlib lzo 速度更快，zlib 压缩率更高。注意确认 SSD 主控是否是非压缩主控，若为压缩主控不建议加入该参数。 写缓存若 SSD 带有缓存，启用 Write Cache 可以提高性能：Disks -&gt; Drive Setting -&gt; Enable Write Cache，但在突然断电的情况下可能造成数据丢失。 I/O 调度SSD 结构不同于传统硬盘，寻址时间短，I/O 调度算法可选择 noop 以降低延迟。以下命令可查看与修改调度器：12cat/sys/block/sdX/queue/scheduler # sdX 指你的设备sudotee/sys/block/sdX/queue/scheduler &lt;&lt;&lt; noop 注意以上方法并不持久，重启后会重置。如果 SSD 是系统唯一的存储设备，可考虑通过 elevator=noop 内核参数设置 I/O 调度器。也可使用 udev 规则来修改调度器，对多存储设备同样有效：1sudo touch /etc/udev/rules.d/60-ssd-scheduler.rules #创建该文件 文件内容如下：12# set deadline scheduler for non-rotating disksACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]&quot;, ATTR&#123;queue/rotational&#125;==&quot;0&quot;, ATTR&#123;queue/scheduler&#125;=&quot;noop&quot;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cycoe.cc/categories/Linux/"}],"tags":[]},{"title":"教育部公布2017年考研国家线！","slug":"postgraduate","date":"2017-03-14T16:00:00.000Z","updated":"2018-04-13T15:28:09.853Z","comments":true,"path":"2017/03/15/postgraduate/","link":"","permalink":"http://cycoe.cc/2017/03/15/postgraduate/","excerpt":"","text":"2017 年全国硕士研究生招生考试考生进入复试的初试成绩基本要求（学术学位类）2017 年全国硕士研究生招生考试考生进入复试的初试成绩基本要求（专业学位类） 为方便考生调剂，3 月 17 日至 4 月 30 日，教育部将在“中国研究生招生信息网”（公网网址，教育网网址）开通“全国硕士研究生招生调剂服务系统”。 符合条件且有调剂愿望的考生可及时上网了解调剂信息和调剂系统的使用方法，按要求申请调剂。","categories":[{"name":"blog","slug":"blog","permalink":"http://cycoe.cc/categories/blog/"}],"tags":[]},{"title":"[python机器学习-1]K近邻算法实现验证码识别","slug":"KNN","date":"2017-03-11T16:00:00.000Z","updated":"2018-04-13T03:36:34.668Z","comments":true,"path":"2017/03/12/KNN/","link":"","permalink":"http://cycoe.cc/2017/03/12/KNN/","excerpt":"","text":"A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E. 机器学习在最近几年有越来越火热的趋势。正巧打算做一个爬取教务网成绩的爬虫，碰到验证码识别的问题。于是通过各方了解后买了《机器学习实战》这本书，开坑机器学习。机器学习的内容其实很广，涉及的知识也非常的杂，包括概率论、统计学、逼近论、凸分析、算法复杂度理论和编程等等。因为不是本科涉及的内容，只能一点一点的补。 分类机器学习分为监督学习和无监督学习两种，监督学习是指算法知道要预测的目标，即目标变量的分类信息；而无监督学习时，数据没有类别信息，也不会给定目标值。 监督学习 无监督学习 k-近邻算法 K-均值 朴素贝叶斯算法 DBSCAN 支持向量机 \\ 决策树 \\ 核心思想k-近邻算法的原理很简单，即选取 m 个已分类的样本作为训练集，每个样本拥有 n 个特征。待测试样本与每个训练样本求欧式距离，对得到的距离顺序排序。根据预设的 k 值（k 一般取一个比较小的数）取出前 k 个距离。最后统计每个类别出现的次数，取出现次数最多的类别作为待测样本的类别标签。此处说明 KNN 算法的两个特征： 各个特征等权重，不考虑各个特征对类别的贡献大小 最终的分类方法其实是投票表决的方法 代码为了提高代码的运行效率及编码效率，import 了 Numpy 库，具体的函数看 官方文档 ，或者 Numpy 教程 。 分类函数1234567891011121314def classify0(inX, dataSet, labels, k): #输入(待测样本向量，训练样本矩阵，标签向量，k) dataSetSize = dataSet.shape[0] #shape函数用来读取矩阵的维的长度，返回值为(4L,2L) diffMat = tile(inX, (dataSetSize, 1)) - dataSet #tile函数用来重复 A=[1,2] tile(A,(2,3)) -&gt; [[1,2,1,2，1,2], [1,2,1,2,1,2]] sqDiffMat = diffMat**2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; for i in range(k): votedLabel = labels[sortedDistIndicies[i]] classCount[votedLabel] = classCount.get(votedLabel, 0) + 1 #dict.get(key, default_value)函数用来取键对应的值，若键不存在则值为defalut_vlaue sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) #operator.itemgetter(1)表示根据多级列表的第二个元素进行排序 return sortedClassCount[0][0]","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://cycoe.cc/categories/Machine-Learning/"}],"tags":[]},{"title":"如何同步GitHub上游更新","slug":"如何同步GitHub上游更新","date":"2017-03-10T16:00:00.000Z","updated":"2018-04-13T03:36:14.644Z","comments":true,"path":"2017/03/11/如何同步GitHub上游更新/","link":"","permalink":"http://cycoe.cc/2017/03/11/如何同步GitHub上游更新/","excerpt":"","text":"在 GitHub 上进行项目的团队协作，一般都是 fork 组织仓库到自己的账号下，提交补丁后再提交 Pull Request。上游仓库一直保持更新。由于最近在做 LCTT 项目，经常需要同步上游其他人的翻译，下面就以 LCTT 项目为例，记录一下 GitHub 上 fork 仓库同步上游更新的操作。 使用 git remote -v 查看当前的远程仓库别名，输出如下： 1234LCTT https://github.com/LCTT/TranslateProject.git (fetch)LCTT https://github.com/LCTT/TranslateProject.git (push)origin git@github.com:cycoe/TranslateProject.git (fetch)origin git@github.com:cycoe/TranslateProject.git (push) 其中 origin 是自己账号下的对应远端仓库地址别名， LCTT 是设定好的上游仓库地址的别名。此处 LCTT 项目已经帮我们设置好了就不需要另外设置。 如果没有设置上游仓库地址，可通过 git remote add 上游仓库别名 上游仓库地址 命令来设置上游仓库的别名。 同步上游仓库更新到本地，并合并更新到本地仓库 master 分支 123git fetch LCTT #从上游仓库抓取更新git checkout master #切换到 master 分支git merge LCTT/master #合并上游更新到 master 分支 git push 命令推送本地仓库到 fork 仓库","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://cycoe.cc/categories/GitHub/"}],"tags":[]},{"title":"记第一次买域名以及搭建个人主页","slug":"first-post","date":"2017-03-10T16:00:00.000Z","updated":"2018-04-13T15:27:53.557Z","comments":true,"path":"2017/03/11/first-post/","link":"","permalink":"http://cycoe.cc/2017/03/11/first-post/","excerpt":"","text":"看到好基友 @Yinr 搭建了个人主页，也手痒花4块钱在万网上买了 cycoe.win 域名的一年使用权。fork 了 mzlogin 的项目（项目主页在 GitHub Pages 上搭建了各人主页，然后把 cycoe.win 域名解析到了 cycoe.github.io 上，经过一些小改，自己的主页终于搭好了 :laughing: ！最后是去 163 的企业邮箱（163 企业邮箱注册）申请了基于 cycoe.win 域名的邮箱，我的新邮箱就是 cycoe@cycoe.win。 感谢 GitHub 提供的 GitHub Pages 服务 mzlogin 的 Jekyll 模板","categories":[{"name":"blog","slug":"blog","permalink":"http://cycoe.cc/categories/blog/"}],"tags":[]},{"title":"用GitHub-Pages和jekyll搭建个人主页","slug":"用GitHub-Pages和jekyll搭建个人主页","date":"2017-03-08T16:00:00.000Z","updated":"2018-04-13T03:35:54.851Z","comments":true,"path":"2017/03/09/用GitHub-Pages和jekyll搭建个人主页/","link":"","permalink":"http://cycoe.cc/2017/03/09/用GitHub-Pages和jekyll搭建个人主页/","excerpt":"","text":"闲来无事，打算搭建个人主页。查阅了各种资料，发现目前最省钱省力的方法就是在 GitHub Pages 上利用 jekyll 静态网页生成器搭建。对于 Web 开发小白来说，自己写网页代码不太现实。 好在GitHub 上有许多其他大神制作好的 jekyll 模板，直接 fork 过来修改一下就可以使用，其余的精力都可以用在文章内容本身上。 搭建步骤 在 GitHub 上找到自己喜欢的 jekyll 模板， fork 到自己的仓库下，然后点击 Setting 修改仓库名称为 username.github.io 将 fork 后的项目 clone 至本地 打开 _config.yml 文件修改其中的信息，包括网站名称、用户信息等 将 html 或 MarkDown 格式的文章和博客添加到 _posts 文件夹 使用以下命令即可提交更新并推送更新至远端仓库 123git add .git commit -am \"post update\"git push 完成以上步骤后，你就应该可以通过 username.github.io 访问你的主页了 :clap: ！ 注意事项comments_provider: duoshuo duoshuo_username: cycoe disqus_username: cycoe lazy_load_duoshuo: true 此处的usrname一定要填自己申请的账号名 进阶配置 申请域名 本博客使用的主题为 mzlogin 的 码志 主题","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://cycoe.cc/categories/GitHub/"}],"tags":[]},{"title":"CPVC热稳定剂","slug":"CPVC热稳定剂","date":"2017-03-08T16:00:00.000Z","updated":"2018-04-13T03:35:27.372Z","comments":true,"path":"2017/03/09/CPVC热稳定剂/","link":"","permalink":"http://cycoe.cc/2017/03/09/CPVC热稳定剂/","excerpt":"","text":"热稳定剂是一类能防止或减少聚合物在加工使用过程中受热而发生降解或交联,延长复合材料使用寿命的添加剂。常用的稳定剂按照主要成分分类可分为盐基类、脂肪酸皂类、有机锡化合物、复合型热稳定剂及纯有机化合物类。 分类 盐基类热稳定剂:盐基类稳定剂是指结合有“盐基”的无机和有机酸铅盐,这类稳定剂具有优良的耐热性、耐候性和电绝缘性,成本低,透明性差,有一定毒性,用量一般在0.5%~5.0%。 脂肪酸类热稳定剂:该类热稳定剂是指由脂肪酸根与金属离子组成的化合物,也称金属皂类热稳定剂,其性能与酸根及金属离子的种类有关,一般用量为0.1%~3.0%。 有机锡类热稳定剂:该类热稳定剂可与聚氯乙烯分子中的不稳定氯原子形成配位体,而且在配位体中有机锡的羧酸酯基与不稳定的氯原子置换。这类热稳定剂的特点是稳定性高、透明性好、耐热性优异,不足之处是价格较贵。 复合型热稳定剂:该类热稳定剂是以盐基类或金属皂类为基础的液体或固体复合物以及有机锡为基础的复合物,其中金属盐类有钙—镁—锌、钡—钙—锌、钡—锌和钡—镉等;常用的有机酸如有机脂肪酸、环烷酸、油酸、苯甲酸和水杨酸等。 有机化合物热稳定剂:该类热稳定剂除少数可单独使用的主稳定剂(主要是含氮的有机化合物)外,还包括高沸点的多元醇及亚磷酸酯,亚磷酸酯常与金属稳定剂并用,能提高复合材料的耐候性、透明性,改善制品的表面色泽。 PVC热稳定剂的作用机理 吸收中和HCL,抑制其自动催化作用。这类稳定剂包括铅盐类、有机酸金属皂类、有机锡化合物、环氧化合物、酚盐及金属硫醇盐等。它们可与HCL反应,抑制PVC脱HCL的反应。 置换PVC分子中不稳定的烯丙基氯原子抑制脱PVC。如有机锡稳定剂与PVC分子的不稳定氯原子发生配位结合,在配位体中,有机锡与不稳定氯原子置换。 与多烯结构发生加成反应,破坏大共轭体系的形成,减少着色。不饱和酸的盐或酯含有双键,与PVC分子**轭双键发生双烯加成反应,从而破坏其共轭结构,抑制变色。 捕捉自由基,阻止氧化反应。如加入酚类热稳定剂能阻滞脱HCL,是由于酚给出的H原子自由基能与降解的PVC大分子自由基偶合,形成不能与O2反应的物质,而具有热稳定作用。这种热稳定剂可具有一种或兼具几种作用。 理想的PVC热稳定剂应是一种多功能物质,或者是一些材料的混合物,它们能够实现以下功能:一是置换活泼、不稳定的取代基;二是吸收并中和PVC加工过程中放出的HCL,消除HCL的自动催化降解作用;三是中和或钝化对降解起催化作用的金属离子及其他有害杂质;四是通过多种形式的化学反应可阻断不饱和键的继续增长,抑制降解着色;五是最好对紫外光有防护屏蔽作用。通常热稳定剂根据各自的特殊效能配合使用,单独使用的情况极少,而且大部分品种是粉末状,一些是毒性很大的化学物质。为了使用方便,防止粉尘中毒,减小毒性物质或代之以无毒性物质,近年国内外研制出许多种复合稳定剂,例如,世界著名的德国熊牌复合稳定剂系列,美国、德国、日本、荷兰等国的有机锡或复合有机锡稳定剂,都在中国占有相当的市场。因此,全力推广应用我国研制的具有高效、低成本、无粉尘污染及无毒或低毒性的新型复合稳定剂,是我国塑料工业发展的迫切需要。 PVC加工需用热稳定剂原理分析理想的PVC结构是首—尾结构-CH2-CHCl-CH2-CHCl-,是相当稳定的。但是至今合成PVC的方法还不能像合成顺丁橡胶那样,在齐格尔催化剂的作用下使顺丁二烯进行定向有规聚合。氯乙烯的聚合是自由基的无规聚合,它除了有稳定的首—尾结构,还有首—首结构-CH2-CHCl-CHCl-CH-,尾—尾结构-CHCl-CH2-CH2-CHCl-;有偶合歧化生成乙烯基结CH2=CH-CHCl-CH2-结构和烯丙基氯-CH2-CH=CH-CHCl-CH2等。在PVC合成中生成烯丙基氯、叔碳氯和双键等是其分子链结构中不稳定因素,不稳定顺序为:PVC分子链内部的烯丙基氯&gt;叔碳氯&gt;端基烯丙基氯&gt;仲氯。PVC加工时易于降解正是因为PVC分子链的结构中存在着不稳定因素,如不进行稳定化改性,其分解温度为130℃左右,但要将PVC树脂加工成有用的制品,成型温度要在190℃以上。因此,必须添加热稳定剂对其结构进行稳定化改进。 各类热稳定剂受热变色评析理想的热稳定剂应同时具有吸收HCL、消除活性部位、向共轭多烯链加成、破坏碳正离子盐、防止自动氧化等功能,而又不产生对PVC降解有催化作用的产物。实际的热稳定剂因具有不同的功能而表现出不同的热稳定特性,大致可分为初期型、长期型、中间型和全能型四类。 镉、锌皂属典型的初期型热稳定剂,能快速吸收HCL,并在Cd、Zn的催化下有效地以羧酸根取代PVC链上的不稳定氯原子,从而有效抑制初期降解和着色,但因其消耗快而转化产物CdC12、ZnC12,又是PVC脱HCL的高效催化剂,因而会引发PVC恶性降解使物料突然变黑,因此长期热稳定性差。 钡、钙皂属典型的长期型热稳定剂,只有吸收HCL的功能,因此不能有效抑制PVC着色,但因转化产物BaC12、CaC12不具催化活性,不会引起PVC突然变黑,长期热稳定性较好。 脂肪酸有机锡属中间型,既能吸收HCL,又能有效地以羧酸根取代PVC链上的不稳定氯原子,并且转化产物不具催化活性。 硫醇有机锡则具有全能型特征,能同时以各种机制稳定PVC,转化产物也不具催化活性,因此兼具优异的初期和长期热稳定效果。","categories":[{"name":"chemistry","slug":"chemistry","permalink":"http://cycoe.cc/categories/chemistry/"}],"tags":[]}]}