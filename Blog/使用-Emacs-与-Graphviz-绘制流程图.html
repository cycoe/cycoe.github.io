<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-05-15 Fri 22:06 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>使用 Emacs 与 Graphviz 绘制流程图</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="/static/css/default.css" />
</head>
<body>
<div id="preamble" class="status">
<header>
    <nav>Cycoe@Home</nav>
    <ul class="menu">
        <li><a href="/">Index</a></li>
        <li><a href="/Photo/index.html">Photo</a></li>
        <li><a href="/about.html">About</a></li>
    </ul>
</header>
</div>
<div id="content">
<h1 class="title">使用 Emacs 与 Graphviz 绘制流程图</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org616a38f">1. 安装</a>
<ul>
<li><a href="#org65ce001">1.1. Graphviz</a></li>
<li><a href="#org83a7754">1.2. graphviz-dot-mode</a></li>
</ul>
</li>
<li><a href="#orge23e7e7">2. 布局器</a></li>
<li><a href="#org7035d1e">3. 基本使用</a></li>
<li><a href="#orgacaab6e">4. 绘制属性</a>
<ul>
<li><a href="#orgdf21a75">4.1. 节点</a></li>
<li><a href="#orgf605fe0">4.2. 边</a></li>
<li><a href="#org8083ff3">4.3. 边的方向</a></li>
</ul>
</li>
<li><a href="#org4d899b4">5. 子图</a></li>
</ul>
</div>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/2020-03-11_10-40-29_app.png" alt="2020-03-11_10-40-29_app.png" />
</p>
</div>

<p>
前几天在写 <a href="使用-Emacs-与-Org-mode-进行-GTD-管理.html">使用 Emacs 与 Org mode 进行 GTD 管理</a> 博客时，用到了 <a href="http://www.graphviz.org/">Graphviz</a> 绘制流程
图。正巧之前在 LaTeX 中也用它画过一些图，但都没有系统地入过门，那就趁最近学习一
下吧。
</p>

<!-- more -->

<p>
从官网上可以看到，<a href="http://www.graphviz.org/">Graphviz</a> 的全称为<ruby>图<rt>Graph</rt>可视化
<rt>Visualization</rt>工具<rt>Software</rt></ruby>，这里的图说的应该不是数学意
义上的函数图像那种图，而是数据结构中的图，强调的关系。
</p>

<div id="outline-container-org616a38f" class="outline-2">
<h2 id="org616a38f"><span class="section-number-2">1</span> 安装</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org65ce001" class="outline-3">
<h3 id="org65ce001"><span class="section-number-3">1.1</span> Graphviz</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Graphviz 本质上是一个命令行工具，在 Archlinux 上只需要通过 <code>sudo pacman -S
graphviz</code> 安装即可，其他系统类似。
</p>
</div>
</div>

<div id="outline-container-org83a7754" class="outline-3">
<h3 id="org83a7754"><span class="section-number-3">1.2</span> graphviz-dot-mode</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Graphviz 在 Emacs 中的集成是通过 <code>graphviz-dot-mode</code> 这个包来实现的，只需要 <code>&lt;M-x&gt;
package-install graphviz-dot-mode &lt;RET&gt;</code> 即可。
</p>

<p>
然后在 Emacs 配置中加入以下内容来启用
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="font-weight: bold;">use-package</span> graphviz-dot-mode
  <span style="font-weight: bold;">:ensure</span> t
  <span style="font-weight: bold;">:config</span>
  (<span style="font-weight: bold;">setq</span> graphviz-dot-indent-width 4))

(<span style="font-weight: bold;">use-package</span> company-graphviz-dot)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orge23e7e7" class="outline-2">
<h2 id="orge23e7e7"><span class="section-number-2">2</span> 布局器</h2>
<div class="outline-text-2" id="text-2">
<p>
Graphviz 中包含了众多的布局器：
</p>
<ul class="org-ul">
<li>dot 默认布局方式，主要用于有向图</li>
<li>neato 基于 spring-model（又称 force-based）算法</li>
<li>twopi 径向布局</li>
<li>circo 圆环布局</li>
<li>fdp 用于无向图</li>
</ul>
</div>
</div>

<div id="outline-container-org7035d1e" class="outline-2">
<h2 id="org7035d1e"><span class="section-number-2">3</span> 基本使用</h2>
<div class="outline-text-2" id="text-3">
<p>
Graphviz 构建组件为图，节点，边，用属性对其进行描述。
</p>

<p>
创建一个 dot 布局的图，可以使用以下代码
</p>
<div class="org-src-container">
<pre class="src src-dot">digraph first{
    a;
    b;
    c;
    d;
    a-&gt;b;
    b-&gt;d;
    c-&gt;d;
}
</pre>
</div>


<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/first.png" alt="first.png" />
</p>
</div>

<p>
上述代码等价于
</p>
<div class="org-src-container">
<pre class="src src-dot">digraph first{
    a-&gt;b;
    b-&gt;d;
    c-&gt;d;
}
</pre>
</div>

<p>
如果要直接在命令行进行绘图，使用命令 <code>dot -Tpng first.dot -o first.png</code> 。如果利
用 Emacs Babel 进行绘制，需要如下所示的 Headers。
</p>
<div class="org-src-container">
<pre class="src src-org"><span style="font-weight: bold; font-style: italic;">#+begin_src dot :file first.png :cmdline -Tpng :results silent</span>
  digraph first{
      a-&gt;b;
      b-&gt;d;
      c-&gt;d;
  }
<span style="font-weight: bold; font-style: italic;">#+end_src</span>
</pre>
</div>

<p>
其中， <code>:results silent</code> 表示不在 Org 文件中进行任何输出。
</p>
</div>
</div>

<div id="outline-container-orgacaab6e" class="outline-2">
<h2 id="orgacaab6e"><span class="section-number-2">4</span> 绘制属性</h2>
<div class="outline-text-2" id="text-4">
<p>
一个图中可能有非常多的节点与边，如果每次都需要声明一个节点的属性会非常麻烦。类似
于面向对象编程的思想，我们可以用 <code>node</code> 和 <code>edge</code> 类标签来设置全局的属性，也可以用对
象标签设置单个节点与边的属性。
</p>

<div class="org-src-container">
<pre class="src src-dot">digraph G{
    // &#35774;&#32622;&#22270;&#29255;&#26368;&#22823;&#23610;&#23544;
    size = "40, 40";
    // &#35774;&#32622;&#33410;&#28857;&#25490;&#24067;&#26041;&#21521;
    rankdir = LR;
    // &#35774;&#32622;&#33410;&#28857;&#23383;&#20307;
    node[fontname="SimHei"];
    // &#35774;&#32622;&#36830;&#32447;&#23383;&#20307;
    edge[fontname="SimHei"];

    // &#35774;&#32622;&#40664;&#35748;&#33410;&#28857;&#23646;&#24615;
    node[shape=box, color=blue, style=unfilled];
    // &#35774;&#32622;&#36793;&#30340;&#23646;&#24615;
    edge[color=red];

    // &#33410;&#28857;
    &#23567;&#34013;;
    &#23567;&#32418;[color=red];
    // &#36793;
    &#23567;&#34013;-&gt;&#23567;&#32418;; // &#40664;&#35748;&#36793;&#23646;&#24615;
    &#23567;&#32418;-&gt;&#23567;&#34013;[color=blue, style=dashed]; // &#33258;&#23450;&#20041;&#36793;&#23646;&#24615;
}
</pre>
</div>

<p>
<a id="org92743f4"></a>
<img src="使用-Emacs-与-Graphviz-绘制流程图/property.png" alt="property.png" />
</p>

<p>
所有可用的属性见 <a href="https://graphviz.gitlab.io/_pages/doc/info/attrs.html">官网</a>，此处列举部分常用的属性
</p>
<ul class="org-ul">
<li><b>charset</b> 编码，一般设置 UTF-8</li>
<li><b>fontname</b> 字体名称，这个在中文的情况需要设置，否则导出图片的时候会乱码，一般设
置微软雅黑("Microsoft YaHei"), linux 下也是同样设置系统带的字体就好，其他字体
设置见fontpath 属性</li>
<li><b>fontcolor</b> 字体颜色</li>
<li><b>fontsize</b> 字体大小，用于文本内容</li>
<li><b>fillcolor</b> 用于填充节点或者集群(cluster)的背景颜色。</li>
<li><b>size</b> 图形的最大宽度和高度</li>
<li><b>label</b> 图形上的文本标记</li>
<li><b>margin</b> 设置图形的边距</li>
<li><b>pad</b> 指定将绘制区域扩展到绘制图形所需的最小区域的长度（以英寸为单位）</li>
<li><p>
<b>style</b> 设置图形组件的样式信息。 对于聚类子图或者节点，如果 style = filled，则
填充聚类框的背景
</p>


<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/Screenshot_20200311_143758_yfrBsd.png" alt="Screenshot_20200311_143758_yfrBsd.png" />
</p>
</div></li>

<li><p>
<b>rankdir</b> 设置图形布局的排列方向 (全局只有一个生效). "TB", "LR", "BT", "RL", 分
别对应于从上到下，从左到右，从下到上和从右到左绘制的有向图。
</p>

<div class="org-src-container">
<pre class="src src-dot">digraph {
    rankdir = RL;
    A-&gt;B-&gt;C[color=green];
    A-&gt;C[label="RL"];
}
</pre>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/rankdir.png" alt="rankdir.png" />
</p>
</div></li>

<li><b>ranksep</b> 以英寸为单位提供所需的排列间隔</li>
<li><b>ratio</b> 设置生成图片的纵横比</li>
</ul>
</div>

<div id="outline-container-orgdf21a75" class="outline-3">
<h3 id="orgdf21a75"><span class="section-number-3">4.1</span> 节点</h3>
<div class="outline-text-3" id="text-4-1">
<p>
节点的默认属性为 shape = ellipse, width = .75, height = 0.5 并且用节点标识符作为
节点的显示文字。
</p>

<p>
如 <a href="#org92743f4">图 1</a> 中所示，声明两个节点 <i>小蓝</i> 和 <i>小红/，/小蓝</i> 或 <i>小红</i> 就表示这个节点的节点标
识符，后面紧跟的是该节点的属性列表；另一种用法为 节点标识符:节点部分:方向[属性列
表] <code>小蓝:body[style=filled color=lightblue]</code>, 这个为单一节点声明的方式。
</p>

<p>
节点中的基本属性有
</p>
<ul class="org-ul">
<li><b>shape</b> 形状，全部形状见 <a href="https://graphviz.gitlab.io/_pages/doc/info/shapes.html">Graphviz 官网</a>，一些常用的图形有 box, circle, ellipse,
plaintext, square</li>
<li><b>width</b> <b>height</b>, 图形的宽度和高度，如果设置了 fixedsize 为 true，则宽和高为最终的
长度</li>
<li><b>fixedsize</b> 如果为false，节点的大小由其文本内容所需要的最小值决定</li>
<li><b>rank</b> 子图中节点上的排列等级约束. 最小等级是最顶部或最左侧，最大等级是最底部或
最右侧。
<ul class="org-ul">
<li>same. 所有节点都位于同一等级</li>
<li>min. 所有节点都位于最小等级上</li>
<li>source. 所有节点都位于最小等级上，并且最小等级上的唯一节点属于某个等级
source 或 min 的子图</li>
<li>max sink. 和上类似</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgf605fe0" class="outline-3">
<h3 id="orgf605fe0"><span class="section-number-3">4.2</span> 边</h3>
<div class="outline-text-3" id="text-4-2">
<p>
有向图中的的边用 <code>-&gt;</code> 表示，无向图用 <code>--</code> 表示。
</p>

<p>
可以同时连接多个节点或者子图，但是只能有一个属性列表，如下
</p>
<div class="org-src-container">
<pre class="src src-dot">digraph {
    rankdir = LR
    A -&gt; B -&gt; c[color=green]
}
</pre>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/edge_color.png" alt="edge_color.png" />
</p>
</div>

<p>
一些关于边的属性如下：
</p>
<ul class="org-ul">
<li><b>len</b> 首选边的长度</li>
<li><p>
<b>weight</b> 边的权重, 权重越大越接近边的长度
</p>

<p>
如果我们希望图中的绿色边为主要逻辑分支，需要设置 <code>A-&gt;B-&gt;C-&gt;D-&gt;F</code> 的权重最大，修改
绿色的分支的权重为 100，使其变成主要逻辑分支，修改后的效果如下
</p>

<div class="org-src-container">
<pre class="src src-dot">digraph {
    rankdir = LR
    splines = ortho

    A -&gt; B -&gt; C -&gt; D -&gt; F [color=green, weight=100]
    E -&gt; F -&gt; B -&gt; D [color=blue]
    B -&gt; E -&gt; H[color=red]
}
</pre>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/edge_weight.png" alt="edge_weight.png" />
</p>
</div></li>
<li><b>lhead</b> 逻辑边缘的头部(箭头那个位置)，compound 设置为 true 时，边被裁减到子图的边界处</li>
<li><b>ltail</b> 类似 lhead</li>
<li><b>headlabel</b> 边上靠近箭头部分的标签</li>
<li><b>taillabel</b> 边上靠近尾部部分的标签</li>
<li><b>splines</b> 控制如何显示边，取值可以是
<ul class="org-ul">
<li><p>
none 或者 "", 无边
</p>
<div class="org-src-container">
<pre class="src src-dot">digraph {
    rankdir = LR
    splines = none

    A -&gt; B -&gt; C -&gt; D -&gt; F [color=green]
    E -&gt; F -&gt; B -&gt; D [color=blue]
    B -&gt; E -&gt; H[color=red]
}
</pre>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/edge_splines_none.png" alt="edge_splines_none.png" />
</p>
</div></li>
<li><p>
true 或者 spline, 样条线（无规则，可为直或者曲线）
</p>
<div class="org-src-container">
<pre class="src src-dot">digraph {
    rankdir = LR
    splines = spline

    A -&gt; B -&gt; C -&gt; D -&gt; F [color=green]
    E -&gt; F -&gt; B -&gt; D [color=blue]
    B -&gt; E -&gt; H[color=red]
}
</pre>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/edge_splines_spline.png" alt="edge_splines_spline.png" />
</p>
</div></li>
<li><p>
false 或者 line, 直线
</p>
<div class="org-src-container">
<pre class="src src-dot">digraph {
    rankdir = LR
    splines = line

    A -&gt; B -&gt; C -&gt; D -&gt; F [color=green]
    E -&gt; F -&gt; B -&gt; D [color=blue]
    B -&gt; E -&gt; H[color=red]
}
</pre>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/edge_splines_line.png" alt="edge_splines_line.png" />
</p>
</div></li>
<li><p>
polyline, 折线
</p>
<div class="org-src-container">
<pre class="src src-dot">digraph {
    rankdir = LR
    splines = polyline

    A -&gt; B -&gt; C -&gt; D -&gt; F [color=green]
    E -&gt; F -&gt; B -&gt; D [color=blue]
    B -&gt; E -&gt; H[color=red]
}
</pre>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/edge_splines_polyline.png" alt="edge_splines_polyline.png" />
</p>
</div></li>
<li><p>
curved, 曲弧线，看起来像贝塞尔曲线
</p>
<div class="org-src-container">
<pre class="src src-dot">digraph {
    rankdir = LR
    splines = curved

    A -&gt; B -&gt; C -&gt; D -&gt; F [color=green]
    E -&gt; F -&gt; B -&gt; D [color=blue]
    B -&gt; E -&gt; H[color=red]
}
</pre>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/edge_splines_curved.png" alt="edge_splines_curved.png" />
</p>
</div></li>
<li><p>
ortho, 正交折线
</p>
<div class="org-src-container">
<pre class="src src-dot">digraph {
    rankdir = LR
    splines = ortho

    A -&gt; B -&gt; C -&gt; D -&gt; F [color=green]
    E -&gt; F -&gt; B -&gt; D [color=blue]
    B -&gt; E -&gt; H[color=red]
}
</pre>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/edge_splines_ortho.png" alt="edge_splines_ortho.png" />
</p>
</div></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org8083ff3" class="outline-3">
<h3 id="org8083ff3"><span class="section-number-3">4.3</span> 边的方向</h3>
<div class="outline-text-3" id="text-4-3">
<p>
<b>示例</b> 声明多部分节点，以及对各部分进行单独设置
</p>
<div class="org-src-container">
<pre class="src src-dot">node0 [label = "&lt;postid1&gt; string|&lt;postid2&gt; string|&lt;postid3&gt; string3", height=.5];
node0:head[color=lightblue];
</pre>
</div>

<div class="org-src-container">
<pre class="src src-dot">digraph action {
    node [shape = record,height=.1];

    node0 [label = "&lt;head&gt; head|&lt;body&gt; body|&lt;foot&gt; foot", height=.5]
    node2 [shape = box label="mind"]

    node0:head:n -&gt; node2:n [label = "n"]
    node0:head:ne -&gt; node2:ne [label = "ne"]
    node0:head:e -&gt; node2:e [label = "e"]
    node0:head:se -&gt; node2:se [label = "se"]
    node0:head:s -&gt; node2:s [label = "s"]
    node0:head:sw -&gt; node2:sw [label = "sw"]
    node0:head:w -&gt; node2:w [label = "w"]
    node0:head:nw -&gt; node2:nw [label = "nw"]
    node0:head:c -&gt; node2:c [label = "c"] // center&#65292;&#20013;&#38388;
    node0:head:_ -&gt; node2:_ [label = "_"] // &#20219;&#24847;

    node0:body[style=filled color=lightblue]
}
</pre>
</div>


<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/direction.png" alt="direction.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org4d899b4" class="outline-2">
<h2 id="org4d899b4"><span class="section-number-2">5</span> 子图</h2>
<div class="outline-text-2" id="text-5">
<p>
<b>subgraph</b> 必须配合 <b>cluster</b> 一起使用，用法为 =subgraph cluster* {} 。
</p>

<p>
需要设置 <b>compound</b> 为 true，则在群集之间留出边缘，子图的边界关系在 边 的定义中有给出，这里直接给个示例。
</p>

<div class="org-src-container">
<pre class="src src-dot">digraph G {
    compound = true  // &#20801;&#35768;&#23376;&#22270;&#38388;&#23384;&#22312;&#36793;
    ranksep = 1
    node [shape = record]

    subgraph cluster_hardware {
        label = "hardware"
        color = lightblue
        CPU Memory
    }

    subgraph cluster_kernel {
        label = "kernel"
        color = green
        Init IPC
    }

    subgraph cluster_libc {
        label = "libc"
        color = yellow
        glibc
    }

    CPU -&gt; Init [lhead = cluster_kernel ltail = cluster_hardware]
    IPC -&gt; glibc [lhead = cluster_libc ltail = cluster_kernel]
}
</pre>
</div>

<div class="figure">
<p><img src="使用-Emacs-与-Graphviz-绘制流程图/subgraph.png" alt="subgraph.png" />
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer>
    <img src="/img/Cc-logo-128x128.png" height="14px" width="14px" />
    本站文章如未特殊声明，默认采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">署名-非商业性使用-相同方式共享 2.5 中国大陆</a>进行许可。
</footer>
</div>
</body>
</html>
