<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-01-27 Sat 21:20 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>从零实现一个 Lisp 解释器第四篇－lambda 函数与控制语句</title>
<meta name="author" content="Cycoe" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="/static/css/default.css" />
<link rel="shortcut icon" type="image/png" href="/static/img/favicon.png"/>
<script language="JavaScript" type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script language="JavaScript" type="text/javascript" src="/static/js/main.js"></script>
</head>
<body>
<div id="preamble" class="status">
<div id="top-container">
  <a id="site-name" href="/">Cycoe<span id="at-home">@Home</span></a>
  <div id="banner">Keep It Simple Stupid</div>
</div>

<div id="top-nav">
  <div id="nav-wrapper">
    <div class="nav-btn" id="toc-wrapper">
      <span class="vertical-align">Ξ</span>
      <div id="go-top">
        <a href="javascript:window.scrollTo(0,0)" style="color: black !important; border-bottom: none !important;" class="tooltip" title="Go to the top of the page">
        <span class="top">&uarr;</span>
        </a></div>
    </div>
    <div id="nav-left-wrapper">
      <a class="nav-btn" id="photo-entry" href="/Photo/index.html" title="Photo">Photo</a>
      <a class="nav-btn" id="about-entry" href="/about.html" title="About Me">About</a>
      <div id="nav-title-wrapper">
        <span id="nav-title">从零实现一个 Lisp 解释器第四篇－lambda 函数与控制语句</span>
        <span id="nav-date">Written @<2023-03-10 Fri 12:39></span>
      </div>
    </div>
  </div>
</div>

<!-- The Modal -->
<div id="img-modal" class="modal">
  <!-- The Close Button -->
  <span class="close">&times;</span>
  <!-- Modal Content (The Image) -->
  <img class="modal-content" id="img-wrapper">
  <!-- Modal Caption (Image Text) -->
  <div id="caption"></div>
</div>
</div>
<div id="content" class="content">
<header>
<h1 class="title">从零实现一个 Lisp 解释器第四篇－lambda 函数与控制语句</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orge8d9a33">1. 本系列链接</a></li>
<li><a href="#orgbd0ebb3">2. lamdba 函数</a></li>
<li><a href="#orge21e34b">3. 函数签名</a></li>
<li><a href="#orgc8dbf20">4. 结构控制函数</a>
<ul>
<li><a href="#org0de17da">4.1. 分支判断</a></li>
<li><a href="#org27fcb2b">4.2. 比较函数</a></li>
</ul>
</li>
<li><a href="#org180cb2a">5. 递归与调用栈</a></li>
</ul>
</div>
</nav>

<div id="outline-container-orge8d9a33" class="outline-2">
<h2 id="orge8d9a33"><span class="section-number-2">1.</span> 本系列链接</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li><a href="从零实现一个-Lisp-解释器第一篇-类型定义与解析.html">从零实现一个-Lisp-解释器第一篇-类型定义与解析.html</a></li>
<li><a href="从零实现一个-Lisp-解释器第二篇-函数.html">从零实现一个-Lisp-解释器第二篇-函数.html</a></li>
<li><a href="从零实现一个-Lisp-解释器第三篇-状态与变量.html">从零实现一个-Lisp-解释器第三篇-状态与变量.html</a></li>
<li><a href="从零实现一个-Lisp-解释器第四篇-lambda-函数与控制语句.html">从零实现一个-Lisp-解释器第四篇-lambda-函数与控制语句.html</a></li>
</ul>

<p>
完整代码地址：<a href="https://github.com/cycoe/lisp-interpretor">https://github.com/cycoe/lisp-interpretor</a>
</p>

<p>
参考博客：<a href="https://www.defmacro.org/ramblings/lisp-in-haskell.html">https://www.defmacro.org/ramblings/lisp-in-haskell.html</a>
</p>
</div>
</div>

<div id="outline-container-orgbd0ebb3" class="outline-2">
<h2 id="orgbd0ebb3"><span class="section-number-2">2.</span> lamdba 函数</h2>
<div class="outline-text-2" id="text-2">
<p>
在函数式编程语言中，lambda 函数是一个非常通用的概念，表示一类没有别名只有函数定义的函数对象。在 lisp 中 lambda 函数可以用如下的形式进行表示
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #00af00;">lambda</span> (x) (* x x))
</pre>
</div>

<p>
其中 <code>lambda</code> 是一个内置的函数符号，表示当前的列表是一个 lambda 函数定义。紧跟 <code>lambda</code> 之后的 <code>(x)</code> 是该函数形参列表，表示该函数接收一个参数并将其绑定到 <code>x</code> 。最后一部分的 <code>(* x x)</code> 是函数体表达式，是当前函数的返回值。
</p>

<p>
那么我们可以将这个 lambda 函数作为一个函数对象进行调用。
</p>

<div class="org-src-container">
<pre class="src src-lisp">((<span style="color: #00af00;">lambda</span> (x) (* x x)) 2)
</pre>
</div>

<p>
或者我们可以像绑定其他对象一样将这个 lambda 函数绑定到一个符号 f 上，并使用这个符号进行调用。
</p>

<div class="org-src-container">
<pre class="src src-lisp">(set f (<span style="color: #00af00;">lambda</span> (x) (* x x))))
(f 2)
</pre>
</div>
</div>
</div>

<div id="outline-container-orge21e34b" class="outline-2">
<h2 id="orge21e34b"><span class="section-number-2">3.</span> 函数签名</h2>
<div class="outline-text-2" id="text-3">
<p>
为了实现上面的 lambda 函数定义的功能，我们可以定义一个内置函数关键字 lambda，它接受一个参数列表和一个函数体表达式，并返回构造出的 LispFunc 函数。但我们注意到，函数的定义和函数的调用过程是分开的，因此我们需要一种方式实现中间的参数传递过程。一种最简单的方式就是定义函数签名，在函数调用时通过函数签名去上下文中获取参数传入函数。
</p>

<p>
第一步我们需要定义函数签名的类型并修改我们的 LispFunc 和 LispQuot 定义，将函数签名也作为它们的一部分。这里我们将函数签名定义为 String 的列表。同时需要注意我们的 LispFunc 类型中第一个成员类型由 <code>[LispExpr] -&gt; LispState</code> 变为了 <code>LispState</code> ，这是因为函数参数改为从状态中获取无需再显式传入。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00af00;">data</span> <span style="color: #18b2b2;">LispExpr</span> <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">LispInt</span> <span style="color: #18b2b2;">Integer</span>
              <span style="color: #ff8700;">|</span> <span style="color: #18b2b2;">LispSymbol</span> <span style="color: #18b2b2;">String</span>
              <span style="color: #ff8700;">|</span> <span style="color: #18b2b2;">LispFunc</span> <span style="color: #18b2b2;">LispState</span> <span style="color: #18b2b2;">FunctionSignature</span>
              <span style="color: #ff8700;">|</span> <span style="color: #18b2b2;">LispQuot</span> <span style="color: #18b2b2;">LispState</span> <span style="color: #18b2b2;">FunctionSignature</span>
              <span style="color: #ff8700;">|</span> <span style="color: #18b2b2;">LispList</span> [<span style="color: #18b2b2;">LispExpr</span>]

<span style="color: #00af00;">type</span> <span style="color: #18b2b2;">FunctionSignature</span> <span style="color: #ff8700;">=</span> [<span style="color: #18b2b2;">String</span>]
</pre>
</div>

<p>
对应的 show 函数也需要做一些修改，现在我们可以打印出函数对应的签名了。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00af00;">instance</span> <span style="color: #18b2b2;">Show</span> <span style="color: #18b2b2;">LispExpr</span> <span style="color: #00af00;">where</span>
  show <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">LispExpr</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">String</span>
  show (<span style="color: #18b2b2;">LispFunc</span> <span style="color: #00af00;">_</span> sign) <span style="color: #ff8700;">=</span> <span style="color: #ff1f8b;">"&lt;function&gt;"</span> <span style="color: #ff8700;">++</span> show sign
  show (<span style="color: #18b2b2;">LispQuot</span> <span style="color: #00af00;">_</span> sign) <span style="color: #ff8700;">=</span> <span style="color: #ff1f8b;">"&lt;special-form&gt;"</span> <span style="color: #ff8700;">++</span> show sign
</pre>
</div>

<p>
最大的变化在 <code>eval</code> 函数，我们将 LispList 的整个求值过程可以分为两步。第一步为 <code>applyArgsToContext expectedArgs args</code> ，在这一步我们将函数签名中期望的参数名称和实际函数应用的参数一一对应起来并写入状态；第二步我们调用函数 <code>f</code> ，在这一步函数将根据函数签名从状态中取出参数并进行函数求值。 <code>...</code> 是我们定义的一个特殊参数签名，代表匹配剩余的所有参数。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">eval</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">LispExpr</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispState</span>
<span style="color: #ef2929;">eval</span> (<span style="color: #18b2b2;">LispFunc</span> f sign)  <span style="color: #ff8700;">=</span> return <span style="color: #ff8700;">$</span> <span style="color: #18b2b2;">LispFunc</span> f sign
<span style="color: #ef2929;">eval</span> (<span style="color: #18b2b2;">LispQuot</span> f sign)  <span style="color: #ff8700;">=</span> return <span style="color: #ff8700;">$</span> <span style="color: #18b2b2;">LispQuot</span> f sign
<span style="color: #ef2929;">eval</span> (<span style="color: #18b2b2;">LispList</span> (x<span style="color: #18b2b2;">:</span>xs))  <span style="color: #ff8700;">=</span> eval x <span style="color: #ff8700;">&gt;&gt;=</span> apply <span style="color: #00af00;">where</span>
  apply (<span style="color: #18b2b2;">LispQuot</span> f expectedArgs) <span style="color: #ff8700;">=</span> apply' expectedArgs xs f
  apply (<span style="color: #18b2b2;">LispFunc</span> f expectedArgs) <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
    args <span style="color: #ff8700;">&lt;-</span> mapM eval xs
    apply' expectedArgs args f
  apply expr <span style="color: #ff8700;">=</span> throwError <span style="color: #ff8700;">$</span> <span style="color: #ff1f8b;">"[eval] "</span> <span style="color: #ff8700;">++</span> show expr <span style="color: #ff8700;">++</span> <span style="color: #ff1f8b;">" cannot call as function"</span>
  apply' <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FunctionSignature</span> <span style="color: #ff8700;">-&gt;</span> [<span style="color: #18b2b2;">LispExpr</span>] <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispState</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispState</span>
  apply' expectedArgs args f <span style="color: #ff8700;">=</span> applyArgsToContext expectedArgs args <span style="color: #ff8700;">&gt;&gt;</span> f
  applyArgsToContext <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FunctionSignature</span> <span style="color: #ff8700;">-&gt;</span> [<span style="color: #18b2b2;">LispExpr</span>] <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">StateT</span> <span style="color: #18b2b2;">Context</span> <span style="color: #18b2b2;">LispError</span> <span style="color: #18b2b2;">()</span>
  applyArgsToContext (<span style="color: #ff1f8b;">"..."</span><span style="color: #18b2b2;">:</span><span style="color: #00af00;">_</span>) args <span style="color: #ff8700;">=</span> modify <span style="color: #ff8700;">$</span> Map.insert <span style="color: #ff1f8b;">"..."</span> (<span style="color: #18b2b2;">LispList</span> args)
  applyArgsToContext <span style="color: #18b2b2;">[]</span> <span style="color: #00af00;">_</span> <span style="color: #ff8700;">=</span> return <span style="color: #18b2b2;">()</span>
  applyArgsToContext (earg<span style="color: #18b2b2;">:</span>eargs) (arg<span style="color: #18b2b2;">:</span>args) <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
    modify <span style="color: #ff8700;">$</span> Map.insert earg arg
    applyArgsToContext eargs args
<span style="color: #ef2929;">eval</span> (<span style="color: #18b2b2;">LispList</span> <span style="color: #18b2b2;">[]</span>) <span style="color: #ff8700;">=</span> throwError <span style="color: #ff1f8b;">"[eval] Cannot eval empty list"</span>
</pre>
</div>

<p>
为了方便从状态中获取符号和函数签名绑定的参数表达式，我们再定义两个工具函数 <code>getSymbol</code> 和 <code>getSymbols</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">getSymbol</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">String</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispState</span>
<span style="color: #ef2929;">getSymbol</span> symbol <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
  ctx <span style="color: #ff8700;">&lt;-</span> get
  <span style="color: #00af00;">if</span> symbol <span style="color: #ff8700;">`Map.member`</span> ctx
  <span style="color: #00af00;">then</span> return <span style="color: #ff8700;">$</span> ctx <span style="color: #ff8700;">Map.!</span> symbol
  <span style="color: #00af00;">else</span> throwError <span style="color: #ff8700;">$</span> <span style="color: #ff1f8b;">"[getSymbol] symbol ["</span> <span style="color: #ff8700;">++</span> symbol <span style="color: #ff8700;">++</span> <span style="color: #ff1f8b;">"] NOT in context!"</span>

<span style="color: #ef2929;">getSymbols</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FunctionSignature</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">StateT</span> <span style="color: #18b2b2;">Context</span> <span style="color: #18b2b2;">LispError</span> [<span style="color: #18b2b2;">LispExpr</span>]
<span style="color: #ef2929;">getSymbols</span> <span style="color: #ff8700;">=</span> mapM getSymbol
</pre>
</div>

<p>
最后我们可以实现 <code>lispLambda</code> 函数用于 lambda 函数的定义，lambda 函数调用时从状态中获取 args 和 body 两个参数，分别代表形参列表和函数体表达式。返回由函数体和形参列表生成的函数签名组成的函数 LispFunc 就是我们通过 lambda 关键字定义的新函数。同样的，其他函数也需要做一下相应的修改来适配我们的新代码。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">lispSetArgs</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FunctionSignature</span>
<span style="color: #ef2929;">lispSetArgs</span> <span style="color: #ff8700;">=</span> [<span style="color: #ff1f8b;">"symbol"</span>, <span style="color: #ff1f8b;">"expr"</span>]
<span style="color: #ef2929;">lispSet</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">LispState</span>
<span style="color: #ef2929;">lispSet</span> <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
  [<span style="color: #18b2b2;">LispSymbol</span> s, expr] <span style="color: #ff8700;">&lt;-</span> getSymbols lispSetArgs
  eval_e <span style="color: #ff8700;">&lt;-</span> eval expr
  modify <span style="color: #ff8700;">$</span> Map.insert s eval_e
  return eval_e

<span style="color: #ef2929;">lispLambdaArgs</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FunctionSignature</span>
<span style="color: #ef2929;">lispLambdaArgs</span> <span style="color: #ff8700;">=</span> [<span style="color: #ff1f8b;">"args"</span>, <span style="color: #ff1f8b;">"body"</span>]
<span style="color: #ef2929;">lispLambda</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">LispState</span>
<span style="color: #ef2929;">lispLambda</span> <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
  [<span style="color: #18b2b2;">LispList</span> args, body] <span style="color: #ff8700;">&lt;-</span> getSymbols lispLambdaArgs
  return <span style="color: #ff8700;">$</span> <span style="color: #18b2b2;">LispFunc</span> (eval body) ((<span style="color: #ff8700;">\</span>(<span style="color: #18b2b2;">LispSymbol</span> arg) <span style="color: #ff8700;">-&gt;</span> arg) <span style="color: #ff8700;">&lt;$&gt;</span> args)

<span style="color: #ef2929;">intBinaryOp</span> <span style="color: #ff8700;">::</span> (<span style="color: #18b2b2;">Integer</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Integer</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Integer</span>) <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispState</span>
<span style="color: #ef2929;">intBinaryOp</span> op <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
  <span style="color: #18b2b2;">LispList</span> (x<span style="color: #18b2b2;">:</span>xs) <span style="color: #ff8700;">&lt;-</span> getSymbol <span style="color: #ff1f8b;">"..."</span>
  return <span style="color: #ff8700;">.</span> <span style="color: #18b2b2;">LispInt</span> <span style="color: #ff8700;">$</span> foldl op (unwrapInt x) (map unwrapInt xs) <span style="color: #00af00;">where</span>
  unwrapInt <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">LispExpr</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Integer</span>
  unwrapInt (<span style="color: #18b2b2;">LispInt</span> i) <span style="color: #ff8700;">=</span> i
  unwrapInt expr        <span style="color: #ff8700;">=</span> undefined

<span style="color: #ef2929;">symbols</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Context</span>
<span style="color: #ef2929;">symbols</span> <span style="color: #ff8700;">=</span> Map.fromList
  [ (<span style="color: #ff1f8b;">"set"</span>, <span style="color: #18b2b2;">LispQuot</span> lispSet lispSetArgs)
  , (<span style="color: #ff1f8b;">"lambda"</span>, <span style="color: #18b2b2;">LispQuot</span> lispLambda lispLambdaArgs)
  , (<span style="color: #ff1f8b;">"+"</span>, <span style="color: #18b2b2;">LispFunc</span> (intBinaryOp (<span style="color: #ff8700;">+</span>)) [<span style="color: #ff1f8b;">"..."</span>])
  , (<span style="color: #ff1f8b;">"-"</span>, <span style="color: #18b2b2;">LispFunc</span> (intBinaryOp (<span style="color: #ff8700;">-</span>)) [<span style="color: #ff1f8b;">"..."</span>])
  , (<span style="color: #ff1f8b;">"*"</span>, <span style="color: #18b2b2;">LispFunc</span> (intBinaryOp (<span style="color: #ff8700;">*</span>)) [<span style="color: #ff1f8b;">"..."</span>])
  , (<span style="color: #ff1f8b;">"/"</span>, <span style="color: #18b2b2;">LispFunc</span> (intBinaryOp div) [<span style="color: #ff1f8b;">"..."</span>])
  ]
</pre>
</div>

<p>
完成！让我们来试一下定义一个 double 函数将传入的值翻倍。
</p>

<div class="org-src-container">
<pre class="src src-haskell">ghci<span style="color: #ef2929;">&gt;</span> runInputT defaultSettings (shell symbols)
lisp<span style="color: #ef2929;">&gt;</span> (set double (lambda (x) (<span style="color: #ff8700;">*</span> x 2)))
(fromList [(<span style="color: #ff1f8b;">"*"</span>,<span style="color: #ff8700;">&lt;</span>function<span style="color: #ff8700;">&gt;</span>[<span style="color: #ff1f8b;">"..."</span>]),(<span style="color: #ff1f8b;">"+"</span>,<span style="color: #ff8700;">&lt;</span>function<span style="color: #ff8700;">&gt;</span>[<span style="color: #ff1f8b;">"..."</span>]),(<span style="color: #ff1f8b;">"-"</span>,<span style="color: #ff8700;">&lt;</span>function<span style="color: #ff8700;">&gt;</span>[<span style="color: #ff1f8b;">"..."</span>]),(<span style="color: #ff1f8b;">"/"</span>,<span style="color: #ff8700;">&lt;</span>function<span style="color: #ff8700;">&gt;</span>[<span style="color: #ff1f8b;">"..."</span>]
l<span style="color: #ef2929;">-</span>form<span style="color: #ff8700;">&gt;</span>[<span style="color: #ff1f8b;">"args"</span>,<span style="color: #ff1f8b;">"body"</span>]),(<span style="color: #ff1f8b;">"set"</span>,<span style="color: #ff8700;">&lt;</span>special<span style="color: #ff8700;">-</span>form<span style="color: #ff8700;">&gt;</span>[<span style="color: #ff1f8b;">"symbol"</span>,<span style="color: #ff1f8b;">"expr"</span>]),(<span style="color: #ff1f8b;">"symbol"</span>,double)],<span style="color: #ff8700;">&lt;</span>function<span style="color: #ff8700;">&gt;</span>[<span style="color: #ff1f8b;">"x"</span>])
lisp<span style="color: #ef2929;">&gt;</span> (double 10)
(fromList [(<span style="color: #ff1f8b;">"*"</span>,<span style="color: #ff8700;">&lt;</span>function<span style="color: #ff8700;">&gt;</span>[<span style="color: #ff1f8b;">"..."</span>]),(<span style="color: #ff1f8b;">"+"</span>,<span style="color: #ff8700;">&lt;</span>function<span style="color: #ff8700;">&gt;</span>[<span style="color: #ff1f8b;">"..."</span>]),(<span style="color: #ff1f8b;">"-"</span>,<span style="color: #ff8700;">&lt;</span>function<span style="color: #ff8700;">&gt;</span>[<span style="color: #ff1f8b;">"..."</span>]),(<span style="color: #ff1f8b;">"..."</span>,(10 2)),(<span style="color: #ff1f8b;">"/"</span>,<span style="color: #ff8700;">&lt;</span>f
lambda<span style="color: #ff1f8b;">",&lt;special-form&gt;["</span>args<span style="color: #ff1f8b;">","</span>body<span style="color: #ff1f8b;">"]),("</span>set<span style="color: #ff1f8b;">",&lt;special-form&gt;["</span>symbol<span style="color: #ff1f8b;">","</span>expr<span style="color: #ff1f8b;">"]),("</span>symbol<span style="color: #ff1f8b;">",double),("</span>x<span style="color: #cc0000; font-weight: bold;">"</span><span style="color: #ff1f8b;">,10)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc8dbf20" class="outline-2">
<h2 id="orgc8dbf20"><span class="section-number-2">4.</span> 结构控制函数</h2>
<div class="outline-text-2" id="text-4">
<p>
到目前为止我们已经能够使用我们的 Lisp 解释器进行简单的函数定义和求值，但是它还缺少一些非常重要的功能，那就是分支判断和循环等结构控制函数。这些函数的逻辑无法通过我们目前已有的关键字进行实现，因此我们需要将它们实现为内置的函数关键字。
</p>
</div>

<div id="outline-container-org0de17da" class="outline-3">
<h3 id="org0de17da"><span class="section-number-3">4.1.</span> 分支判断</h3>
<div class="outline-text-3" id="text-4-1">
<p>
函数式语言中的 if 关键字和 c 语言中的三目条件运算符很相似，是一个接收三个参数的函数，分别为条件表达式 cond、条件为真时的返回值 expr1 和条件为假时的返回值 expr2。expr1 和 expr2 可以为任意的 Lisp 表达式，而 cond 由于我们并未定义布尔类型，这里可以采用和 c 语言中一样的策略，整数零代表假而非零为真。需要注意的是，这里我们将 if 函数定义为 LispQuot 类型，保证参数在传入时不被求值，只有满足条件的分支才被手动求值。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">lispIfArgs</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FunctionSignature</span>
<span style="color: #ef2929;">lispIfArgs</span> <span style="color: #ff8700;">=</span> [<span style="color: #ff1f8b;">"cond"</span>, <span style="color: #ff1f8b;">"expr1"</span>, <span style="color: #ff1f8b;">"expr2"</span>]
<span style="color: #ef2929;">lispIf</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">LispState</span>
<span style="color: #ef2929;">lispIf</span> <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
  [cond, expr1, expr2] <span style="color: #ff8700;">&lt;-</span> getSymbols lispIfArgs
  econd <span style="color: #ff8700;">&lt;-</span> eval cond
  <span style="color: #00af00;">case</span> econd <span style="color: #00af00;">of</span>
    <span style="color: #18b2b2;">LispInt</span> i <span style="color: #ff8700;">-&gt;</span> eval <span style="color: #ff8700;">$</span> <span style="color: #00af00;">if</span> i <span style="color: #ff8700;">/=</span> 0 <span style="color: #00af00;">then</span> expr1 <span style="color: #00af00;">else</span> expr2
    e         <span style="color: #ff8700;">-&gt;</span> throwError <span style="color: #ff8700;">$</span> <span style="color: #ff1f8b;">"[lispIf] expr ["</span> <span style="color: #ff8700;">++</span> show e
                              <span style="color: #ff8700;">++</span> <span style="color: #ff1f8b;">"] CANNOT be a condition!"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org27fcb2b" class="outline-3">
<h3 id="org27fcb2b"><span class="section-number-3">4.2.</span> 比较函数</h3>
<div class="outline-text-3" id="text-4-2">
<p>
虽然比较函数并不属于结构控制函数，但是我们会在分支和循环的条件判断中用到它。为了方便后面的演示和代码开发，我们先实现比较函数 lispCmp 和对布尔值取非的 not 函数，有了前面的经验，这两个函数的实现都非常简单。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">lispCmpArgs</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FunctionSignature</span>
<span style="color: #ef2929;">lispCmpArgs</span> <span style="color: #ff8700;">=</span> [<span style="color: #ff1f8b;">"left"</span>, <span style="color: #ff1f8b;">"right"</span>]
<span style="color: #ef2929;">lispCmp</span> <span style="color: #ff8700;">::</span> (<span style="color: #18b2b2;">Integer</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Integer</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Bool</span>) <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispState</span>
<span style="color: #ef2929;">lispCmp</span> op <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
  [l, r] <span style="color: #ff8700;">&lt;-</span> getSymbols lispCmpArgs
  <span style="color: #00af00;">case</span> (l, r) <span style="color: #00af00;">of</span>
    (<span style="color: #18b2b2;">LispInt</span> li, <span style="color: #18b2b2;">LispInt</span> ri) <span style="color: #ff8700;">-&gt;</span> return <span style="color: #ff8700;">.</span> <span style="color: #18b2b2;">LispInt</span> <span style="color: #ff8700;">$</span> <span style="color: #00af00;">if</span> li <span style="color: #ff8700;">`op`</span> ri <span style="color: #00af00;">then</span> 1 <span style="color: #00af00;">else</span> 0
    (lo, ro) <span style="color: #ff8700;">-&gt;</span> throwError <span style="color: #ff8700;">$</span> <span style="color: #ff1f8b;">"[lispCmp] expr1 ["</span> <span style="color: #ff8700;">++</span> show lo
                          <span style="color: #ff8700;">++</span> <span style="color: #ff1f8b;">"] and expr2["</span> <span style="color: #ff8700;">++</span> show ro <span style="color: #ff8700;">++</span> <span style="color: #ff1f8b;">"] MUST be LispInt!"</span>

<span style="color: #ef2929;">lispNotArgs</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FunctionSignature</span>
<span style="color: #ef2929;">lispNotArgs</span> <span style="color: #ff8700;">=</span> [<span style="color: #ff1f8b;">"cond"</span>]
<span style="color: #ef2929;">lispNot</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">LispState</span>
<span style="color: #ef2929;">lispNot</span> <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
  [cond] <span style="color: #ff8700;">&lt;-</span> getSymbols lispNotArgs
  <span style="color: #00af00;">case</span> cond <span style="color: #00af00;">of</span>
    <span style="color: #18b2b2;">LispInt</span> i <span style="color: #ff8700;">-&gt;</span> return <span style="color: #ff8700;">.</span> <span style="color: #18b2b2;">LispInt</span> <span style="color: #ff8700;">$</span> <span style="color: #00af00;">if</span> i <span style="color: #ff8700;">==</span> 0 <span style="color: #00af00;">then</span> 1 <span style="color: #00af00;">else</span> 0
    other <span style="color: #ff8700;">-&gt;</span> throwError <span style="color: #ff8700;">$</span> <span style="color: #ff1f8b;">"[lispNot] cond ["</span> <span style="color: #ff8700;">++</span> show other <span style="color: #ff8700;">++</span> <span style="color: #ff1f8b;">"] MUST be LispInt!"</span>
</pre>
</div>

<p>
有了 lispCmp 函数，比较相等、不等、大于小于等操作都可以通过传入 Haskell 的比较函数实现。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">symbols</span> <span style="color: #ff8700;">=</span> Map.fromList
  [ (<span style="color: #ff1f8b;">"eq"</span>, <span style="color: #18b2b2;">LispFunc</span> (lispCmp (<span style="color: #ff8700;">==</span>)) lispCmpArgs)
  , (<span style="color: #ff1f8b;">"ne"</span>, <span style="color: #18b2b2;">LispFunc</span> (lispCmp (<span style="color: #ff8700;">/=</span>)) lispCmpArgs)
  , (<span style="color: #ff1f8b;">"gt"</span>, <span style="color: #18b2b2;">LispFunc</span> (lispCmp (<span style="color: #ff8700;">&gt;</span>)) lispCmpArgs)
  , (<span style="color: #ff1f8b;">"ge"</span>, <span style="color: #18b2b2;">LispFunc</span> (lispCmp (<span style="color: #ff8700;">&gt;=</span>)) lispCmpArgs)
  , (<span style="color: #ff1f8b;">"lt"</span>, <span style="color: #18b2b2;">LispFunc</span> (lispCmp (<span style="color: #ff8700;">&lt;</span>)) lispCmpArgs)
  , (<span style="color: #ff1f8b;">"le"</span>, <span style="color: #18b2b2;">LispFunc</span> (lispCmp (<span style="color: #ff8700;">&lt;=</span>)) lispCmpArgs)
  , (<span style="color: #ff1f8b;">"not"</span>, <span style="color: #18b2b2;">LispFunc</span> lispNot lispNotArgs)]
</pre>
</div>

<p>
通过结构控制函数，我们可以实现第一个真正意义上包含逻辑功能的函数，比如我们可以实现绝对值函数 <code>abs</code>
</p>

<div class="org-src-container">
<pre class="src src-lisp">lisp&gt; (set abs (<span style="color: #00af00;">lambda</span> (x) (<span style="color: #00af00;">if</span> (lt x 0) (- 0 x) x)))
&lt;function&gt;[<span style="color: #ff1f8b;">"x"</span>]
lisp&gt; (abs 1)
1
lisp&gt; (abs -1)
1
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org180cb2a" class="outline-2">
<h2 id="org180cb2a"><span class="section-number-2">5.</span> 递归与调用栈</h2>
<div class="outline-text-2" id="text-5">
<p>
要如何实现循环？这个问题在函数式语言中一般是通过递归来解决。我们的解释器支持递归嗎？让我们先来试着定义一个求阶乘的递归函数。
</p>

<p>
这个函数非常简单，当传入的 <code>x</code> 为 0 时为递归终止条件我们直接返回 1；当 <code>x</code> 不为 0 时函数返回 <code>x</code> 和 (x-1) 阶乘的乘积。让我们传入 5 求一下阶乘的结果。
</p>

<div class="org-src-container">
<pre class="src src-lisp">lisp&gt; (set prod (<span style="color: #00af00;">lambda</span> (x) (<span style="color: #00af00;">if</span> (eq x 0) 1 (* x (prod (- x 1))))))
&lt;function&gt;[<span style="color: #ff1f8b;">"x"</span>]
lisp&gt; (prod 5)
120
</pre>
</div>

<p>
竟然得到了正确的结果，这是怎么做到的呢？让我们来分析一下整个调用过程。递归函数的调用可以分为参数向下传递，以及到达终于条件后结果向上回归两个过程。
</p>

<div class="org-src-container">
<pre class="src src-lisp">(prod 5)
(* 5 (prod 4))
(* 5 (* 4 (prod 3)))
(* 5 (* 4 (* 3 (prod 2))))
(* 5 (* 4 (* 3 (* 2 (prod 1)))))
(* 5 (* 4 (* 3 (* 2 (* 1 (prod 0))))))
(* 5 (* 4 (* 3 (* 2 (* 1 1)))))
(* 5 (* 4 (* 3 (* 2 1))))
(* 5 (* 4 (* 3 2)))
(* 5 (* 4 6))
(* 5 24)
120
</pre>
</div>

<p>
可以看到，整个调用和求值过程没有问题，但是真的是这样嗎？我们可以试着把 <code>x</code> 和 <code>(prod (- x 1))</code> 的顺序换一下。
</p>

<div class="org-src-container">
<pre class="src src-lisp">lisp&gt; (set prod (<span style="color: #00af00;">lambda</span> (x) (<span style="color: #00af00;">if</span> (eq x 0) 1 (* (prod (- x 1)) x))))
&lt;function&gt;[<span style="color: #ff1f8b;">"x"</span>]
lisp&gt; (prod 5)
0
</pre>
</div>

<p>
结果竟然变成了零！说明我们的解释器在处理递归时还有 bug。问题出在哪里？我们可以先分析一下递归参数向下传递的部分。
</p>

<div class="org-src-container">
<pre class="src src-lisp">(prod 5)
(* (prod 4) x)
(* (* (prod 3) x) x)
(* (* (* (prod 2) x) x) x)
(* (* (* (* (prod 1) x) x) x) x)
(* (* (* (* (* (prod 0) x) x) x) x) x)
</pre>
</div>

<p>
这里与上面的 prod 定义方式一个很明显的不同之处就是，由于函数中 <code>x</code> 的位置在 <code>(prod (- x 1))</code> 之后，导致 <code>x</code> 的求值在整个递归过程到达终止条件并且开始回归之后才会进行。当调用到 <code>(prod 0)</code> 时事情开始变得不同，0 作为参数 <code>x</code> 的值被传入函数，这个时候我们的状态表中就保存了符号 <code>x</code> 对应的值为 0。当 <code>(prod 0)</code> 调用完成后会返回结果为 1，但此时状态表中的 <code>x</code> 绑定的始终是 0，导致后续对 <code>x</code> 进行求值的结果全部为 0。
</p>

<div class="org-src-container">
<pre class="src src-lisp">(* (* (* (* (* (prod 0) x) x) x) x) x)
(* (* (* (* (* 1 0) x) x) x) x)
(* (* (* (* 0 0) x) x) x)
(* (* (* 0 0) x) x)
(* (* 0 0) x)
(* 0 0)
0
</pre>
</div>

<p>
问题出现的根本原因在于我们的递归函数中有些表达式在递归函数自身之后求值，导致之前调用的函数的参数对后面用到同名参数的表达式产生了干扰。解决这个问题的一个办法是为每一次函数调用都绑定一个栈空间，并且这个栈空间在函数调用完成之后就被销毁，这样函数的局部变量就拥有了生命周期，不同函数之间也不会产生影响。
</p>

<p>
首先我们来定义一下我们的栈空间类型，先将原先的符号映射表类型改名为 <code>SymbolTable</code> ，再将 <code>Context</code> 定义为一个链表的形式。 <code>Context</code> 由一个 SymbolTable 和一个可能指向下一个 Context 节点的 <code>Maybe</code> 对象组成。如果 Maybe 为 <code>Nothing</code> 表示当前栈帧为栈底。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00af00;">type</span> <span style="color: #18b2b2;">SymbolTable</span> <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Map.Map</span> <span style="color: #18b2b2;">String</span> <span style="color: #18b2b2;">LispExpr</span>
<span style="color: #00af00;">data</span> <span style="color: #18b2b2;">Context</span>     <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Context</span> <span style="color: #18b2b2;">SymbolTable</span> (<span style="color: #18b2b2;">Maybe</span> <span style="color: #18b2b2;">Context</span>) <span style="color: #00af00;">deriving</span> <span style="color: #18b2b2;">Show</span>
</pre>
</div>

<p>
为了对栈空间进行操作，我们需要定义 4 个工具函数。 <code>pushContext</code> 将一个空的符号表压入栈； <code>popContext</code> 将栈顶的符号表弹出，如果当前帧已经是栈底则不做处理； <code>updateSymbol</code> 将一个符号和对应的表达式更新到栈顶的符号表中； <code>updateSymbolInParent</code> 函数比较特殊，它将符号和对应的表达式更新到栈顶的上一层栈帧。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">pushContext</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Context</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Context</span>
<span style="color: #ef2929;">pushContext</span> ctx <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Context</span> Map.empty (<span style="color: #18b2b2;">Just</span> ctx)

<span style="color: #ef2929;">popContext</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Context</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Context</span>
<span style="color: #ef2929;">popContext</span> (<span style="color: #18b2b2;">Context</span> <span style="color: #00af00;">_</span> (<span style="color: #18b2b2;">Just</span> parent)) <span style="color: #ff8700;">=</span> parent

<span style="color: #ef2929;">updateSymbol</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">String</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispExpr</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">StateT</span> <span style="color: #18b2b2;">Context</span> <span style="color: #18b2b2;">LispError</span> <span style="color: #18b2b2;">()</span>
<span style="color: #ef2929;">updateSymbol</span> symbol expr <span style="color: #ff8700;">=</span> modify <span style="color: #ff8700;">$</span> <span style="color: #ff8700;">\</span>(<span style="color: #18b2b2;">Context</span> st mp) <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Context</span> (Map.insert symbol expr st) mp

<span style="color: #ef2929;">updateSymbolInParent</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">String</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispExpr</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">StateT</span> <span style="color: #18b2b2;">Context</span> <span style="color: #18b2b2;">LispError</span> <span style="color: #18b2b2;">()</span>
<span style="color: #ef2929;">updateSymbolInParent</span> symbol expr <span style="color: #ff8700;">=</span> modify <span style="color: #ff8700;">$</span> <span style="color: #ff8700;">\</span>(<span style="color: #18b2b2;">Context</span> st mp) <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Context</span> st (update mp) <span style="color: #00af00;">where</span>
  update (<span style="color: #18b2b2;">Just</span> (<span style="color: #18b2b2;">Context</span> st mp)) <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Just</span> (<span style="color: #18b2b2;">Context</span> (Map.insert symbol expr st) mp)
</pre>
</div>

<p>
<code>getSymbol</code> 函数现在查找符号需要依次从栈顶查找到栈底，对应了当前作用域不存在变量则去外层作用域查找的操作。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">getSymbol</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">String</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispState</span>
<span style="color: #ef2929;">getSymbol</span> symbol <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
  ctx <span style="color: #ff8700;">&lt;-</span> get
  getSymbolFrom symbol ctx <span style="color: #00af00;">where</span>
    getSymbolFrom <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">String</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Context</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispState</span>
    getSymbolFrom symbol (<span style="color: #18b2b2;">Context</span> st mp) <span style="color: #ff8700;">=</span>
      <span style="color: #00af00;">if</span> symbol <span style="color: #ff8700;">`Map.member`</span> st
      <span style="color: #00af00;">then</span> return <span style="color: #ff8700;">$</span> st <span style="color: #ff8700;">Map.!</span> symbol
      <span style="color: #00af00;">else</span> <span style="color: #00af00;">case</span> mp <span style="color: #00af00;">of</span>
        <span style="color: #18b2b2;">Nothing</span> <span style="color: #ff8700;">-&gt;</span> throwError <span style="color: #ff8700;">$</span> <span style="color: #ff1f8b;">"[getSymbol] symbol ["</span> <span style="color: #ff8700;">++</span> symbol <span style="color: #ff8700;">++</span> <span style="color: #ff1f8b;">"] NOT in symbol table!"</span>
        <span style="color: #18b2b2;">Just</span> parent <span style="color: #ff8700;">-&gt;</span> getSymbolFrom symbol parent
</pre>
</div>

<p>
LispList 求值函数也需要做一些调整，最核心的部分是 <code>apply'</code> 函数的实现。现在在函数调用之前我们先用 <code>modify pushContext</code> 压入空的符号表，然后在空的符号表上更新函数参数的值，调用函数，最后将当前栈顶弹出完成一个完整的函数调用过程。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">eval</span> (<span style="color: #18b2b2;">LispSymbol</span> s)     <span style="color: #ff8700;">=</span> getSymbol s
<span style="color: #ef2929;">eval</span> (<span style="color: #18b2b2;">LispList</span> (x<span style="color: #18b2b2;">:</span>xs))  <span style="color: #ff8700;">=</span> eval x <span style="color: #ff8700;">&gt;&gt;=</span> apply <span style="color: #00af00;">where</span>
  apply (<span style="color: #18b2b2;">LispQuot</span> f expectedArgs) <span style="color: #ff8700;">=</span> apply' expectedArgs xs f
  apply (<span style="color: #18b2b2;">LispFunc</span> f expectedArgs) <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
    args <span style="color: #ff8700;">&lt;-</span> mapM eval xs
    apply' expectedArgs args f
  apply expr <span style="color: #ff8700;">=</span> throwError <span style="color: #ff8700;">$</span> <span style="color: #ff1f8b;">"[eval] "</span> <span style="color: #ff8700;">++</span> show expr <span style="color: #ff8700;">++</span> <span style="color: #ff1f8b;">" cannot call as function"</span>
  apply' <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FunctionSignature</span> <span style="color: #ff8700;">-&gt;</span> [<span style="color: #18b2b2;">LispExpr</span>] <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispState</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">LispState</span>
  apply' expectedArgs args f <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
    modify pushContext
    applyArgsToContext expectedArgs args
    result <span style="color: #ff8700;">&lt;-</span> f
    modify popContext
    return result
  applyArgsToContext <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FunctionSignature</span> <span style="color: #ff8700;">-&gt;</span> [<span style="color: #18b2b2;">LispExpr</span>] <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">StateT</span> <span style="color: #18b2b2;">Context</span> <span style="color: #18b2b2;">LispError</span> <span style="color: #18b2b2;">()</span>
  applyArgsToContext (<span style="color: #ff1f8b;">"..."</span><span style="color: #18b2b2;">:</span><span style="color: #00af00;">_</span>) args <span style="color: #ff8700;">=</span> updateSymbol <span style="color: #ff1f8b;">"..."</span> <span style="color: #ff8700;">$</span> <span style="color: #18b2b2;">LispList</span> args
  applyArgsToContext <span style="color: #18b2b2;">[]</span> <span style="color: #00af00;">_</span> <span style="color: #ff8700;">=</span> return <span style="color: #18b2b2;">()</span>
  applyArgsToContext (earg<span style="color: #18b2b2;">:</span>eargs) (arg<span style="color: #18b2b2;">:</span>args) <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
    updateSymbol earg arg
    applyArgsToContext eargs args
</pre>
</div>

<p>
当 <code>lispSet</code> 函数被调用时同样会压入空栈帧，但我们不应该在当前栈顶绑定符号，因为当前栈顶会在 <code>lispSet</code> 函数调用完成后被弹出。所以需要调用 <code>updateSymbolInParent</code> 在上一层栈帧绑定符号和表达式。
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">lispSet</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">LispState</span>
<span style="color: #ef2929;">lispSet</span> <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
  [<span style="color: #18b2b2;">LispSymbol</span> s, expr] <span style="color: #ff8700;">&lt;-</span> getSymbols lispSetArgs
  eval_e <span style="color: #ff8700;">&lt;-</span> eval expr
  updateSymbolInParent s eval_e
  return eval_e
</pre>
</div>

<p>
最后验证一下我们的阶乘函数是否可以正确工作。
</p>

<div class="org-src-container">
<pre class="src src-lisp">lisp&gt; (set prod (<span style="color: #00af00;">lambda</span> (x) (<span style="color: #00af00;">if</span> (eq x 0) 1 (* (prod (- x 1)) x))))
&lt;function&gt;[<span style="color: #ff1f8b;">"x"</span>]
lisp&gt; (prod 5)
120
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="author-info">
      <div id="author">Author: Cycoe (cycoejoo@163.com)</div>
      <div id="date">Date: <2023-03-10 Fri 12:39></div>
      <div id="generator">Generator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.1 (<a href="https://orgmode.org">Org</a> mode 9.6.6)</div>
      <div id="built">Built: <2024-01-27 Sat 21:20></div>
      </div><div id="copyright">
    <img id="cc" src="/static/img/Cc-logo-128x128.png" height="14px" width="14px"/>本站文章如未特殊声明，默认采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">署名-非商业性使用-相同方式共享 2.5 中国大陆</a>进行许可。
</div>
</div>
</body>
</html>