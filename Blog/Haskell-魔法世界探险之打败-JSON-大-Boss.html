<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-06-25 Fri 09:18 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Haskell 魔法世界探险之打败 JSON 小 Boss</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Cycoe">
<link rel="stylesheet" type="text/css" href="/static/css/default.css" />
<link rel="shortcut icon" type="image/png" href="/static/img/favicon.png"/>
<script language="JavaScript" type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script language="JavaScript" type="text/javascript" src="/static/js/main.js"></script>
</head>
<body>
<div id="preamble" class="status">
<div id="top-container">
  <a id="site-name" href="/">Cycoe<span id="at-home">@Home</span></a>
  <div id="banner">Keep It Simple Stupid</div>
</div>

<div id="top-nav">
  <div id="nav-wrapper">
    <div class="nav-btn" id="toc-wrapper">
      <span class="vertical-align">Ξ</span>
      <div id="go-top">
        <a href="javascript:window.scrollTo(0,0)" style="color: black !important; border-bottom: none !important;" class="tooltip" title="Go to the top of the page">
        <span class="top">&uarr;</span>
        </a></div>
    </div>
    <div id="nav-left-wrapper">
      <a class="nav-btn" id="photo-entry" href="/Photo/index.html" title="Photo">Photo</a>
      <a class="nav-btn" id="about-entry" href="/about.html" title="About Me">About</a>
      <div id="nav-title-wrapper">
        <span id="nav-title">Haskell 魔法世界探险之打败 JSON 小 Boss</span>
        <span id="nav-date">Written @<2021-06-12 Sat 14:23></span>
      </div>
    </div>
  </div>
</div>

<!-- The Modal -->
<div id="img-modal" class="modal">
  <!-- The Close Button -->
  <span class="close">&times;</span>
  <!-- Modal Content (The Image) -->
  <img class="modal-content" id="img-wrapper">
  <!-- Modal Caption (Image Text) -->
  <div id="caption"></div>
</div>
</div>
<div id="content">
<header>
<h1 class="title">Haskell 魔法世界探险之打败 JSON 小 Boss</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc8289fe">1. Haskell 魔法世界探险之打败 JSON 大 Boss</a>
<ul>
<li><a href="#org1aa948f">1.1. JSON 类型描述</a></li>
<li><a href="#org5141815">1.2. Parser 解析器类型</a></li>
<li><a href="#org49a7bb9">1.3. 单字符匹配 <code>charP</code></a></li>
<li><a href="#org2cbbaef">1.4. 字符串匹配 <code>stringP</code></a></li>
<li><a href="#org986f85d">1.5. 打败 JsonNull 的法术——群体攻击</a></li>
<li><a href="#org4e2f323">1.6. 打败 JsonBool 的武器——选择攻击</a></li>
<li><a href="#orgda6a1cc">1.7. 打败 JsonNumber 的武器——属性甄别</a></li>
<li><a href="#org0609884">1.8. 打败 JsonString 的法术——护甲忽略术</a></li>
<li><a href="#org1d94a83">1.9. 打败 JsonArray 的武器——无限递归魔法</a></li>
<li><a href="#org5d14185">1.10. 打败 JsonObject 的武器——组合武器</a></li>
<li><a href="#orgaeaeea9">1.11. 实战！</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
进入 Haskell 魔法世界探险也有近两个月了，一直只能打打小怪练级。现在来到了
<code>Functor</code> 、 <code>Monad</code> 、 <code>Applicative</code> 三座大山前，遇到 <code>JSON</code> 小 Boss 拦路，一场不可避免
的战斗即将展开。
</p>

<!-- more -->

<div id="outline-container-orgc8289fe" class="outline-2">
<h2 id="orgc8289fe"><span class="section-number-2">1</span> Haskell 魔法世界探险之打败 JSON 大 Boss</h2>
<div class="outline-text-2" id="text-1">
<p>
注：因 <code>org-babel</code> 与 <code>ghci</code> 配合的问题，文中代码块中的函数定义都需要使用 <code>:{...:}</code> 结
构进行包裹，在实际 haskell 源码中不需要
</p>
</div>

<div id="outline-container-org1aa948f" class="outline-3">
<h3 id="org1aa948f"><span class="section-number-3">1.1</span> JSON 类型描述</h3>
<div class="outline-text-3" id="text-1-1">
<p>
标准的 <code>JSON</code> 数据有六种类型，我们将其表示为 ADT（Algebraic data type），分别为
<code>null</code> 、布尔类型、数字类型、字符串类型、数组类型和对象类型
</p>

<p>
我们使用以下 ADT（Algebraic data type）数据结构 <code>JsonValue</code> 来描述 <code>JSON</code> ，并且实现
了对应的六种构造函数，并使用继承的方法自动实现 <code>Eq</code> 和 <code>Show</code> 类型的接口用于比较和输
出信息
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #00af00;">data</span> <span style="color: #18b2b2;">JsonValue</span>
  <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">JsonNull</span>
  <span style="color: #ff8700;">|</span> <span style="color: #18b2b2;">JsonBool</span> <span style="color: #18b2b2;">Bool</span>
  <span style="color: #ff8700;">|</span> <span style="color: #18b2b2;">JsonNumber</span> <span style="color: #18b2b2;">Int</span>  <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">&#21482;&#25903;&#25345;&#25972;&#22411;</span>
  <span style="color: #ff8700;">|</span> <span style="color: #18b2b2;">JsonString</span> <span style="color: #18b2b2;">String</span>
  <span style="color: #ff8700;">|</span> <span style="color: #18b2b2;">JsonArray</span> <span style="color: #1f5bff; font-weight: bold;">[</span><span style="color: #18b2b2;">JsonValue</span><span style="color: #1f5bff; font-weight: bold;">]</span>
  <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">&#27492;&#22788;&#38190;&#19981;&#33021;&#20351;&#29992; JsonString &#65292;&#22240;&#20026; JsonString &#19981;&#26159;&#19968;&#31181;&#31867;&#22411;&#32780;&#26159; constructor</span>
  <span style="color: #ff8700;">|</span> <span style="color: #18b2b2;">JsonObject</span> <span style="color: #1f5bff; font-weight: bold;">[</span><span style="color: #00af00; font-weight: bold;">(</span><span style="color: #18b2b2;">String</span>, <span style="color: #18b2b2;">JsonValue</span><span style="color: #00af00; font-weight: bold;">)</span><span style="color: #1f5bff; font-weight: bold;">]</span>
  <span style="color: #00af00;">deriving</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">Eq</span>, <span style="color: #18b2b2;">Show</span><span style="color: #1f5bff; font-weight: bold;">)</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org5141815" class="outline-3">
<h3 id="org5141815"><span class="section-number-3">1.2</span> Parser 解析器类型</h3>
<div class="outline-text-3" id="text-1-2">
<p>
想要实现对 JSON 数据的解析，我们需要一系列的组合子（Parser Combinator）用于处理
匹配。而在实现这一系列组合子之前，对组合子的行为进行抽象至关重要。我们将需要的进
行解析的字符串称为 <code>input</code> ，而输入由连续的字符组成。我们希望能向 Parser 中传入一
个 <code>input</code> ，Parser 返回一个解析出的 JsonValue，因此将 Parser 定义为一个泛型
<code>Parser a</code> 可用于对付各种组合子；我们希望 Parser 能直接返回一个 <code>input</code> 剩余部分和
JsonValue 对象的元组，这样我们就可以方便的对剩余部分进行处理；最后，Parser 解析
可能是失败的，因此我们使用 <code>Maybe</code> 类型对结果进行包裹。最终我们的 Parser 定义如下，
"Simple but powerful!"
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #00af00;">newtype</span> <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Parser</span>
  <span style="color: #1f5bff; font-weight: bold;">{</span> <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">Parser &#21253;&#35065;&#20102;&#19968;&#20010;&#20989;&#25968;&#65292;&#36825;&#20010;&#20989;&#25968;&#23558;&#23545; JSON &#36827;&#34892;&#35299;&#26512;</span>
    runParser <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">String</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Maybe</span> <span style="color: #00af00; font-weight: bold;">(</span><span style="color: #18b2b2;">String</span>, a<span style="color: #00af00; font-weight: bold;">)</span>
  <span style="color: #1f5bff; font-weight: bold;">}</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org49a7bb9" class="outline-3">
<h3 id="org49a7bb9"><span class="section-number-3">1.3</span> 单字符匹配 <code>charP</code></h3>
<div class="outline-text-3" id="text-1-3">
<p>
没有什么是比解析单个字符更简单的事情了，我们的第一把武器是一个单兵瞄准镜，对JSON
中的单个字符进行匹配。 <code>charP</code> 接受一个要匹配的字符并生成一个 <code>Parser Char</code> 类型的组
合子，这个解析器接受一个 JSON 字符串，如果字符串的第一个字符是我们要找的，则返回
<code>Just (xs, c)</code> ，否则返回 <code>Nothing</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">charP</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Char</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">Char</span>
<span style="color: #ef2929;">charP</span> c <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #ff8700;">$</span> <span style="color: #ff8700;">\</span>input <span style="color: #ff8700;">-&gt;</span> <span style="color: #00af00;">case</span> input <span style="color: #00af00;">of</span>
  <span style="color: #1f5bff; font-weight: bold;">(</span>x <span style="color: #18b2b2;">:</span> xs<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">|</span> c <span style="color: #ff8700;">==</span> x <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Just</span> <span style="color: #1f5bff; font-weight: bold;">(</span>xs, c<span style="color: #1f5bff; font-weight: bold;">)</span>
  <span style="color: #00af00;">_</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Nothing</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #18b2b2;">:</span>set prompt <span style="color: #ff1f8b;">"GHCi&gt; "</span>
<span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">charP 'a' &#26500;&#36896;&#20102;&#19968;&#20010;&#23547;&#25214;&#24618;&#29289; 'a' &#30340;&#35299;&#26512;&#22120;</span>
<span style="color: #ef2929;">runParser</span> <span style="color: #cc0000; font-weight: bold;">(</span>charP <span style="color: #ff1f8b;">'a'</span><span style="color: #cc0000; font-weight: bold;">)</span> <span style="color: #ff1f8b;">"abc"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; GHCi&gt; GHCi&gt; Just ("bc",'a')
</pre>


<p>
看！ <code>charP 'a'</code> 找到了第一个字符 <code>'a'</code> 并返回了剩余部分 <code>"bc"</code>
</p>
</div>
</div>

<div id="outline-container-org2cbbaef" class="outline-3">
<h3 id="org2cbbaef"><span class="section-number-3">1.4</span> 字符串匹配 <code>stringP</code></h3>
<div class="outline-text-3" id="text-1-4">
<p>
有的时候我们希望匹配一些连续的字符，因此我们需要生成一个针对字符串的 <code>Parser
String</code> 。 <code>String</code> 类型其实就是 <code>[Char]</code> 类型的一个别名，因此我们要构造的就是 <code>Parser
[Char]</code>
</p>

<p>
了解过函数式编程的同学应该都对 <code>map</code> 有所了解。 <code>map</code> 是将一个单体技能复制多份，分别
作用在多个目标上的法术，我们可以试试利用 <code>map</code> 把 <code>charP</code> 作用在一个字符串上。来看看
效果！
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span>t map charP <span style="color: #ff1f8b;">"hello"</span>
</pre>
</div>

<pre class="example">
map charP "hello" :: [Parser Char]
</pre>


<p>
看起来离成功还有一点距离，我们的目标是字符列表的解析器 <code>Parser [Char]</code> ，而不是字
符解析器的列表 <code>[Parser Char]</code> 。幸好我们有 <code>Functor</code> 和 <code>Applicative</code> 两种类型类，可
将更多接口函数装配在我们的 Parser 上。首先使用 <code>Functor</code> 为 <code>Parser</code> 扩展 <code>fmap</code> 接口，
让我们可以使用 <code>fmap</code> 对解析器的解析结果进行变形
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00af00;">import</span> <span style="color: #18b2b2;">Data.Char</span> <span style="color: #cc0000; font-weight: bold;">(</span>ord<span style="color: #cc0000; font-weight: bold;">)</span>

<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #00af00;">instance</span> <span style="color: #18b2b2;">Functor</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #00af00;">where</span>
  <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">fmap &#23558;&#19968;&#20010;&#20989;&#25968;&#20316;&#29992;&#21040; Functor &#21253;&#35065;&#30340;&#20540;&#19978;&#65292; &lt;$&gt; &#26159; fmap &#30340;&#20013;&#32512;&#24418;&#24335;</span>
  <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b</span>
  fmap f <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">Parser</span> p<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #ff8700;">$</span> <span style="color: #ff8700;">\</span>input <span style="color: #ff8700;">-&gt;</span> <span style="color: #00af00;">do</span>
    <span style="color: #1f5bff; font-weight: bold;">(</span>input', c<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;-</span> p input
    <span style="color: #18b2b2;">Just</span> <span style="color: #1f5bff; font-weight: bold;">(</span>input', f c<span style="color: #1f5bff; font-weight: bold;">)</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #18b2b2;">:</span>t ord <span style="color: #ff8700;">&lt;$&gt;</span> charP <span style="color: #ff1f8b;">'a'</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| GHCi&gt; GHCi&gt; ord &lt;$&gt; charP 'a' :: Parser Int
</pre>


<p>
<code>&lt;$&gt;</code> 将一个函数作用到 <code>Parser</code> 的目标值上（此处为 Char），并返回一个 <code>Parser Int</code> 类
型的解析器
</p>

<p>
下面我们使用 <code>Applicative</code> 为 <code>Parser</code> 扩展 <code>pure</code> 和 <code>&lt;*&gt;</code> 接口
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #00af00;">instance</span> <span style="color: #18b2b2;">Applicative</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #00af00;">where</span>
  <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">pure &#23558;&#19968;&#20010;&#26222;&#36890;&#20540;&#21253;&#35065;&#20026;&#19968;&#20010; Applicative &#65292;&#27492;&#22788;&#26500;&#36896;&#19968;&#20010;&#35299;&#26512;&#22120;&#65292;</span>
  <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">&#35813;&#35299;&#26512;&#22120;&#19981;&#28040;&#32791;&#20219;&#20309;&#36755;&#20837;&#65292;&#24182;&#36820;&#22238;&#19968;&#20010; Just (input, x)</span>
  <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">pure :: a -&gt; Parser a</span>
  pure x <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #ff8700;">$</span> <span style="color: #ff8700;">\</span>input <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Just</span> <span style="color: #1f5bff; font-weight: bold;">(</span>input, x<span style="color: #1f5bff; font-weight: bold;">)</span>

  <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">&lt;*&gt; &#23558;&#19968;&#20010;&#30001; Parser &#21253;&#35065;&#30340;&#20989;&#25968;&#20316;&#29992;&#21040; Parser &#19978;&#65292;Parser f &#21644;</span>
  <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">Parser a &#20381;&#27425;&#28040;&#32791;&#36755;&#20837;&#65292;&#24182;&#36820;&#22238; f a</span>
  <span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">(&lt;*&gt;) :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b</span>
  <span style="color: #18b2b2;">Parser</span> f <span style="color: #ff8700;">&lt;*&gt;</span> <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #ff8700;">$</span> <span style="color: #ff8700;">\</span>input <span style="color: #ff8700;">-&gt;</span> <span style="color: #00af00;">do</span>
    <span style="color: #1f5bff; font-weight: bold;">(</span>input', f'<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;-</span> f input
    <span style="color: #1f5bff; font-weight: bold;">(</span>input'', a'<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;-</span> a input'
    return <span style="color: #1f5bff; font-weight: bold;">(</span>input'', f' a'<span style="color: #1f5bff; font-weight: bold;">)</span>

  <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">&lt;*</span> <span style="color: #18b2b2;">Parser</span> b <span style="color: #ff8700;">=</span>
    fst <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #00af00; font-weight: bold;">(</span><span style="color: #18b2b2;">,</span><span style="color: #00af00; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">&lt;*&gt;</span> <span style="color: #18b2b2;">Parser</span> b<span style="color: #1f5bff; font-weight: bold;">)</span>
  <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">*&gt;</span> <span style="color: #18b2b2;">Parser</span> b <span style="color: #ff8700;">=</span>
    snd <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #00af00; font-weight: bold;">(</span><span style="color: #18b2b2;">,</span><span style="color: #00af00; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">&lt;*&gt;</span> <span style="color: #18b2b2;">Parser</span> b<span style="color: #1f5bff; font-weight: bold;">)</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">&#20351;&#29992; &lt;*&gt; &#32452;&#21512; Parser &#65292;&#29992;&#20110;&#35299;&#26512; "he" &#23383;&#31526;&#20018;</span>
<span style="color: #ef2929;">runParser</span> <span style="color: #cc0000; font-weight: bold;">(</span><span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">,</span><span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> charP <span style="color: #ff1f8b;">'h'</span> <span style="color: #ff8700;">&lt;*&gt;</span> charP <span style="color: #ff1f8b;">'e'</span><span style="color: #cc0000; font-weight: bold;">)</span> <span style="color: #ff1f8b;">"hello"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; GHCi&gt; Just ("llo",('h','e'))
</pre>


<p>
值得纪念的一刻，我们使用 <code>charP</code> 组合子实现了我们第一个组合 Parser ！那么我们将这
个链加长，并且使用 <code>(:)</code> 进行组合呢？
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">abcP &#21305;&#37197;&#23383;&#31526;&#20018; "abc"</span>
<span style="color: #ef2929;">abcP</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">String</span>
<span style="color: #ef2929;">abcP</span> <span style="color: #ff8700;">=</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">:</span><span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> charP <span style="color: #ff1f8b;">'a'</span> <span style="color: #ff8700;">&lt;*&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #00af00; font-weight: bold;">(</span><span style="color: #ff4ea3; font-weight: bold;">(</span><span style="color: #18b2b2;">:</span><span style="color: #ff4ea3; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> charP <span style="color: #ff1f8b;">'b'</span><span style="color: #00af00; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;*&gt;</span> <span style="color: #00af00; font-weight: bold;">(</span><span style="color: #ff4ea3; font-weight: bold;">(</span><span style="color: #00d7af; font-weight: bold;">(</span><span style="color: #18b2b2;">:</span><span style="color: #00d7af; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> charP <span style="color: #ff1f8b;">'c'</span><span style="color: #ff4ea3; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;*&gt;</span> pure <span style="color: #ff4ea3; font-weight: bold;">[]</span><span style="color: #00af00; font-weight: bold;">)</span><span style="color: #1f5bff; font-weight: bold;">)</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> abcP <span style="color: #ff1f8b;">"abcdef"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just ("def","abc")
</pre>


<p>
Amazing! 我们成功使用 <code>&lt;$&gt;</code> 和 <code>&lt;*&gt;</code> 组合出了字符串解析器。但是我们不能在每次使用的
时候才进行组合，函数式的精髓在于抽象，我们需要一个函数将这个组合过程进行抽象复用，
这个函数就是 <code>sequenceA</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">sequenceA</span> <span style="color: #ff8700;">::</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">Applicative</span> f<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">=&gt;</span> <span style="color: #1f5bff; font-weight: bold;">[</span>f a<span style="color: #1f5bff; font-weight: bold;">]</span> <span style="color: #ff8700;">-&gt;</span> f <span style="color: #1f5bff; font-weight: bold;">[</span>a<span style="color: #1f5bff; font-weight: bold;">]</span>
<span style="color: #ef2929;">sequenceA</span> <span style="color: #1f5bff; font-weight: bold;">(</span>f <span style="color: #18b2b2;">:</span> fs<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">=</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">:</span><span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> f <span style="color: #ff8700;">&lt;*&gt;</span> sequenceA fs
<span style="color: #ef2929;">sequenceA</span> <span style="color: #00af00;">_</span>        <span style="color: #ff8700;">=</span> pure <span style="color: #1f5bff; font-weight: bold;">[]</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> <span style="color: #cc0000; font-weight: bold;">(</span>sequenceA <span style="color: #ff8700;">$</span> charP <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #ff1f8b;">"hello"</span><span style="color: #cc0000; font-weight: bold;">)</span> <span style="color: #ff1f8b;">"hello, world!"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just (", world!","hello")
</pre>


<p>
到此为止，我们拥有了实现字符串解析器的所有前置条件，可以顺利打造我们的群体攻击武
器 <code>stringP</code> ，输入一个待匹配的字符串，返回一个字符串解析器
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">stringP</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">String</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">String</span>
<span style="color: #ef2929;">stringP</span> s <span style="color: #ff8700;">=</span> sequenceA <span style="color: #ff8700;">$</span> charP <span style="color: #ff8700;">&lt;$&gt;</span> s
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> <span style="color: #cc0000; font-weight: bold;">(</span>stringP <span style="color: #ff1f8b;">"hello"</span><span style="color: #cc0000; font-weight: bold;">)</span> <span style="color: #ff1f8b;">"hello, world!"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just (", world!","hello")
</pre>
</div>
</div>

<div id="outline-container-org986f85d" class="outline-3">
<h3 id="org986f85d"><span class="section-number-3">1.5</span> 打败 JsonNull 的法术——群体攻击</h3>
<div class="outline-text-3" id="text-1-5">
<p>
有了以上的基础设施，我们就可以很容易地写出针对 <code>JsonNull</code> 的解析器了。在 JSON 中，
每个字符串 <code>null</code> 都代表了一个 <code>JsonNull</code> 类型的值，因此我们只需对字符串 <code>null</code> 进行匹
配
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">jsonNull</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">JsonValue</span>
<span style="color: #ef2929;">jsonNull</span> <span style="color: #ff8700;">=</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #ff8700;">\</span><span style="color: #00af00;">_</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">JsonNull</span><span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> stringP <span style="color: #ff1f8b;">"null"</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> jsonNull <span style="color: #ff1f8b;">"null"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just ("",JsonNull)
</pre>
</div>
</div>

<div id="outline-container-org4e2f323" class="outline-3">
<h3 id="org4e2f323"><span class="section-number-3">1.6</span> 打败 JsonBool 的武器——选择攻击</h3>
<div class="outline-text-3" id="text-1-6">
<p>
消灭掉 JsonNull 后我们遇到了 JsonBool，JsonBool 构造器对应的值有 <code>JsonBool True</code>
和 <code>JsonBool False</code> 。在 JSON 数据中， <code>true</code> 和 <code>false</code> 就代表了 JsonBool 类型的数据，
我们只需要匹配这两个字符串即可。但这时又有一个问题，我们只可能匹配上 true 和
false 中的一个，当一个匹配失败时才需要尝试另一个。为解决这个问题我们引入
<code>Alternative</code> 类型类来扩展我们的 Parser
</p>

<p>
<code>Alternative</code> 类型类需要实现 <code>&lt;|&gt;</code> 和 <code>empty</code> 接口，如 <code>Maybe</code> 就是 <code>Alternative</code> 类型类的
一个实例
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00af00;">import</span> <span style="color: #18b2b2;">Control.Applicative</span>

<span style="color: #18b2b2;">Nothing</span> <span style="color: #ef2929;">&lt;|&gt;</span> <span style="color: #18b2b2;">Just</span> 4 <span style="color: #ff8700;">&lt;|&gt;</span> <span style="color: #18b2b2;">Just</span> 5
</pre>
</div>

<pre class="example">
GHCi&gt; Just 4
</pre>


<p>
<code>&lt;|&gt;</code> 返回第一个有效值，我们将 <code>Parser</code> 实现为 <code>Alternative</code> 的实例
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #00af00;">instance</span> <span style="color: #18b2b2;">Alternative</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #00af00;">where</span>
  <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">Parser</span> p1<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;|&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">Parser</span> p2<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #ff8700;">$</span> <span style="color: #ff8700;">\</span>input <span style="color: #ff8700;">-&gt;</span>
    p1 input <span style="color: #ff8700;">&lt;|&gt;</span> p2 input
  empty <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #ff8700;">$</span> const <span style="color: #18b2b2;">Nothing</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">&#20351;&#29992; &lt;|&gt; &#21305;&#37197; true &#25110; false</span>
<span style="color: #ef2929;">runParser</span> <span style="color: #cc0000; font-weight: bold;">(</span>stringP <span style="color: #ff1f8b;">"true"</span> <span style="color: #ff8700;">&lt;|&gt;</span> stringP <span style="color: #ff1f8b;">"false"</span><span style="color: #cc0000; font-weight: bold;">)</span> <span style="color: #ff1f8b;">"false"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; GHCi&gt; Just ("","false")
</pre>


<p>
JsonBool 对应的解析器构造器可定义为
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">jsonBool</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">JsonValue</span>
<span style="color: #ef2929;">jsonBool</span> <span style="color: #ff8700;">=</span> construct <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span>stringP <span style="color: #ff1f8b;">"true"</span> <span style="color: #ff8700;">&lt;|&gt;</span> stringP <span style="color: #ff1f8b;">"false"</span><span style="color: #1f5bff; font-weight: bold;">)</span>
  <span style="color: #00af00;">where</span>
    construct <span style="color: #ff1f8b;">"true"</span> <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">JsonBool</span> <span style="color: #18b2b2;">True</span>
    construct <span style="color: #ff1f8b;">"false"</span> <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">JsonBool</span> <span style="color: #18b2b2;">False</span>
    construct <span style="color: #00af00;">_</span> <span style="color: #ff8700;">=</span> undefined
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> jsonBool <span style="color: #ff1f8b;">"false, something"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just (", something",JsonBool False)
</pre>
</div>
</div>

<div id="outline-container-orgda6a1cc" class="outline-3">
<h3 id="orgda6a1cc"><span class="section-number-3">1.7</span> 打败 JsonNumber 的武器——属性甄别</h3>
<div class="outline-text-3" id="text-1-7">
<p>
数字（整数）是由一组连续的数字字符组成，因此我们需要读取一串连续的数字字符，并将
其转为 <code>Int</code> 格式。这里我们使用函数 <code>span</code> 构造一个 <code>spanP</code> ，函数 <code>span</code> 接受一个谓词并
返回列表开头满足谓词的部分
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00af00;">import</span> <span style="color: #18b2b2;">GHC.Unicode</span> <span style="color: #cc0000; font-weight: bold;">(</span>isDigit<span style="color: #cc0000; font-weight: bold;">)</span>

<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">spanP &#20351;&#29992;&#35859;&#35789; p &#23545;&#23383;&#31526;&#36827;&#34892;&#21305;&#37197;&#65292;&#30452;&#21040;&#35859;&#35789;&#21028;&#26029;&#36820;&#22238; False</span>
<span style="color: #ef2929;">spanP</span> <span style="color: #ff8700;">::</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">Char</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Bool</span><span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">String</span>
<span style="color: #ef2929;">spanP</span> p <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #ff8700;">$</span> <span style="color: #ff8700;">\</span>input <span style="color: #ff8700;">-&gt;</span>
  <span style="color: #00af00;">let</span> <span style="color: #1f5bff; font-weight: bold;">(</span>token, rest<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">=</span> span p input
   <span style="color: #00af00;">in</span> <span style="color: #18b2b2;">Just</span> <span style="color: #1f5bff; font-weight: bold;">(</span>rest, token<span style="color: #1f5bff; font-weight: bold;">)</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> <span style="color: #cc0000; font-weight: bold;">(</span>spanP isDigit<span style="color: #cc0000; font-weight: bold;">)</span> <span style="color: #ff1f8b;">"123abc"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| GHCi&gt; GHCi&gt; Just ("abc","123")
</pre>


<p>
使用 <code>isDigit</code> 作为谓词，将字符串开头的数字字符分割了出来，接下来只需要将数字字符
串转化为 <code>Int</code> 即可
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">jsonNumber</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">JsonValue</span>
<span style="color: #ef2929;">jsonNumber</span> <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">JsonNumber</span> <span style="color: #ff8700;">.</span> read <span style="color: #ff8700;">&lt;$&gt;</span> spanP isDigit
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> jsonNumber <span style="color: #ff1f8b;">"123abc"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just ("abc",JsonNumber 123)
</pre>


<p>
嗯。。看起来可以运行，但是传入非数字开头的字符串呢？
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #ef2929;">runParser</span> jsonNumber <span style="color: #ff1f8b;">"hello"</span>
</pre>
</div>

<pre class="example">
Just ("hello",JsonNumber *** Exception: Prelude.read: no parse
</pre>


<p>
哈哈哈哈， <code>Int</code> 类型的 <code>read</code> 函数无法从空字符串读取一个值，我们需要一个函数来对
Parser 的结果进行判空，如果 <code>read</code> 函数的输入为空则直接返回 <code>Nothing</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">notNullP</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #1f5bff; font-weight: bold;">[</span>a<span style="color: #1f5bff; font-weight: bold;">]</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #1f5bff; font-weight: bold;">[</span>a<span style="color: #1f5bff; font-weight: bold;">]</span>
<span style="color: #ef2929;">notNullP</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">Parser</span> p<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #ff8700;">$</span> <span style="color: #ff8700;">\</span>input <span style="color: #ff8700;">-&gt;</span> <span style="color: #00af00;">do</span>
  <span style="color: #1f5bff; font-weight: bold;">(</span>input', x<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;-</span> p input
  <span style="color: #00af00;">case</span> x <span style="color: #00af00;">of</span>
    <span style="color: #1f5bff; font-weight: bold;">[]</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Nothing</span>
    <span style="color: #00af00;">_</span> <span style="color: #ff8700;">-&gt;</span> return <span style="color: #1f5bff; font-weight: bold;">(</span>input', x<span style="color: #1f5bff; font-weight: bold;">)</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> <span style="color: #cc0000; font-weight: bold;">(</span>notNullP <span style="color: #ff8700;">$</span> stringP <span style="color: #ff1f8b;">""</span><span style="color: #cc0000; font-weight: bold;">)</span> <span style="color: #ff1f8b;">"hello"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Nothing
</pre>


<p>
那么我们的 <code>jsonNumber</code> 可改写为
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">jsonNumber</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">JsonValue</span>
<span style="color: #ef2929;">jsonNumber</span> <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">JsonNumber</span> <span style="color: #ff8700;">.</span> read <span style="color: #ff8700;">&lt;$&gt;</span> notNullP <span style="color: #1f5bff; font-weight: bold;">(</span>spanP isDigit<span style="color: #1f5bff; font-weight: bold;">)</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> jsonNumber <span style="color: #ff1f8b;">"hello"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Nothing
</pre>
</div>
</div>

<div id="outline-container-org0609884" class="outline-3">
<h3 id="org0609884"><span class="section-number-3">1.8</span> 打败 JsonString 的法术——护甲忽略术</h3>
<div class="outline-text-3" id="text-1-8">
<p>
<code>JsonString</code> 与我们之前碰到的类型都不同，因为 <code>JsonString</code> 在 JSON 中表示为这样的形
式 <code>\"hello\"</code> ，一个由引号包裹的字符串。在我们的解析结果中我们将忽略引号，只需要
引号中包裹的本体，即被称为 literal(字面值) 的部分。因此在这节中我们需要的是一种
能够忽略护甲 <code>""</code> 的技术，这种技术让我们可以选择性地忽略匹配到字符串的一部分。在
<code>stringP</code> 一章中定义 Parser 为 Applicative 实例时我们就已经实现了接口 <code>&lt;*</code> 和 <code>*&gt;</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #00af00;">instance</span> <span style="color: #18b2b2;">Applicative</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #00af00;">where</span>
  <span style="color: #b2b2b2; font-style: italic;">--</span><span style="color: #b2b2b2; font-style: italic;">- &lt;* &#32452;&#21512;&#20004;&#20010; Parser &#24182;&#36820;&#22238;&#24038;&#36793;&#37027;&#20010;&#30340;&#32467;&#26524;</span>
  <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">&lt;*</span> <span style="color: #18b2b2;">Parser</span> b <span style="color: #ff8700;">=</span>
    fst <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #00af00; font-weight: bold;">(</span><span style="color: #18b2b2;">,</span><span style="color: #00af00; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">&lt;*&gt;</span> <span style="color: #18b2b2;">Parser</span> b<span style="color: #1f5bff; font-weight: bold;">)</span>
  <span style="color: #b2b2b2; font-style: italic;">--</span><span style="color: #b2b2b2; font-style: italic;">- *&gt; &#32452;&#21512;&#20004;&#20010; Parser &#24182;&#36820;&#22238;&#21491;&#36793;&#37027;&#20010;&#30340;&#32467;&#26524;</span>
  <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">*&gt;</span> <span style="color: #18b2b2;">Parser</span> b <span style="color: #ff8700;">=</span>
    snd <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #00af00; font-weight: bold;">(</span><span style="color: #18b2b2;">,</span><span style="color: #00af00; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">&lt;*&gt;</span> <span style="color: #18b2b2;">Parser</span> b<span style="color: #1f5bff; font-weight: bold;">)</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>
</pre>
</div>

<p>
利用这种忽略护甲的技术，我们就可以锁定字符串中表示字符串的部分，并通过忽略护甲得
到 JsonString
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">literalP</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">String</span>
<span style="color: #ef2929;">literalP</span> <span style="color: #ff8700;">=</span> charP <span style="color: #ff1f8b;">'"'</span> <span style="color: #ff8700;">*&gt;</span> spanP <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #ff8700;">/=</span> <span style="color: #ff1f8b;">'"'</span><span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;*</span> charP <span style="color: #ff1f8b;">'"'</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> literalP <span style="color: #ff1f8b;">"\"hello, world!\""</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just ("","hello, world!")
</pre>


<p>
那么，针对 JsonString 我们可以定义如下组合子
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">jsonString</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">JsonValue</span>
<span style="color: #ef2929;">jsonString</span> <span style="color: #ff8700;">=</span> <span style="color: #18b2b2;">JsonString</span> <span style="color: #ff8700;">&lt;$&gt;</span> literalP
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> jsonString <span style="color: #ff1f8b;">"\"hello, world!\""</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just ("",JsonString "hello, world!")
</pre>
</div>
</div>

<div id="outline-container-org1d94a83" class="outline-3">
<h3 id="org1d94a83"><span class="section-number-3">1.9</span> 打败 JsonArray 的武器——无限递归魔法</h3>
<div class="outline-text-3" id="text-1-9">
<p>
随着我们拥有的组合子越来越丰富，解析过程也变得越来越简单，这就是函数式的魅力所在
吧。接下来我们将面对 JsonArray 类型，JsonArray 与我们之前碰到的类型都不同。
JsonArray 是一种不定长的类型，也就是说，我们无法在匹配之前得知这个数组的具体长度。
但是可以对 JsonArray 进行侧写，JsonArray 是由 <code>[</code> 和 <code>]</code> 包裹起来的，括号中间有一些
由逗号分隔的值，每一个值都可解析为 JsonValue。
</p>

<p>
在此之前我们需要实现一个辅助函数，这个函数可以将一个组合子的目标复制任意多次，用
于匹配多个连续的目标
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">many use recursive to match p, if match fails return pure []</span>
<span style="color: #ef2929;">many</span> <span style="color: #ff8700;">::</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">Alternative</span> p<span style="color: #1f5bff; font-weight: bold;">)</span><span style="color: #ff8700;">=&gt;</span> p a <span style="color: #ff8700;">=&gt;</span> p <span style="color: #1f5bff; font-weight: bold;">[</span>a<span style="color: #1f5bff; font-weight: bold;">]</span>
<span style="color: #ef2929;">many</span> p <span style="color: #ff8700;">=</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">:</span><span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> p <span style="color: #ff8700;">&lt;*&gt;</span> many p <span style="color: #ff8700;">&lt;|&gt;</span> pure <span style="color: #1f5bff; font-weight: bold;">[]</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> <span style="color: #cc0000; font-weight: bold;">(</span>many <span style="color: #ff8700;">$</span> stringP <span style="color: #ff1f8b;">"hello"</span><span style="color: #cc0000; font-weight: bold;">)</span> <span style="color: #ff1f8b;">"hellohello, world!"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just (", world!",["hello","hello"])
</pre>


<p>
那么 JsonArray 中间由逗号分隔的元素可由组合子 <code>sepBy</code> 匹配， <code>sepBy</code> 先匹配一个元素，
再匹配多次 <code>, elem</code> 这种模式组合。如果匹配失败，意味着数组中没有元素，则返回 <code>pure
[]</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">sepBy</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Parser</span> b <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #1f5bff; font-weight: bold;">[</span>b<span style="color: #1f5bff; font-weight: bold;">]</span>
<span style="color: #ef2929;">sepBy</span> sep element <span style="color: #ff8700;">=</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">:</span><span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;$&gt;</span> element <span style="color: #ff8700;">&lt;*&gt;</span> many <span style="color: #1f5bff; font-weight: bold;">(</span>sep <span style="color: #ff8700;">*&gt;</span> element<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #ff8700;">&lt;|&gt;</span> pure <span style="color: #1f5bff; font-weight: bold;">[]</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> <span style="color: #cc0000; font-weight: bold;">(</span>sepBy <span style="color: #1f5bff; font-weight: bold;">(</span>charP <span style="color: #ff1f8b;">','</span><span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #1f5bff; font-weight: bold;">(</span>stringP <span style="color: #ff1f8b;">"hello"</span><span style="color: #1f5bff; font-weight: bold;">)</span><span style="color: #cc0000; font-weight: bold;">)</span> <span style="color: #ff1f8b;">"hello,hello,hello,world!"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just (",world!",["hello","hello","hello"])
</pre>


<p>
在实际情况中，数组括号与元素以及元素与逗号之间可能存在任意多的空格，因此需要定义
一个 <code>spaceP</code> 组合子用于匹配空格
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00af00;">import</span> <span style="color: #18b2b2;">GHC.Unicode</span> <span style="color: #cc0000; font-weight: bold;">(</span>isSpace<span style="color: #cc0000; font-weight: bold;">)</span>
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">spaceP</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">String</span>
<span style="color: #ef2929;">spaceP</span> <span style="color: #ff8700;">=</span> spanP isSpace
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> <span style="color: #cc0000; font-weight: bold;">(</span>sepBy <span style="color: #1f5bff; font-weight: bold;">(</span>spaceP <span style="color: #ff8700;">*&gt;</span> charP <span style="color: #ff1f8b;">','</span> <span style="color: #ff8700;">&lt;*</span> spaceP<span style="color: #1f5bff; font-weight: bold;">)</span> <span style="color: #1f5bff; font-weight: bold;">(</span>stringP <span style="color: #ff1f8b;">"hello"</span><span style="color: #1f5bff; font-weight: bold;">)</span><span style="color: #cc0000; font-weight: bold;">)</span> <span style="color: #ff1f8b;">"hello,  hello  ,hello"</span>
</pre>
</div>

<pre class="example">
Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| Prelude Data.Char Control.Applicative GHC.Unicode GHC.Unicode| GHCi&gt; GHCi&gt; Just ("",["hello","hello","hello"])
</pre>


<p>
那么 <code>jsonArray</code> 组合子可表示为
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">jsonArray</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">JsonValue</span>
<span style="color: #ef2929;">jsonArray</span> <span style="color: #ff8700;">=</span>
  <span style="color: #18b2b2;">JsonArray</span> <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span>charP <span style="color: #ff1f8b;">'['</span> <span style="color: #ff8700;">*&gt;</span> spaceP <span style="color: #ff8700;">*&gt;</span>
                 elements
                 <span style="color: #ff8700;">&lt;*</span> spaceP <span style="color: #ff8700;">&lt;*</span> charP <span style="color: #ff1f8b;">']'</span><span style="color: #1f5bff; font-weight: bold;">)</span>
  <span style="color: #00af00;">where</span> elements <span style="color: #ff8700;">=</span> sepBy <span style="color: #1f5bff; font-weight: bold;">(</span>spaceP <span style="color: #ff8700;">*&gt;</span> charP <span style="color: #ff1f8b;">','</span> <span style="color: #ff8700;">&lt;*</span> spaceP<span style="color: #1f5bff; font-weight: bold;">)</span> jsonValue

<span style="color: #ef2929;">jsonValue</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">JsonValue</span>
<span style="color: #ef2929;">jsonValue</span> <span style="color: #ff8700;">=</span> jsonNull <span style="color: #ff8700;">&lt;|&gt;</span> jsonBool <span style="color: #ff8700;">&lt;|&gt;</span> jsonNumber <span style="color: #ff8700;">&lt;|&gt;</span> jsonString <span style="color: #ff8700;">&lt;|&gt;</span> jsonArray
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> jsonArray <span style="color: #ff1f8b;">"[1, true, null]"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just ("",JsonArray [JsonNumber 1,JsonBool True,JsonNull])
</pre>
</div>
</div>

<div id="outline-container-org5d14185" class="outline-3">
<h3 id="org5d14185"><span class="section-number-3">1.10</span> 打败 JsonObject 的武器——组合武器</h3>
<div class="outline-text-3" id="text-1-10">
<p>
来到最后的战斗，有了前面打败前五种 JsonValue 的经验和积累，对付 JsonObject 变得
手到擒来。JsonObject 由 <code>{</code> 和 <code>}</code> 括号包裹，其中包含一些由逗号分隔的键值对，键值对
由冒号分隔
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">Treat jsonObject as jsonValue, otherwise we cannot use jsonObject as</span>
<span style="color: #b2b2b2; font-style: italic;">-- </span><span style="color: #b2b2b2; font-style: italic;">jsonValue below</span>
<span style="color: #ef2929;">jsonValue</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">JsonValue</span>
<span style="color: #ef2929;">jsonValue</span> <span style="color: #ff8700;">=</span> jsonNull <span style="color: #ff8700;">&lt;|&gt;</span> jsonBool <span style="color: #ff8700;">&lt;|&gt;</span> jsonNumber <span style="color: #ff8700;">&lt;|&gt;</span> jsonString <span style="color: #ff8700;">&lt;|&gt;</span> jsonArray <span style="color: #ff8700;">&lt;|&gt;</span> jsonObject

<span style="color: #ef2929;">jsonArray</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">JsonValue</span>
<span style="color: #ef2929;">jsonArray</span> <span style="color: #ff8700;">=</span>
  <span style="color: #18b2b2;">JsonArray</span> <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span>charP <span style="color: #ff1f8b;">'['</span> <span style="color: #ff8700;">*&gt;</span> spaceP <span style="color: #ff8700;">*&gt;</span>
                 elements
                 <span style="color: #ff8700;">&lt;*</span> spaceP <span style="color: #ff8700;">&lt;*</span> charP <span style="color: #ff1f8b;">']'</span><span style="color: #1f5bff; font-weight: bold;">)</span>
  <span style="color: #00af00;">where</span> elements <span style="color: #ff8700;">=</span> sepBy <span style="color: #1f5bff; font-weight: bold;">(</span>spaceP <span style="color: #ff8700;">*&gt;</span> charP <span style="color: #ff1f8b;">','</span> <span style="color: #ff8700;">&lt;*</span> spaceP<span style="color: #1f5bff; font-weight: bold;">)</span> jsonValue

<span style="color: #ef2929;">jsonObject</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">Parser</span> <span style="color: #18b2b2;">JsonValue</span>
<span style="color: #ef2929;">jsonObject</span> <span style="color: #ff8700;">=</span>
  <span style="color: #18b2b2;">JsonObject</span> <span style="color: #ff8700;">&lt;$&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span>charP <span style="color: #ff1f8b;">'{'</span> <span style="color: #ff8700;">*&gt;</span> spaceP <span style="color: #ff8700;">*&gt;</span>
                  sepBy <span style="color: #00af00; font-weight: bold;">(</span>spaceP <span style="color: #ff8700;">*&gt;</span> charP <span style="color: #ff1f8b;">','</span> <span style="color: #ff8700;">&lt;*</span> spaceP<span style="color: #00af00; font-weight: bold;">)</span> pair
                  <span style="color: #ff8700;">&lt;*</span> spaceP <span style="color: #ff8700;">&lt;*</span> charP <span style="color: #ff1f8b;">'}'</span><span style="color: #1f5bff; font-weight: bold;">)</span>
  <span style="color: #00af00;">where</span> pair <span style="color: #ff8700;">=</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #ff8700;">\</span>key <span style="color: #00af00;">_</span> value <span style="color: #ff8700;">-&gt;</span> <span style="color: #00af00; font-weight: bold;">(</span>key, value<span style="color: #00af00; font-weight: bold;">)</span><span style="color: #1f5bff; font-weight: bold;">)</span>
          <span style="color: #ff8700;">&lt;$&gt;</span> literalP
          <span style="color: #ff8700;">&lt;*&gt;</span> <span style="color: #1f5bff; font-weight: bold;">(</span>spaceP <span style="color: #ff8700;">*&gt;</span> charP <span style="color: #ff1f8b;">':'</span> <span style="color: #ff8700;">*&gt;</span> spaceP<span style="color: #1f5bff; font-weight: bold;">)</span>
          <span style="color: #ff8700;">&lt;*&gt;</span> jsonValue
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">runParser</span> jsonObject <span style="color: #ff1f8b;">"{\"primes\" : [2, 3, 5, 7, 11]}"</span>
</pre>
</div>

<pre class="example">
GHCi&gt; Just ("",JsonObject [("primes",JsonArray [JsonNumber 2,JsonNumber 3,JsonNumber 5,JsonNumber 7,JsonNumber 11])])
</pre>
</div>
</div>

<div id="outline-container-orgaeaeea9" class="outline-3">
<h3 id="orgaeaeea9"><span class="section-number-3">1.11</span> 实战！</h3>
<div class="outline-text-3" id="text-1-11">
<p>
我们从 Firefox 的缓存目录随便找了一个 JSON 文件，我们先来看看文件内容
</p>

<pre class="example" id="org294830f">
{"defaultHandlersVersion":{"en-US":4},"mimeTypes":{"application/pdf":{"action":3,"extensions":["pdf"]},"text/xml":{"action":3,"extensions":["xml"]},"image/svg+xml":{"action":3,"extensions":["svg"]},"image/webp":{"action":3,"extensions":["webp"]},"application/zip":{"action":0,"ask":true,"extensions":["zip"]},"application/x-xz":{"action":0,"ask":true,"extensions":["xz"]}},"schemes":{"irc":{"stubEntry":true,"handlers":[null,{"name":"Mibbit","uriTemplate":"https://www.mibbit.com/?url=%s"}]},"ircs":{"stubEntry":true,"handlers":[null,{"name":"Mibbit","uriTemplate":"https://www.mibbit.com/?url=%s"}]},"mailto":{"stubEntry":true,"handlers":[null,{"name":"Yahoo! Mail","uriTemplate":"https://compose.mail.yahoo.com/?To=%s"},{"name":"Gmail","uriTemplate":"https://mail.google.com/mail/?extsrc=mailto&amp;url=%s"}]}}}
</pre>

<p>
文件中基本包含了六种 JsonValue 数据，现在，让我们用自己实现的 JsonValue Parser
去解析看看结果吧！
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">{</span>
<span style="color: #ef2929;">parseFile</span> <span style="color: #ff8700;">::</span> <span style="color: #18b2b2;">FilePath</span> <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">Parser</span> a <span style="color: #ff8700;">-&gt;</span> <span style="color: #18b2b2;">IO</span> <span style="color: #1f5bff; font-weight: bold;">(</span><span style="color: #18b2b2;">Maybe</span> a<span style="color: #1f5bff; font-weight: bold;">)</span>
<span style="color: #ef2929;">parseFile</span> fileName parser <span style="color: #ff8700;">=</span> <span style="color: #00af00;">do</span>
  input <span style="color: #ff8700;">&lt;-</span> readFile fileName
  return <span style="color: #ff8700;">$</span> snd <span style="color: #ff8700;">&lt;$&gt;</span> runParser parser input
<span style="color: #18b2b2;">:</span><span style="color: #cc0000; font-weight: bold;">}</span>

<span style="color: #ef2929;">parseFile</span> <span style="color: #ff1f8b;">"Haskell-&#39764;&#27861;&#19990;&#30028;&#25506;&#38505;&#20043;&#25171;&#36133;-JSON-&#22823;-Boss/handlers.json"</span> jsonValue
</pre>
</div>

<pre class="example">
GHCi&gt; Just (JsonObject [("defaultHandlersVersion",JsonObject [("en-US",JsonNumber 4)]),("mimeTypes",JsonObject [("application/pdf",JsonObject [("action",JsonNumber 3),("extensions",JsonArray [JsonString "pdf"])]),("text/xml",JsonObject [("action",JsonNumber 3),("extensions",JsonArray [JsonString "xml"])]),("image/svg+xml",JsonObject [("action",JsonNumber 3),("extensions",JsonArray [JsonString "svg"])]),("image/webp",JsonObject [("action",JsonNumber 3),("extensions",JsonArray [JsonString "webp"])]),("application/zip",JsonObject [("action",JsonNumber 0),("ask",JsonBool True),("extensions",JsonArray [JsonString "zip"])]),("application/x-xz",JsonObject [("action",JsonNumber 0),("ask",JsonBool True),("extensions",JsonArray [JsonString "xz"])])]),("schemes",JsonObject [("irc",JsonObject [("stubEntry",JsonBool True),("handlers",JsonArray [JsonNull,JsonObject [("name",JsonString "Mibbit"),("uriTemplate",JsonString "https://www.mibbit.com/?url=%s")]])]),("ircs",JsonObject [("stubEntry",JsonBool True),("handlers",JsonArray [JsonNull,JsonObject [("name",JsonString "Mibbit"),("uriTemplate",JsonString "https://www.mibbit.com/?url=%s")]])]),("mailto",JsonObject [("stubEntry",JsonBool True),("handlers",JsonArray [JsonNull,JsonObject [("name",JsonString "Yahoo! Mail"),("uriTemplate",JsonString "https://compose.mail.yahoo.com/?To=%s")],JsonObject [("name",JsonString "Gmail"),("uriTemplate",JsonString "https://mail.google.com/mail/?extsrc=mailto&amp;url=%s")]])])])])
</pre>


<p>
Amazing! we implement a JSON parser from scratch!
</p>

<p>
我们的 JSON Parser 还有一些可以优化的地方：
</p>
<ol class="org-ol">
<li>目前 jsonNumber 还只能处理整型，或许可以通过一些小的修改使其可以匹配浮点数</li>
<li>匹配成功会返回结果，失败只会返回 <code>Nothing</code> ，加上错误位置的上下文、期望值、实际
值会更好，可以使用 <code>Either</code> 类型来传递错误信息</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="author-info">
      <div id="author">Author: Cycoe (cycoejoo@163.com)</div>
      <div id="date">Date: <2021-06-12 Sat 14:23></div>
      <div id="generator">Generator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.0.50 (<a href="https://orgmode.org">Org</a> mode 9.4.4)</div>
      <div id="built">Built: <2021-06-25 Fri 09:18></div>
      </div><div id="copyright">
    <img id="cc" src="/static/img/Cc-logo-128x128.png" height="14px" width="14px"/>本站文章如未特殊声明，默认采用<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank">署名-非商业性使用-相同方式共享 2.5 中国大陆</a>进行许可。
</div>
</div>
</body>
</html>
